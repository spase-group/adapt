(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.AskNicely = {}));
}(this, (function (exports) { 'use strict';

	var symbols = {
	  isMatchForPart: Symbol('_isMatchForPart'),
	  spliceInputFromParts: Symbol('_spliceInputFromParts'),
	  updateInputSpecsAfterMatch: Symbol('_updateInputSpecsAfterMatch'),
	  updateTiersAfterMatch: Symbol('_updateTiersAfterMatch'),
	  applyDefault: Symbol('_applyDefault'),
	  validateInput: Symbol('_validateInput'),
	  createContributionToRequestObject: Symbol('_createContributionToRequestObject')
	};

	class NamedSyntaxPart {
	  /**
	   * @param {string} name
	   */
	  constructor(name) {
	    this.name = name;
	    this.description = null;
	  }
	  /**
	   * Signals the parser that an input part matches this NamedSyntaxPart definition.
	   * @param part
	   * @return {boolean}
	   */


	  [symbols.isMatchForPart](part) {
	    throw new Error('Not implemented.');
	  }
	  /**
	   * Describes how the value should be temporarily stored together with it's defining NamedSyntaxPart
	   * @param {NamedSyntaxPart} resolvedInputSpecs
	   * @param {*} inputValue
	   * @return {Array}
	   */


	  [symbols.updateInputSpecsAfterMatch](resolvedInputSpecs, inputValue) {
	    resolvedInputSpecs.push({
	      syntax: this,
	      input: inputValue
	    });
	    return resolvedInputSpecs;
	  }
	  /**
	   * Describes how to extract an input value from input parts. Is expected to mutate `parts`, and return (a temporary)
	   * input value.
	   * @param parts
	   * @return {*}
	   */


	  [symbols.spliceInputFromParts](parts) {
	    throw new Error('Not implemented.');
	  }
	  /**
	   * Describes how a temporarily stored input value (from `spliceInputFromParts`) is written to the Request object.
	   * Is not expected to return anything.
	   * @param {Request} request
	   * @param {*} input
	   */


	  [symbols.createContributionToRequestObject](accumulated, input) {
	    throw new Error('Not implemented.');
	  }

	  [symbols.applyDefault](value, isUndefined) {
	    return value;
	  }
	  /**
	   * Validates input before it is resolved. Expected to throw an error if something is awry, return undefined
	   * otherwise.
	   * @param input
	   * @return {boolean}
	   */


	  [symbols.validateInput](input) {}
	  /**
	   * Explains to the system which type of syntax it is, eg. what other syntax parts it may compete with
	   */


	  'getType'() {
	    throw new Error('Not implemented.');
	  }
	  /**
	   * Validates a value after it is resolved. Expected to throw an error if something is awry, return undefined
	   * otherwise.
	   * @param input
	   */


	  'validateValue'(value) {}
	  /**
	   * Returns the new scope of NamedSyntaxParts to parse through after this is parsed.
	   * @param {Array} tiers
	   * @return {Array}
	   */


	  [symbols.updateTiersAfterMatch](tiers) {
	    throw new Error('Not implemented.');
	  }
	  /**
	   * Stored a descriptive string for the NamedSyntaxPart definition, or whatever it is to the end-user
	   * @param {string} description
	   * @return {NamedSyntaxPart}
	   */


	  'setDescription'(description) {
	    this.description = description;
	    return this;
	  }

	}

	class AskNicelyInputError extends Error {
	  constructor(message, solution, code) {
	    super(message);
	    this.code = code || null;
	    this.name = this.constructor.name;
	    this.solution = solution; // A workaround to make `instanceof AskNicelyInputError` work in ES5 after babel transform

	    this.constructor = AskNicelyInputError;
	    this.__proto__ = AskNicelyInputError.prototype;
	  }

	}

	class VariableSyntaxPart extends NamedSyntaxPart {
	  /**
	   * @param {string} name
	   */
	  constructor(name) {
	    super(name);
	    this.validators = [];
	  }
	  /**
	   * @param {boolean|function(Type, Type): Type} required - If this is a function, acts as a short-hand for addValidator() as well
	   * @return {VariableSyntaxPart}
	   */


	  'isRequired'(required) {
	    this.required = !!required;
	    return typeof required === 'function' ? this.addValidator(required) : this;
	  }
	  /**
	   * Add a validator function that would check the resolved value and is expected to throw if something's awry.
	   * @param {function(Type, Type): Type} validator
	   * @return {VariableSyntaxPart}
	   */


	  'addValidator'(validator) {
	    this.validators.push(validator);
	    return this;
	  }
	  /**
	   * Define a callback that can (asynchronously) resolve user input to a value. `resolver` can return any value
	   * synchronously or a Promise for that value.
	   * @param {function(Type, Type): Type} resolver
	   * @return {VariableSyntaxPart}
	   */


	  'setResolver'(resolver) {
	    this.resolver = resolver;
	    return this;
	  }
	  /**
	   * Set a value to fall back to in case VariableSyntaxPart was not defined (and not required)
	   * @param {*} value
	   * @return {VariableSyntaxPart}
	   */


	  'setDefault'(value) {
	    this.default = value;
	    return this;
	  }

	  [symbols.applyDefault](value, isUndefined) {
	    return isUndefined ? this.cloneDefault() : value;
	  } // @TODO: Find a better way to clone objects, since Object.assign does not seem to do the job
	  // If clone is not done properly, actual usage of a default property could overwrite it for later usages


	  'cloneDefault'() {
	    return this.default && typeof this.default === 'object' && !Array.isArray(this.default) ? JSON.parse(JSON.stringify(this.default)) : this.default;
	  }

	  [symbols.validateInput](input) {
	    if (this.required && input === undefined) throw new AskNicelyInputError(`The ${this.getType()} "${this.name}" can not be undefined.`, null, 'EINVAL');
	  }

	  'validateValue'(value) {
	    this.validators.forEach(validator => validator(value));
	  }

	}

	class Option extends VariableSyntaxPart {
	  constructor(name) {
	    super(name);
	  }

	  [symbols.isMatchForPart](value) {
	    // return true if value is a (grouped) short, or long notation
	    return value.indexOf('-') !== 0 ? false : this.short && value.charAt(1) === this.short || value === `--${this.name}`;
	  }

	  [symbols.updateTiersAfterMatch](tiers) {
	    // do not change tiers because options are always recognizable, and may occur in input again
	    return tiers;
	  }

	  [symbols.spliceInputFromParts](parts) {
	    // if this is a short notation (for one or more flags)
	    if (this.short && parts[0].charAt(1) === this.short) {
	      // remove the flag signifier from group
	      parts[0] = '-' + parts[0].substr(2); // replace(this.short, '');
	      // if the group is not empty, stop parsing this option

	      if (parts[0] !== '-') return;
	    } // Stop caring about the flag signifier


	    parts.shift(); // if value is a dash, stop parsing

	    if (parts[0] === '-') {
	      parts.shift();
	      return;
	    } // use next input part if it is not another option


	    if (parts[0] && parts[0].charAt(0) !== '-') return parts.shift();
	  }

	  [symbols.applyDefault](value, isUndefined) {
	    if (this.required && isUndefined) return undefined;

	    if (value === undefined) {
	      if (this.useDefaultIfFlagMissing || !isUndefined) {
	        return this.cloneDefault() || true;
	      }
	    }

	    return value;
	  }

	  [symbols.createContributionToRequestObject](accumulated, value, isUndefined) {
	    return {
	      options: {
	        [this.name]: value
	      }
	    };
	  }

	  'getType'() {
	    return 'option';
	  }
	  /**
	   *
	   * @param value
	   * @param {boolean} [useDefaultIfFlagMissing] - Ignored when option is also required -- will fail validation
	   * @return {Option}
	   */


	  'setDefault'(value, useDefaultIfFlagMissing) {
	    this.default = value;
	    this.useDefaultIfFlagMissing = !!useDefaultIfFlagMissing;
	    return this;
	  }
	  /**
	   * Set a one-letter alias for a flag.
	   * @param {string} short
	   * @return {Option}
	   */


	  'setShort'(short) {
	    this.short = short;
	    return this;
	  }

	}

	class Parameter extends VariableSyntaxPart {
	  constructor(name) {
	    super(name);
	  }

	  [symbols.isMatchForPart](value) {
	    return value === '-' || value.substr(0, 1) !== '-';
	  }

	  [symbols.updateTiersAfterMatch](tiers) {
	    tiers.ordered.shift();
	    return tiers;
	  }

	  [symbols.spliceInputFromParts](parts) {
	    const value = parts.shift();
	    return value === '-' ? undefined : value;
	  }

	  [symbols.createContributionToRequestObject](accumulated, value) {
	    return {
	      parameters: {
	        [this.name]: value === undefined ? this.cloneDefault() : value
	      }
	    };
	  }

	  'getType'() {
	    return 'parameter';
	  }

	}

	/**
	 * @param {Command} root
	 * @param {String|Array<String>} [parts]
	 * @return {Array<[]>}
	 */

	function matchInputToSyntaxPaths(root, parts) {
	  if (!parts) parts = [];
	  if (typeof parts === 'string') parts = parts.match(/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g).map(str => str.replace(/['"]+/g, '')); // Tiers are two collections of syntax parts; ordered ones need to be written in order by the user, unordered syntax
	  // parts may occur at any point in a command line input

	  let tiers = {
	    // Commands, parameters
	    ordered: [root],
	    // Options
	    unordered: []
	  }; //

	  root[symbols.updateTiersAfterMatch](tiers, root); // Match and validate syntax parts based on input

	  let resolvedInputSpecs = [{
	    // The root command represents having invoked ask-nicely in the first place,
	    // or in other words, it's what happens if you were to run your script without any input
	    syntax: root,
	    input: root,
	    isUndefined: false
	  }];

	  while (parts.length) {
	    const expectedScopes = [...tiers.unordered].concat(tiers.ordered),
	          matchingScope = expectedScopes.find(scope => scope[symbols.isMatchForPart](parts[0]));

	    if (!matchingScope) {
	      throw new AskNicelyInputError(`The input "${parts[0]}" was not expected`, null, 'EINVAL');
	    } // Allow the SyntaxPart to modify the string that is being evaluated
	    //   eg. allow an Option to change "-abc" to "-bc" for following SyntaxParts
	    // @DEBT returns a modified matchingScope _and_ changes by reference `parts`


	    const matchingValue = matchingScope[symbols.spliceInputFromParts](parts); // Update the collection of parsed values (each coupled to their matchign SyntaxPart)

	    resolvedInputSpecs = matchingScope[symbols.updateInputSpecsAfterMatch](resolvedInputSpecs, matchingValue); // Update the tiers (ordered/unordered) for whatever is left to parse

	    tiers = matchingScope[symbols.updateTiersAfterMatch](tiers, matchingValue);
	  } // Find everything that is still open to match, and map it to the same format as resolvedScopeValues
	  // This information is needed so that parts (like an --option) can set itself to a default conditionally of being
	  // used, or not


	  const unresolvedInputSpecs = [...tiers.ordered, ...tiers.unordered].reduce((leftovers, tierOptions) => leftovers.concat(tierOptions), []).filter(syntaxPart => !resolvedInputSpecs.find(match => match.syntax === syntaxPart)).map(unmatch => ({
	    syntax: unmatch,
	    input: undefined,
	    isUndefined: true
	  }));
	  return [resolvedInputSpecs, unresolvedInputSpecs];
	}
	/**
	 *
	 * @param {Request} request
	 * @param {Array<[]>} inputSpecs
	 * @param {Array<*>} rest
	 * @return {Promise}
	 */


	function interpreter(root, parts, request, ...rest) {
	  const [resolvedInputSpecs, unresolvedInputSpecs] = matchInputToSyntaxPaths(root, parts);
	  return [...resolvedInputSpecs.map(valueSpec => {
	    // Maybe set the default
	    valueSpec.input = valueSpec.syntax[symbols.applyDefault](valueSpec.input, valueSpec.isUndefined);
	    valueSpec.syntax[symbols.validateInput](valueSpec.input);
	    return valueSpec;
	  }), ...unresolvedInputSpecs.map(valueSpec => {
	    // Maybe set the default
	    valueSpec.input = valueSpec.syntax[symbols.applyDefault](valueSpec.input, valueSpec.isUndefined);
	    valueSpec.syntax[symbols.validateInput](valueSpec.input);
	    return valueSpec;
	  }).reverse()] // Resolve the valueSpecs in sequence with each given the output of their predecessor
	  .reduce(async (asyncLast, valueSpec) => {
	    // Run the Command#addResolver configuration
	    if (valueSpec.syntax.resolver) {
	      valueSpec.input = await valueSpec.syntax.resolver(valueSpec.input, ...rest);
	    } // Run the Command#addValidator configuration


	    await valueSpec.syntax.validateValue(valueSpec.input);
	    const mergedRequestObject = await asyncLast; // This is the object a syntax part generated, to be spliced into the Request object
	    // eg. { options: { foo: 'bar' }}

	    const contribution = (await valueSpec.syntax[symbols.createContributionToRequestObject](mergedRequestObject, valueSpec.input, valueSpec.isUndefined)) || {}; // Merge the contribution into the original Request object
	    // eg. { command: Command, options: { foo: 'bar', 'boo': 'baz' }}

	    return Object.keys(contribution).reduce((merged, key) => {
	      if (key === 'command') merged[key] = contribution[key];else merged[key] = Object.assign(merged[key] || {}, contribution[key]);
	      return merged;
	    }, mergedRequestObject);
	  }, request || {});
	}

	class Request {
	  constructor() {
	    this.command = null;
	    this.options = {};
	    this.parameters = {};
	  }
	  /**
	   * Execute command controller, or reject if errors were found
	   * @param {*} ... Zero or many arguments to pass on to controller
	   * @return {Promise}
	   */


	  execute(...args) {
	    return this.command.run.apply(this.command, [this].concat(args));
	  }

	}

	const CHILD_CLASS = Symbol('child command class definition');
	class Command extends NamedSyntaxPart {
	  constructor(name, controller) {
	    super(name);
	    this.parent = null;
	    this.controller = null;
	    this.children = [];
	    this.aliases = [];
	    this.options = [];
	    this.parameters = [];
	    this.preControllers = [];
	    this.setNewChildClass(Command);
	    this.setController(controller);
	  }

	  [symbols.isMatchForPart](value) {
	    return !!this.getCommandByName(value);
	  }

	  [symbols.updateTiersAfterMatch](tiers, syntaxPartThatWasMatched) {
	    tiers.ordered.splice(tiers.ordered.indexOf(this), 1);

	    if (syntaxPartThatWasMatched.getType() === 'command') {
	      // Remove all previously defined options of the same name
	      tiers.unordered.filter(x => syntaxPartThatWasMatched.options.some(y => x.name === y.name)).forEach(option => tiers.unordered.splice(tiers.unordered.indexOf(option), 1));
	      tiers.ordered.splice(0, 0, ...syntaxPartThatWasMatched.parameters.concat(syntaxPartThatWasMatched));
	      tiers.unordered.splice(0, 0, ...syntaxPartThatWasMatched.options);
	    }

	    return tiers;
	  }

	  [symbols.spliceInputFromParts](parts) {
	    return this.getCommandByName(parts.shift());
	  }

	  [symbols.createContributionToRequestObject](accumulated, value) {
	    return value ? {
	      command: value
	    } : null;
	  }
	  /**
	   * Parse input onto a request object, and execute accordingly
	   * @param {String|Array<String>} [parts]
	   * @param {Object} [request] An existing Request, if you do not want to make a new one if you want to re-use it
	   * @return {Promise}
	   */


	  async 'execute'(parts, initialRequest, ...args) {
	    const request = await interpreter(this, parts, initialRequest || new Request(), true, args);
	    return request.command.getControllerStack().apply(request.command, [request, ...args]);
	  }

	  'getType'() {
	    return 'command';
	  }
	  /**
	   *
	   * @param parts
	   * @param request
	   * @param args
	   */
	  // parse (parts, request, ...args) {
	  // 	return interpreter(this, parts, request || new Request(), false, args);
	  // }

	  /**
	   * Execute all ancestroy precontrollers
	   * @param args
	   * @return {*}
	   */


	  'executePreControllers'(...args) {
	    return this.preControllers.reduce((res, preController) => res.then(previousVal => previousVal === false ? previousVal : preController(...args)), this.parent ? this.parent.executePreControllers(...args) : Promise.resolve(true));
	  }
	  /**
	   * Returns a function that executes all ancestry precontrollers and this command's controller
	   * @return {function(Type, Type): Type}
	   */


	  'getControllerStack'() {
	    return (...args) => this.executePreControllers(...args).then(previousValue => previousValue === false || typeof this.controller !== 'function' ? previousValue : this.controller(...args));
	  }
	  /**
	   * Look up a child command by it's name
	   * @param {string} name
	   * @return {Command|undefined}
	   */


	  'getCommandByName'(name) {
	    return this.children.find(child => child.name === name || child.aliases.indexOf(name) >= 0);
	  }
	  /**
	   * Set the main controller
	   * @param {function(Type, Type): Type} cb
	   * @return {Command}
	   */


	  'setController'(cb) {
	    this.controller = cb;
	    return this;
	  }
	  /**
	   * Defines what class new child instances should have if they're being instantiated by this object
	   * @param ClassObject
	   * @return {Command}
	   */


	  'setNewChildClass'(ClassObject) {
	    this[CHILD_CLASS] = ClassObject;
	    return this;
	  }
	  /**
	   * Add a precontroller function that is ran before its own controller, or any of it's descendants precontrollers
	   * @param {function(Type, Type): Type} cb
	   * @return {Command}
	   */


	  'addPreController'(cb) {
	    this.preControllers.push(cb);
	    return this;
	  }
	  /**
	   * Give command an alternative name
	   * @param {string} name
	   * @return {Command}
	   */


	  'addAlias'(name) {
	    this.aliases.push(name);
	    return this;
	  }
	  /**
	   * Describe an option
	   * @param {Option|string} long - The identifying name of this option, unique for its ancestry
	   * @param {string} [short] - A one-character alias of this option, unique for its ancestry
	   * @param {string} [description]
	   * @param {boolean} [required] - If true, an omittance would throw an error
	   * @return {Command}
	   */


	  'addOption'(long, short, description, required) {
	    this.options.push(typeof long.getType === 'function' && long.getType() === 'option' ? long : new Option(long).setShort(short).setDescription(description).isRequired(required));
	    return this;
	  }
	  /**
	   * Describes a parameter. Notice tat if a command has child commands, *required is implied for all ancestor parameters
	   * (and child cmd names will be mistaken for parameters if some is missing)
	   * @param {Parameter|string} name
	   * @param {string} [description]
	   * @param {boolean} [required]
	   * @return {Command}
	   */


	  'addParameter'(name, description, required) {
	    this.parameters.push(typeof name.getType === 'function' && name.getType() === 'parameter' ? name : new Parameter(name).setDescription(description).isRequired(required));
	    return this;
	  }
	  /**
	   * Register a command as a child of this, and register this as parent of the child
	   * @TODO: Check if child is not in lineage of command, to avoid circularness
	   * @param {string|Command} name
	   * @param {function(Type, Type): Type} [controller]
	   * @return {Command} The child command
	   */


	  'addCommand'(name, controller) {
	    const child = typeof name.getType === 'function' && name.getType() === 'command' ? name : new this[CHILD_CLASS](name, controller);
	    child.parent = this;
	    this.children.push(child);
	    return child;
	  }

	}

	function getValueFromPath(nameParts, obj) {
	  return nameParts.reduce((o, part) => o && o[part] ? o[part] : undefined, obj);
	} // TECHNICAL DEBT


	function assignValueToPath(nameParts, resultObj, value) {
	  const name = nameParts.shift();
	  resultObj[name] = nameParts.length ? assignValueToPath(nameParts, resultObj[name] || {}, value) : value;
	  return resultObj;
	}

	class DeepSyntaxPart {
	  static [symbols.spliceInputFromParts](parts) {
	    let deepName = parts.shift();
	    deepName = deepName.substr(deepName.indexOf('.') + 1); // if value is a dash, set actual value to TRUE

	    if (parts[0] === '-') {
	      parts.shift();
	      return [deepName, getValueFromPath(deepName.split('.'), this.cloneDefault()) || true];
	    }

	    return parts[0] && parts[0].indexOf('-') !== 0 ? [deepName, parts.shift()] : [deepName, getValueFromPath(deepName.split('.'), this.cloneDefault()) || true];
	  }

	  static [symbols.createContributionToRequestObject](propertyName, accumulated, value) {
	    var _accumulated$property, _value$;

	    const contribution = {
	      [propertyName]: {
	        [this.name]: (accumulated === null || accumulated === void 0 ? void 0 : (_accumulated$property = accumulated[propertyName]) === null || _accumulated$property === void 0 ? void 0 : _accumulated$property[this.name]) || this.cloneDefault() || {}
	      }
	    }; // console.log(contribution[propertyName][this.name]);

	    if (value === undefined) {
	      return contribution;
	    }

	    if (!((_value$ = value[0]) === null || _value$ === void 0 ? void 0 : _value$.split)) {
	      console.log(value, accumulated);
	    }

	    if (typeof value[0] === 'string') assignValueToPath(value[0].split('.'), contribution[propertyName][this.name], value[1]); // Object.assign(contribution[propertyName][this.name], contributedProp);
	    // console.log('Contributed DeepSyntaxPath response ' + propertyName + '/' + this.name, contribution);

	    return contribution;
	  }

	}

	class DeepOption extends Option {
	  constructor(name) {
	    super(name);
	  }

	  [symbols.isMatchForPart](value) {
	    return value.indexOf(`--${this.name}.`) === 0;
	  }

	  [symbols.spliceInputFromParts](parts) {
	    return DeepSyntaxPart[symbols.spliceInputFromParts].call(this, parts);
	  }

	  [symbols.createContributionToRequestObject](...args) {
	    // Inherit the behaviour of DeepSyntaxPart with a predetermined propertyName
	    return DeepSyntaxPart[symbols.createContributionToRequestObject].call(this, 'options', ...args);
	  }

	}

	class DeepParameter extends Parameter {
	  constructor(name) {
	    super(name);
	  }

	  [symbols.isMatchForPart](value) {
	    return value.indexOf(`${this.name}.`) === 0;
	  }

	  [symbols.updateTiersAfterMatch](tiers) {
	    return tiers;
	  }

	  [symbols.spliceInputFromParts](parts) {
	    return DeepSyntaxPart[symbols.spliceInputFromParts].call(this, parts);
	  }

	  [symbols.createContributionToRequestObject](...args) {
	    // Inherit the behaviour of DeepSyntaxPart with a predetermined propertyName
	    return DeepSyntaxPart[symbols.createContributionToRequestObject].call(this, 'parameters', ...args);
	  }

	}

	class IsolatedOption extends Option {
	  constructor(name) {
	    super(name);
	  } // By resetting all tiers there are no "unresolved" syntax parts


	  [symbols.updateTiersAfterMatch](tiers) {
	    tiers = {
	      ordered: [],
	      unordered: []
	    };
	    return tiers;
	  } // By emptying out parts there should be no further attempts to match


	  [symbols.spliceInputFromParts](parts) {
	    const input = Option.prototype[symbols.spliceInputFromParts].apply(this, arguments);
	    parts.splice(0, parts.length);
	    return input;
	  } // By resetting the results to just the command and this instance the Request object stays clean


	  [symbols.updateInputSpecsAfterMatch](resolvedInputSpecs, inputValue) {
	    resolvedInputSpecs = [resolvedInputSpecs.reverse().find(inputSpec => inputSpec.syntax.getType() === 'command'), {
	      syntax: this,
	      input: inputValue
	    }];
	    return resolvedInputSpecs;
	  }

	}

	const breakPartsOnPart = Symbol();
	const breakPartsDefaultPattern = /^[-.*]/;
	class MultiOption extends Option {
	  constructor(name) {
	    super(name);
	    this.isInfinite();
	  } // @todo: infinite arg as a callback
	  // @amazement 4 years later: what the actual did i mean?


	  'isInfinite'(infinite) {
	    this[breakPartsOnPart] = infinite ? part => false : part => part.charAt(0) === '-';
	    return this;
	  }

	  [breakPartsOnPart](part) {
	    return part.match(breakPartsDefaultPattern);
	  }

	  [symbols.spliceInputFromParts](parts) {
	    if (this.short && parts[0].charAt(1) === this.short) {
	      parts[0] = '-' + parts[0].substr(2);
	      if (parts[0] !== '-') return [];
	    }

	    parts.shift();
	    const input = [];

	    do {
	      if (parts[0] === '-') {
	        parts.shift();
	        break;
	      }

	      if (!parts[0] || this[breakPartsOnPart](parts[0])) break;
	      input.push(parts.shift());
	    } while (parts.length > 0);

	    return input;
	  }

	  [symbols.applyDefault](value, isUndefined) {
	    if (value === undefined || !value.length) {
	      if (this.useDefaultIfFlagMissing || !isUndefined) {
	        value = this.cloneDefault() || [];
	      }
	    }

	    if (this.required && (isUndefined || !value || !value.length)) return undefined;
	    return value || [];
	  }

	  [symbols.createContributionToRequestObject](accumulated, value, isUndefined) {
	    var _accumulated$options;

	    return {
	      options: {
	        [this.name]: ((accumulated === null || accumulated === void 0 ? void 0 : (_accumulated$options = accumulated.options) === null || _accumulated$options === void 0 ? void 0 : _accumulated$options[this.name]) || []).concat(value)
	      }
	    };
	  }

	}

	exports.Command = Command;
	exports.DeepOption = DeepOption;
	exports.DeepParameter = DeepParameter;
	exports.InputError = AskNicelyInputError;
	exports.IsolatedOption = IsolatedOption;
	exports.MultiOption = MultiOption;
	exports.Option = Option;
	exports.Parameter = Parameter;
	exports.Request = Request;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
