{"version":3,"file":"node-schematron.cjs.production.min.js","sources":["../src/Namespace.ts","../src/Result.ts","../src/Assert.ts","../src/Variable.ts","../src/Rule.ts","../src/Pattern.ts","../src/Phase.ts","../src/Schema.ts"],"sourcesContent":["export class Namespace {\n\tprefix: string;\n\turi: string;\n\n\tconstructor(prefix: string, uri: string) {\n\t\tthis.prefix = prefix;\n\t\tthis.uri = uri;\n\t}\n\n\tstatic QUERY = `map {\n\t\t\"prefix\": @prefix/string(),\n\t\t\"uri\": @uri/string()\n\t}`;\n\n\tstatic fromJson(json: NamespaceJson): Namespace {\n\t\treturn new Namespace(json.prefix, json.uri);\n\t}\n}\n\nexport type NamespaceJson = {\n\tprefix: string;\n\turi: string;\n};\n","import { Assert } from './Assert';\n\nexport class Result {\n\t// pattern: Pattern;\n\t// phase?: Phase;\n\t// rule: Rule;\n\tassertId: string | null;\n\tisReport: boolean;\n\tcontext: Node;\n\tmessage?: string;\n\n\tconstructor(\n\t\t// pattern: Pattern,\n\t\t// phase?: Phase,\n\t\t// rule: Rule,\n\t\tcontext: Node,\n\t\tassert: Assert,\n\t\tmessage?: string\n\t) {\n\t\t// this.pattern = pattern;\n\t\t// this.phase = phase;\n\t\t// this.rule = rule;\n\t\tthis.assertId = assert.id;\n\t\tthis.isReport = assert.isReport;\n\t\tthis.context = context;\n\t\tthis.message = message;\n\t}\n\n\ttoJson() {\n\t\treturn {\n\t\t\tassertId: this.assertId,\n\t\t\tisReport: this.isReport,\n\t\t\tcontext: (this.context as HTMLElement).outerHTML,\n\t\t\tmessage: this.message\n\t\t};\n\t}\n}\n","import { evaluateXPathToBoolean, evaluateXPathToString } from 'fontoxpath';\n\nimport { Result } from './Result';\n\nimport { FontoxpathOptions } from './types';\n\nexport class Assert {\n\tid: string | null;\n\ttest: string;\n\tmessage: Array<string | Object>;\n\tisReport: boolean;\n\n\tconstructor(\n\t\tid: string | null,\n\t\ttest: string,\n\t\tmessage: Array<string | Object>,\n\t\tisReport: boolean\n\t) {\n\t\tthis.id = id;\n\t\tthis.test = test;\n\t\tthis.message = message;\n\t\tthis.isReport = isReport;\n\t}\n\n\tcreateMessageString(\n\t\tcontextNode: Node,\n\t\tvariables: Object,\n\t\tfontoxpathOptions: FontoxpathOptions,\n\t\tchunks: Array<string | any>\n\t): string {\n\t\treturn chunks\n\t\t\t.map((chunk): string => {\n\t\t\t\tif (typeof chunk === 'string') {\n\t\t\t\t\treturn chunk;\n\t\t\t\t}\n\n\t\t\t\t// <sch:name />\n\t\t\t\tif (chunk.$type === 'name') {\n\t\t\t\t\treturn evaluateXPathToString(\n\t\t\t\t\t\t'name(' + (chunk.path || '') + ')',\n\t\t\t\t\t\tcontextNode,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tvariables,\n\t\t\t\t\t\tfontoxpathOptions\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// <sch:value-of />\n\t\t\t\tif (chunk.$type === 'value-of') {\n\t\t\t\t\treturn evaluateXPathToString(\n\t\t\t\t\t\tchunk.select,\n\t\t\t\t\t\tcontextNode,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tvariables,\n\t\t\t\t\t\tfontoxpathOptions\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconsole.log(chunk);\n\t\t\t\tthrow new Error('Unsupported element in <sch:message>');\n\t\t\t})\n\t\t\t.join('');\n\t}\n\n\tvalidateNode(\n\t\tcontext: Node,\n\t\tvariables: Object,\n\t\tfontoxpathOptions: FontoxpathOptions\n\t): Result | null {\n\t\tconst outcome = evaluateXPathToBoolean(\n\t\t\tthis.test,\n\t\t\tcontext,\n\t\t\tnull,\n\t\t\tvariables,\n\t\t\tfontoxpathOptions\n\t\t);\n\t\treturn (!this.isReport && outcome) || (this.isReport && !outcome)\n\t\t\t? null\n\t\t\t: new Result(\n\t\t\t\t\tcontext,\n\t\t\t\t\tthis,\n\t\t\t\t\tthis.createMessageString(context, variables, fontoxpathOptions, this.message)\n\t\t\t  );\n\t}\n\n\tstatic QUERY = `map {\n\t\t'id': if (@id) then string(@id) else (),\n\t\t'test': @test/string(),\n\t\t'message': array { (./text()|./element())/local:json(.) },\n\t\t'isReport': boolean(local-name() = 'report')\n\t}`;\n\n\tstatic fromJson(json: AssertJson): Assert {\n\t\treturn new Assert(json.id, json.test, json.message, json.isReport);\n\t}\n}\n\nexport type AssertJson = {\n\tid: string | null;\n\ttest: string;\n\tmessage: Array<string | Object>;\n\tisReport: boolean;\n};\n","import { evaluateXPath } from 'fontoxpath';\n\nimport { FontoxpathOptions } from './types';\n\nexport class Variable {\n\tname: string;\n\tvalue: string;\n\n\tconstructor(name: string, value: string) {\n\t\tthis.name = name;\n\t\tthis.value = value;\n\t}\n\n\tstatic reduceVariables(\n\t\tcontext: any,\n\t\tvariables: Variable[],\n\t\tfontoxpathOptions: FontoxpathOptions,\n\t\tinitial: Object | null\n\t): Object {\n\t\treturn variables.reduce(\n\t\t\t(mapping, variable) =>\n\t\t\t\tObject.assign(mapping, {\n\t\t\t\t\t[variable.name]: variable.value\n\t\t\t\t\t\t? evaluateXPath(\n\t\t\t\t\t\t\t\tvariable.value,\n\t\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\tmapping,\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\tfontoxpathOptions\n\t\t\t\t\t\t  )\n\t\t\t\t\t\t: context\n\t\t\t\t}),\n\t\t\tinitial || {}\n\t\t);\n\t}\n\n\tstatic QUERY = `map {\n\t\t'name': @name/string(),\n\t\t'value': @value/string()\n\t}`;\n\n\tstatic fromJson(json: VariableJson): Variable {\n\t\treturn new Variable(json.name, json.value);\n\t}\n}\n\nexport type VariableJson = { name: string; value: string };\n","import { Assert, AssertJson } from './Assert';\nimport { Result } from './Result';\nimport { Variable, VariableJson } from './Variable';\n\nimport { FontoxpathOptions } from './types';\n\nexport class Rule {\n\tcontext: string;\n\tvariables: Variable[];\n\tasserts: Assert[];\n\n\tconstructor(context: string, variables: Variable[], asserts: Assert[]) {\n\t\tthis.context = context;\n\t\tthis.variables = variables;\n\t\tthis.asserts = asserts;\n\t}\n\n\tvalidateNode(\n\t\tcontext: Node,\n\t\tparentVariables: {} | null,\n\t\tfontoxpathOptions: FontoxpathOptions\n\t): Result[] {\n\t\tconst variables = Variable.reduceVariables(context, this.variables, fontoxpathOptions, {\n\t\t\t...parentVariables\n\t\t});\n\n\t\treturn this.asserts\n\t\t\t.map(assert => assert.validateNode(context, variables, fontoxpathOptions))\n\t\t\t.filter(result => result !== null) as Result[];\n\t}\n\n\tstatic QUERY = `map {\n\t\t'context': @context/string(),\n\t\t'variables': array { ./sch:let/${Variable.QUERY}},\n\t\t'asserts': array{ ./(sch:report|sch:assert)/${Assert.QUERY}}\n\t}`;\n\n\tstatic fromJson(json: RuleJson): Rule {\n\t\tconst variables = json.variables.map(rule => Variable.fromJson(rule));\n\t\tconst asserts = json.asserts.map(rule => Assert.fromJson(rule));\n\n\t\treturn new Rule(json.context, variables, asserts);\n\t}\n}\n\nexport type RuleJson = {\n\tcontext: string;\n\tvariables: VariableJson[];\n\tasserts: AssertJson[];\n};\n","import { evaluateXPathToNodes } from 'fontoxpath';\n\nimport { Result } from './Result';\nimport { Rule, RuleJson } from './Rule';\nimport { Variable, VariableJson } from './Variable';\n\nimport { FontoxpathOptions } from './types';\n\nexport class Pattern {\n\tid: string | null;\n\trules: Rule[];\n\tvariables: Variable[];\n\n\tconstructor(id: string | null, rules: Rule[], variables: Variable[]) {\n\t\tthis.id = id;\n\t\tthis.rules = rules;\n\t\tthis.variables = variables;\n\t}\n\n\tvalidateDocument(\n\t\tdocumentDom: Document,\n\t\tparentVariables: object | null,\n\t\tfontoxpathOptions: FontoxpathOptions\n\t) {\n\t\tconst variables = Variable.reduceVariables(documentDom, this.variables, fontoxpathOptions, {\n\t\t\t...parentVariables\n\t\t});\n\t\tconst ruleContexts = this.rules.map(rule =>\n\t\t\tevaluateXPathToNodes(\n\t\t\t\t'//(' + rule.context + ')',\n\t\t\t\tdocumentDom,\n\t\t\t\tnull,\n\t\t\t\tvariables,\n\t\t\t\tfontoxpathOptions\n\t\t\t)\n\t\t);\n\t\tconst flattenValidationResults = (results: Result[], node: Node): Result[] => {\n\t\t\tconst ruleIndex = ruleContexts.findIndex(context => context.includes(node));\n\t\t\tconst rule = ruleIndex >= 0 ? this.rules[ruleIndex] : null;\n\t\t\tif (rule) {\n\t\t\t\tresults.splice(\n\t\t\t\t\tresults.length,\n\t\t\t\t\t0,\n\t\t\t\t\t...rule.validateNode(node, variables, fontoxpathOptions)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn Array.from(node.childNodes).reduce(flattenValidationResults, results);\n\t\t};\n\n\t\treturn Array.from(documentDom.childNodes).reduce(flattenValidationResults, []);\n\t}\n\n\tstatic QUERY = `map {\n\t\t'id': @id/string(),\n\t\t'rules': array{ ./sch:rule/${Rule.QUERY}},\n\t\t'variables': array { ./sch:let/${Variable.QUERY}}\n\t}`;\n\n\tstatic fromJson(json: PatternJson): Pattern {\n\t\treturn new Pattern(\n\t\t\tjson.id,\n\t\t\tjson.rules.map(obj => Rule.fromJson(obj)),\n\t\t\tjson.variables.map(obj => Variable.fromJson(obj))\n\t\t);\n\t}\n}\n\nexport type PatternJson = {\n\tid: string | null;\n\trules: RuleJson[];\n\tvariables: VariableJson[];\n};\n","import { Variable, VariableJson } from './Variable';\n\nexport class Phase {\n\tid: string;\n\tactive: string[];\n\tvariables: Variable[];\n\n\tconstructor(id: string, active: string[], variables: Variable[]) {\n\t\tthis.id = id;\n\t\tthis.active = active;\n\t\tthis.variables = variables;\n\t}\n\n\tstatic QUERY = `map {\n\t\t\"id\": @id/string(),\n\t\t\"active\": array { ./sch:active/@pattern/string() },\n\t\t'variables': array { ./sch:let/${Variable.QUERY}}\n\t}`;\n\n\tstatic fromJson(json: PhaseJson): Phase {\n\t\treturn new Phase(\n\t\t\tjson.id,\n\t\t\tjson.active,\n\t\t\tjson.variables.map(rule => Variable.fromJson(rule))\n\t\t);\n\t}\n}\n\nexport type PhaseJson = {\n\tid: string;\n\tactive: string[];\n\tvariables: VariableJson[];\n};\n","import { evaluateXPath } from 'fontoxpath';\nimport { sync } from 'slimdom-sax-parser';\n\nimport { Namespace, NamespaceJson } from './Namespace';\nimport { Pattern, PatternJson } from './Pattern';\nimport { Phase, PhaseJson } from './Phase';\nimport { Result } from './Result';\nimport { Variable, VariableJson } from './Variable';\n\nimport { FontoxpathOptions } from './types';\n\nexport class Schema {\n\tpublic title: string;\n\tpublic defaultPhase: string | null;\n\tpublic variables: Variable[];\n\tpublic phases: Phase[];\n\tpublic patterns: Pattern[];\n\tpublic namespaces: Namespace[];\n\n\tconstructor(\n\t\ttitle: string,\n\t\tdefaultPhase: string | null,\n\t\tvariables: Variable[],\n\t\tphases: Phase[],\n\t\tpatterns: Pattern[],\n\t\tnamespaces: Namespace[]\n\t) {\n\t\tthis.title = title;\n\t\tthis.defaultPhase = defaultPhase;\n\t\tthis.variables = variables;\n\t\tthis.phases = phases;\n\t\tthis.patterns = patterns;\n\t\tthis.namespaces = namespaces;\n\t}\n\n\tvalidateString(documentXmlString: string, options?: ValidatorOptions): Result[] {\n\t\t// Typescript casting slimdom.Document to Document, which are the same\n\t\treturn this.validateDocument((sync(documentXmlString) as unknown) as Document, options);\n\t}\n\n\tvalidateDocument(documentDom: Document, options?: ValidatorOptions): Result[] {\n\t\tlet { phaseId, debug } = options || {};\n\t\tif (!phaseId) {\n\t\t\tphaseId = '#DEFAULT';\n\t\t}\n\t\tif (phaseId === '#DEFAULT') {\n\t\t\tphaseId = this.defaultPhase || '#ALL';\n\t\t}\n\t\tconst fontoxpathOptions: FontoxpathOptions = {\n\t\t\tnamespaceResolver: this.getNamespaceUriForPrefix.bind(this),\n\t\t\tdebug\n\t\t};\n\t\tconst variables = Variable.reduceVariables(\n\t\t\tdocumentDom,\n\t\t\tthis.variables,\n\t\t\tfontoxpathOptions,\n\t\t\t{}\n\t\t);\n\n\t\tif (phaseId === '#ALL') {\n\t\t\treturn this.patterns.reduce(\n\t\t\t\t(results: Result[], pattern) =>\n\t\t\t\t\tresults.concat(\n\t\t\t\t\t\tpattern.validateDocument(documentDom, variables, fontoxpathOptions)\n\t\t\t\t\t),\n\t\t\t\t[]\n\t\t\t);\n\t\t}\n\n\t\tconst phase = this.phases.find(phase => phase.id === phaseId);\n\t\tconst phaseVariables = Variable.reduceVariables(\n\t\t\tdocumentDom,\n\t\t\tphase?.variables || [],\n\t\t\tfontoxpathOptions,\n\t\t\t{\n\t\t\t\t...variables\n\t\t\t}\n\t\t);\n\n\t\treturn (\n\t\t\tphase?.active\n\t\t\t\t.map(patternId => this.patterns.find(pattern => pattern.id === patternId))\n\t\t\t\t.reduce(\n\t\t\t\t\t(results: Result[], pattern) =>\n\t\t\t\t\t\tresults.concat(\n\t\t\t\t\t\t\tpattern?.validateDocument(\n\t\t\t\t\t\t\t\tdocumentDom,\n\t\t\t\t\t\t\t\tphaseVariables,\n\t\t\t\t\t\t\t\tfontoxpathOptions\n\t\t\t\t\t\t\t) || []\n\t\t\t\t\t\t),\n\t\t\t\t\t[]\n\t\t\t\t) || []\n\t\t);\n\t}\n\n\t// TODO more optimally store the namespace prefix/uri mapping. Right now its modeled as an array because there\n\t// is a list of <ns> elements that are not really guaranteed to use unique prefixes.\n\tgetNamespaceUriForPrefix(prefix?: string | null): string | null {\n\t\tif (!prefix) {\n\t\t\treturn null;\n\t\t}\n\t\tconst ns = this.namespaces.find(ns => ns.prefix === prefix);\n\t\tif (!ns) {\n\t\t\tthrow new Error(\n\t\t\t\t`Namespace prefix \"${prefix}\" could not be resolved to an URI using <sch:ns>`\n\t\t\t);\n\t\t}\n\n\t\treturn ns.uri;\n\t}\n\n\tstatic QUERY = `\n\t\tdeclare namespace sch = 'http://purl.oclc.org/dsdl/schematron';\n\n\t\tdeclare function local:json($node as node()) {\n\t\t\tif ($node[self::text()])\n\t\t\t\tthen $node/string()\n\t\t\telse\n\t\t\tmap:merge((\n\t\t\t\tmap:entry('$type', $node/local-name()),\n\t\t\t\tfor $attr in $node/@*\n\t\t\t\t\treturn map:entry($attr/name(), $attr/string())\n\t\t\t))\n\t\t};\n\n\t\tlet $context := /*[1]\n\t\treturn map {\n\t\t\t'title': $context/@title/string(),\n\t\t\t'defaultPhase': $context/@defaultPhase/string(),\n\t\t\t'phases': array { $context/sch:phase/${Phase.QUERY}},\n\t\t\t'patterns': array { $context/sch:pattern/${Pattern.QUERY}},\n\t\t\t'variables': array { $context/sch:let/${Variable.QUERY}},\n\t\t\t'namespaces': array { $context/sch:ns/${Namespace.QUERY}}\n\t\t}\n\t`;\n\n\tstatic fromJson(json: SchemaJson): Schema {\n\t\treturn new Schema(\n\t\t\tjson.title,\n\t\t\tjson.defaultPhase,\n\t\t\tjson.variables.map(obj => Variable.fromJson(obj)),\n\t\t\tjson.phases.map(obj => Phase.fromJson(obj)),\n\t\t\tjson.patterns.map(obj => Pattern.fromJson(obj)),\n\t\t\tjson.namespaces.map(obj => Namespace.fromJson(obj))\n\t\t);\n\t}\n\n\tstatic fromDomToJson(schematronDom: Document): SchemaJson {\n\t\treturn evaluateXPath(Schema.QUERY, schematronDom, null, {}, undefined, {\n\t\t\tlanguage: evaluateXPath.XQUERY_3_1_LANGUAGE\n\t\t});\n\t}\n\n\tstatic fromDom(schematronDom: Document): Schema {\n\t\treturn Schema.fromJson(Schema.fromDomToJson(schematronDom));\n\t}\n\n\tstatic fromString(schematronXmlString: string): Schema {\n\t\treturn Schema.fromDom((sync(schematronXmlString) as unknown) as Document);\n\t}\n}\n\nexport type SchemaJson = {\n\ttitle: string;\n\tdefaultPhase: string | null;\n\tvariables: VariableJson[];\n\tphases: PhaseJson[];\n\tpatterns: PatternJson[];\n\tnamespaces: NamespaceJson[];\n};\n\nexport type ValidatorOptions = {\n\tphaseId?: string;\n\tdebug?: boolean;\n};\n"],"names":["Namespace","prefix","uri","fromJson","json","Result","context","assert","message","assertId","id","isReport","toJson","this","outerHTML","Assert","test","createMessageString","contextNode","variables","fontoxpathOptions","chunks","map","chunk","$type","evaluateXPathToString","path","select","console","log","Error","join","validateNode","outcome","evaluateXPathToBoolean","Variable","name","value","reduceVariables","initial","reduce","mapping","variable","Object","assign","evaluateXPath","undefined","Rule","asserts","parentVariables","filter","result","rule","QUERY","Pattern","rules","validateDocument","documentDom","ruleContexts","evaluateXPathToNodes","Array","from","childNodes","flattenValidationResults","results","node","ruleIndex","findIndex","includes","_this","splice","length","obj","Phase","active","Schema","title","defaultPhase","phases","patterns","namespaces","validateString","documentXmlString","options","sync","phaseId","debug","namespaceResolver","getNamespaceUriForPrefix","bind","pattern","concat","phase","find","phaseVariables","patternId","ns","fromDomToJson","schematronDom","language","XQUERY_3_1_LANGUAGE","fromDom","fromString","schematronXmlString"],"mappings":"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"}