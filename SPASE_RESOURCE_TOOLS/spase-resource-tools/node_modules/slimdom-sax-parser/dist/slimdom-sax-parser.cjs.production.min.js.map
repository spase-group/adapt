{"version":3,"file":"slimdom-sax-parser.cjs.production.min.js","sources":["../src/options.ts","../src/createNamespaceContext.ts","../src/createPositionTracker.ts","../src/createHandler.ts","../src/parseDoctypeDeclaration.ts","../src/index.ts","../src/asynchronouslyParseSlimdomDocument.ts","../src/synchronouslyParseSlimdomDocument.ts"],"sourcesContent":["import * as saxes from 'saxes';\n\nexport interface Options extends saxes.SaxesOptions {\n\tadditionalEntities?: {\n\t\t[entityName: string]: string;\n\t};\n}\n\nexport const DEFAULT_OPTIONS: Options = {\n\txmlns: true,\n\tposition: false,\n\tadditionalEntities: {}\n};\n","export const DEFAULT_NAMESPACES: Record<string, string | null> = {\n\t'': null,\n\n\t// Two namespace prefixes that are predetermined by the XML spec.\n\t//\n\t// See also:\n\t//   https://www.w3.org/TR/xml-names/#ns-decl\n\txml: 'http://www.w3.org/XML/1998/namespace',\n\txmlns: 'http://www.w3.org/2000/xmlns/'\n};\n\n/**\n * Records an array of overlapping objects that is shifted and unshifted as the parser traverses.\n */\nexport default function createNamespaceContext(additionalNsMapping: Record<string, string>) {\n\tconst namespaces: Record<string, string | null>[] = [DEFAULT_NAMESPACES];\n\tif (additionalNsMapping !== undefined) {\n\t\tnamespaces.unshift(additionalNsMapping);\n\t}\n\n\treturn {\n\t\t// pop and push are actually shift and unshift to make searches more efficient\n\t\tpush: (x: Record<string, string>) => namespaces.unshift(x),\n\n\t\tpop: () => namespaces.shift(),\n\n\t\t// Get the location associated with a prefix\n\t\tlocation: (prefix: string | undefined): string | null | undefined =>\n\t\t\tprefix === undefined\n\t\t\t\t? prefix\n\t\t\t\t: namespaces.find(ns => ns[prefix] !== undefined)?.[prefix]\n\t};\n}\n","import { SaxesParser } from 'saxes';\nimport { Attr, Node } from 'slimdom';\n\n/**\n * The helper functions to track node positions.\n */\ntype PositionTracker = {\n\ttrackNodePosition<N extends Node>(node: N): PositionTrackedNode<N>;\n\ttrackNodeClosePosition<N extends Node>(node: PositionTrackedNode<N>): PositionTrackedElement<N>;\n\tupdateLastTrackedPosition(): void;\n\tgetCurrentPosition(): Position;\n\ttrackAttributePosition<A extends Attr>(attr: A, endPosition: Position): PositionTrackedAttr<A>;\n};\n\n/**\n * One (collapsed) location in code. `offset` is equal to the length of all preceding lines + column.\n */\nexport type Position = {\n\toffset: number;\n\tline: number;\n\tcolumn: number;\n};\n\n/**\n * A location in code, possibly spanning text. `start` and `end` are both offsets from the start of\n * the XML source.\n */\nexport type PositionRange = {\n\tline: number;\n\tcolumn: number;\n\tstart: number;\n\tend: number;\n};\n\n/**\n * Various properties on nodes that contain the position information.\n */\nexport type PositionTrackedNode<N> = N & {\n\tposition: PositionRange;\n};\nexport type PositionTrackedElement<N> = PositionTrackedNode<N> & {\n\tclosePosition: PositionRange;\n};\nexport type PositionTrackedAttr<A> = A & {\n\tposition: {\n\t\tend: number;\n\t};\n};\n\n/**\n * The DOM node types enumeration. Only TEXT_NODE and COMMENT_NODE are used, so the rest is commented out.\n *\n * See also:\n *   https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\n */\nconst types = {\n\t// ELEMENT_NODE: 1,\n\t// ATTRIBUTE_NODE: 2,\n\tTEXT_NODE: 3,\n\t// CDATA_SECTION_NODE: 4,\n\t// ENTITY_REFERENCE_NODE: 5,\n\t// ENTITY_NODE: 6,\n\t// PROCESSING_INSTRUCTION_NODE: 7,\n\tCOMMENT_NODE: 8\n\t// DOCUMENT_NODE: 9,\n\t// DOCUMENT_TYPE_NODE: 10,\n\t// DOCUMENT_FRAGMENT_NODE: 11,\n\t// NOTATION_NODE: 12\n};\n\n/**\n * Create the context needed to track the positions in an XML string at which a Slimdom node was defined. Is based on\n * input from the saxes parser and fixes some unexpected behaviour by it.\n */\nexport default function createPositionTracker(parser: SaxesParser): PositionTracker {\n\tlet lastTrackedPosition = {\n\t\t// Line and column numbers are 1-based\n\t\tline: 1,\n\t\tcolumn: 1,\n\n\t\t// Offset (start + end) are 0-based\n\t\toffset: 0\n\t};\n\n\tfunction updateLastTrackedPosition(): void {\n\t\tlastTrackedPosition = getCurrentPosition();\n\t}\n\n\t// Fixes some quirky results from saxes' position tracking:\n\t// - XML comments were always one character short\n\tfunction getCurrentPosition<N extends Node>(node?: N) {\n\t\tconst position = {\n\t\t\toffset: parser.position,\n\t\t\tline: parser.line,\n\t\t\tcolumn: parser.column + 1\n\t\t};\n\n\t\tif (!node) {\n\t\t\treturn position;\n\t\t}\n\n\t\tif (node.nodeType === types.TEXT_NODE) {\n\t\t\t// For XML text nodes the position tracking is always received when the next node is instantiated, eg.\n\t\t\t// the opening tag of the next sibling element or closing tag would show up in the text substr.\n\t\t\t// Therefore fix endPosition by not counting the next element or closing tag.\n\t\t\tposition.offset--;\n\t\t\tposition.column--;\n\t\t} else if (node.nodeType === types.COMMENT_NODE) {\n\t\t\t// For XML comments the position tracking is always received one character too short.\n\t\t\t// This right here is a local fix, and rather crude.\n\t\t\tposition.offset++;\n\t\t\tposition.column++;\n\t\t}\n\n\t\treturn position;\n\t}\n\n\t// Updates the tracker with new input from the saxes parser, and writes a \"position\" property to the DOM node\n\t// that was passed.\n\tfunction trackNodePosition<N extends Node>(node: N): PositionTrackedNode<N> {\n\t\tconst endPosition = getCurrentPosition(node);\n\n\t\t(node as PositionTrackedNode<N>).position = {\n\t\t\tline: lastTrackedPosition.line,\n\t\t\tcolumn: lastTrackedPosition.column,\n\t\t\tstart: lastTrackedPosition.offset,\n\t\t\tend: endPosition.offset\n\t\t};\n\n\t\tlastTrackedPosition = endPosition;\n\n\t\treturn node as PositionTrackedNode<N>;\n\t}\n\n\tfunction trackNodeClosePosition<N extends Node>(node: PositionTrackedNode<N>) {\n\t\tconst endPosition = getCurrentPosition(node);\n\n\t\t(node as PositionTrackedElement<N>).closePosition = {\n\t\t\tline: lastTrackedPosition.line,\n\t\t\tcolumn: lastTrackedPosition.column,\n\t\t\tstart: lastTrackedPosition.offset,\n\t\t\tend: endPosition.offset\n\t\t};\n\n\t\tlastTrackedPosition = endPosition;\n\n\t\treturn node as PositionTrackedElement<N>;\n\t}\n\n\tfunction trackAttributePosition<A extends Attr>(\n\t\tattr: A,\n\t\tendPosition: Position\n\t): PositionTrackedAttr<A> {\n\t\t(attr as PositionTrackedAttr<A>).position = {\n\t\t\tend: endPosition.offset\n\t\t};\n\n\t\treturn attr as PositionTrackedAttr<A>;\n\t}\n\n\treturn {\n\t\tgetCurrentPosition,\n\t\ttrackAttributePosition,\n\t\ttrackNodeClosePosition,\n\t\ttrackNodePosition,\n\t\tupdateLastTrackedPosition\n\t};\n}\n\n/**\n * No-op alternative for position tracking, when position tracking is disabled.\n */\nexport const positionTrackerStubs: PositionTracker = {\n\tgetCurrentPosition: () => ({ offset: 0, line: 0, column: 0 }),\n\ttrackAttributePosition: (attr?: any) => attr,\n\ttrackNodeClosePosition: (node?: any) => node,\n\ttrackNodePosition: (node?: any) => node,\n\tupdateLastTrackedPosition: () => {}\n};\n","import {\n\tAttributeHandler,\n\tCDataHandler,\n\tCloseTagHandler,\n\tCommentHandler,\n\tDoctypeHandler,\n\tOpenTagHandler,\n\tOpenTagStartHandler,\n\tPIHandler,\n\tSaxesAttributeNS,\n\tSaxesOptions,\n\tSaxesParser,\n\tTextHandler\n} from 'saxes';\nimport { Document } from 'slimdom';\nimport createNamespaceContext from './createNamespaceContext';\nimport createPositionTracker, { Position, positionTrackerStubs } from './createPositionTracker';\nimport { parseDoctypeDeclaration } from './parseDoctypeDeclaration';\n\ntype Handler = {\n\tonText: TextHandler;\n\tonOpenTag: OpenTagHandler<SaxesOptions>;\n\tonOpenTagStart: OpenTagStartHandler<SaxesOptions>;\n\tonCloseTag: CloseTagHandler<SaxesOptions>;\n\tonAttribute: AttributeHandler<{ xmlns: true; position: true }>;\n\tonProcessingInstruction: PIHandler;\n\tonComment: CommentHandler;\n\tonDocType: DoctypeHandler;\n\tonCdata: CDataHandler;\n\tdocument: Document;\n};\n\n/*\n * Create the required callbacks for populating a new document from sax event handlers\n */\nexport default function createHandler(parser: SaxesParser, options: SaxesOptions): Handler {\n\t// A new XML DOM object that has the same API as the browser DOM implementation, but isomorphic and supports\n\t// namespaces.\n\tconst document = new Document();\n\n\t// The node into which new child nodes are inserted. Is rewritten as the handler traverses in and out of elements.\n\tlet contextNode: any = document;\n\n\t// Helpers for other responsibilities\n\tconst namespaces = createNamespaceContext(options.additionalNamespaces || {});\n\n\tconst {\n\t\ttrackNodePosition,\n\t\ttrackNodeClosePosition,\n\t\tupdateLastTrackedPosition,\n\t\tgetCurrentPosition,\n\t\ttrackAttributePosition\n\t} = options.position ? createPositionTracker(parser) : positionTrackerStubs;\n\n\tlet attributePositions: Map<string, Position> = new Map();\n\n\t// Return a bunch of methods that can be applied directly to a saxes parser instance.\n\treturn {\n\t\tonText: text => {\n\t\t\tif (contextNode === document) {\n\t\t\t\tupdateLastTrackedPosition();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst textNode = trackNodePosition(document.createTextNode(text));\n\t\t\tcontextNode.appendChild(textNode);\n\t\t},\n\n\t\tonOpenTag: element => {\n\t\t\t// More namespace declarations might be applicable\n\t\t\tif (element.ns) {\n\t\t\t\tnamespaces.push(element.ns);\n\t\t\t}\n\t\t\tconst nsLocation = namespaces.location(element.prefix);\n\t\t\tif (nsLocation === undefined) {\n\t\t\t\tthrow new Error(`Could not resolve a namespace location for \"${element.prefix}\"`);\n\t\t\t}\n\t\t\tconst node = trackNodePosition(document.createElementNS(nsLocation, element.name));\n\n\t\t\tObject.keys(element.attributes)\n\t\t\t\t.map(name => element.attributes[name])\n\t\t\t\t.forEach((attr: string | SaxesAttributeNS) => {\n\t\t\t\t\tif (typeof attr === 'string') {\n\t\t\t\t\t\t// @TODO Find out why saxes sometimes uses strings instead of SaxesAttributeNs\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Default namespace declarations do not apply to attributes, so if an attribute\n\t\t\t\t\t// is not prefixed the namespace location is null\n\t\t\t\t\tlet namespaceURI = attr.prefix === '' ? null : namespaces.location(attr.prefix);\n\n\t\t\t\t\t// @xmlns has no prefix but is in the XMLNS namespace\n\t\t\t\t\tif (attr.prefix === '' && attr.name === 'xmlns') {\n\t\t\t\t\t\tnamespaceURI = namespaces.location('xmlns');\n\t\t\t\t\t}\n\n\t\t\t\t\tconst position = attributePositions.get(attr.name)!;\n\t\t\t\t\tconst attributeNode = trackAttributePosition(\n\t\t\t\t\t\tdocument.createAttributeNS(namespaceURI!, attr.name),\n\t\t\t\t\t\tposition\n\t\t\t\t\t);\n\t\t\t\t\tattributeNode.value = attr.value;\n\t\t\t\t\tnode.setAttributeNode(attributeNode);\n\t\t\t\t});\n\n\t\t\tcontextNode.appendChild(node);\n\t\t\tcontextNode = node;\n\t\t},\n\n\t\tonOpenTagStart: () => {\n\t\t\tattributePositions = new Map();\n\t\t},\n\n\t\tonAttribute: attribute => {\n\t\t\tattributePositions.set(attribute.name, getCurrentPosition());\n\t\t},\n\n\t\tonCloseTag: () => {\n\t\t\t// Update position tracking so that the closing tag of an element is not prepended to the following sibling\n\t\t\ttrackNodeClosePosition(contextNode);\n\n\t\t\tif (!contextNode.parentNode) {\n\t\t\t\tthrow new Error('End of the line!');\n\t\t\t}\n\n\t\t\t// Any traversal from now on is within a higher context element\n\t\t\tcontextNode = contextNode.parentNode;\n\n\t\t\t// Less namespace declarations might now be applicable\n\t\t\tnamespaces.pop();\n\t\t},\n\n\t\tonProcessingInstruction: pi => {\n\t\t\tcontextNode.appendChild(\n\t\t\t\ttrackNodePosition(document.createProcessingInstruction(pi.target, pi.body))\n\t\t\t);\n\t\t},\n\n\t\tonComment: comment => {\n\t\t\tcontextNode.appendChild(trackNodePosition(document.createComment(comment)));\n\t\t},\n\n\t\tonDocType: data => {\n\t\t\tconst { qualifiedName, publicId, systemId } = parseDoctypeDeclaration(\n\t\t\t\t`<!DOCTYPE ${data}>`\n\t\t\t);\n\t\t\tcontextNode.appendChild(\n\t\t\t\ttrackNodePosition(\n\t\t\t\t\tdocument.implementation.createDocumentType(\n\t\t\t\t\t\tqualifiedName,\n\t\t\t\t\t\tpublicId || '',\n\t\t\t\t\t\tsystemId || ''\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t);\n\t\t},\n\n\t\tonCdata: string => {\n\t\t\tcontextNode.appendChild(trackNodePosition(document.createCDATASection(string)));\n\t\t},\n\n\t\tdocument: document\n\t};\n}\n","/*\n * Split the doctype string\n * Thanks to https://github.com/jindw/xmldom\n */\nfunction splitDoctypeDeclaration(source: string, start = 0) {\n\tlet match;\n\tconst buf = [];\n\tconst reg = /'[^']+'|\"[^\"]+\"|[^\\s<>/=]+=?|(\\/?\\s*>|<)/g;\n\treg.lastIndex = start;\n\treg.exec(source); //skip <\n\twhile ((match = reg.exec(source))) {\n\t\tbuf.push(match[0]);\n\t\tif (match[1]) return buf;\n\t}\n\treturn buf;\n}\n\nexport function parseDoctypeDeclaration(source: string) {\n\tconst [\n\t\t// @ts-ignore TS6133\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\t_opening,\n\t\tqualifiedName, // @ts-ignore TS6133\n\t\ttype,\n\t\tpublicIdOrSystemId,\n\t\tsystemId\n\t] = splitDoctypeDeclaration(source);\n\treturn type === 'PUBLIC'\n\t\t? {\n\t\t\t\tqualifiedName,\n\t\t\t\tpublicId: publicIdOrSystemId.replace(/^\"(.*)\"$/, '$1'),\n\t\t\t\tsystemId: systemId?.replace(/^\"(.*)\"$/, '$1') || null\n\t\t  }\n\t\t: {\n\t\t\t\tqualifiedName,\n\t\t\t\tpublicId: null,\n\t\t\t\tsystemId: publicIdOrSystemId.replace(/^\"(.*)\"$/, '$1')\n\t\t  };\n}\n","// Workaround for `export * as slimdom`, which doesn't work well in some TS versions\nimport * as _slimdom from 'slimdom';\nexport const slimdom = _slimdom;\n\nexport { Options, DEFAULT_OPTIONS } from './options';\nexport { DEFAULT_NAMESPACES } from './createNamespaceContext';\nexport { async } from './asynchronouslyParseSlimdomDocument';\nexport { sync } from './synchronouslyParseSlimdomDocument';\n","import * as saxes from 'saxes';\nimport { DEFAULT_OPTIONS, Options } from './options';\nimport { Document } from 'slimdom';\nimport { Readable } from 'stream';\n\nimport createHandler from './createHandler';\n\n/**\n * Asynchronously parse a string or readable stream of XML to a Slimdom document.\n */\nexport function async(xml: string | Readable, options?: Options): Promise<Document> {\n\treturn new Promise((resolve, reject) => {\n\t\t// Set up the sax parser\n\t\tconst mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n\t\tconst parser = new saxes.SaxesParser(mergedOptions);\n\t\tconst handler = createHandler(parser, mergedOptions);\n\n\t\t// Bind the handler functions to saxes events\n\t\tparser.on('attribute', handler.onAttribute);\n\t\tparser.on('cdata', handler.onCdata);\n\t\tparser.on('closetag', handler.onCloseTag);\n\t\tparser.on('comment', handler.onComment);\n\t\tparser.on('doctype', handler.onDocType);\n\t\tparser.on('error', error => {\n\t\t\treject(error);\n\t\t});\n\t\tparser.on('opentag', handler.onOpenTag);\n\t\tparser.on('opentagstart', handler.onOpenTagStart);\n\t\tparser.on('processinginstruction', handler.onProcessingInstruction);\n\t\tparser.on('text', handler.onText);\n\n\t\t// Handle additionalEntities\n\t\tif (options !== undefined && options.additionalEntities !== undefined) {\n\t\t\tfor (const [entity, entityValue] of Object.entries(options.additionalEntities)) {\n\t\t\t\tparser.ENTITIES[entity] = entityValue;\n\t\t\t}\n\t\t}\n\n\t\t// Take input from either a string argument...\n\t\tif (typeof xml === 'string') {\n\t\t\tparser.write(xml).close();\n\t\t\tresolve(handler.document);\n\t\t\treturn;\n\t\t}\n\n\t\t// Or take input from a readable string...\n\t\tif (xml instanceof Readable) {\n\t\t\txml.on('readable', () => {\n\t\t\t\tlet chunk;\n\t\t\t\twhile ((chunk = xml.read(xml.readableHighWaterMark || 8 * 1024))) {\n\t\t\t\t\tparser.write(chunk);\n\t\t\t\t}\n\t\t\t});\n\t\t\txml.on('end', () => {\n\t\t\t\tparser.close();\n\t\t\t\tresolve(handler.document);\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\t// Or throw on invalid input.\n\t\treject(new Error(`Unsupported input type ${typeof xml}.`));\n\t});\n}\n","import * as saxes from 'saxes';\nimport { DEFAULT_OPTIONS, Options } from './options';\n\nimport createHandler from './createHandler';\n\n/**\n * Synchronously parse a string of XML to a Slimdom document.\n */\nexport function sync(xml: string, options?: Options) {\n\t// Set up the sax parser\n\tconst mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n\tconst parser = new saxes.SaxesParser(mergedOptions);\n\tconst handler = createHandler(parser, mergedOptions);\n\n\t// Bind the handler functions to saxes events\n\tparser.on('attribute', handler.onAttribute);\n\tparser.on('cdata', handler.onCdata);\n\tparser.on('closetag', handler.onCloseTag);\n\tparser.on('comment', handler.onComment);\n\tparser.on('doctype', handler.onDocType);\n\tparser.on('opentag', handler.onOpenTag);\n\tparser.on('opentagstart', handler.onOpenTagStart);\n\tparser.on('processinginstruction', handler.onProcessingInstruction);\n\tparser.on('text', handler.onText);\n\n\t// Handle additionalEntities\n\tif (options !== undefined && options.additionalEntities !== undefined) {\n\t\tfor (const [entity, entityValue] of Object.entries(options.additionalEntities)) {\n\t\t\tparser.ENTITIES[entity] = entityValue;\n\t\t}\n\t}\n\n\tparser.write(xml).close();\n\n\treturn handler.document;\n}\n"],"names":["DEFAULT_OPTIONS","xmlns","position","additionalEntities","DEFAULT_NAMESPACES","xml","positionTrackerStubs","getCurrentPosition","offset","line","column","trackAttributePosition","attr","trackNodeClosePosition","node","trackNodePosition","updateLastTrackedPosition","createHandler","parser","options","document","Document","contextNode","namespaces","additionalNsMapping","undefined","unshift","push","x","pop","shift","location","prefix","find","ns","_namespaces$find","createNamespaceContext","additionalNamespaces","lastTrackedPosition","nodeType","endPosition","end","closePosition","start","createPositionTracker","attributePositions","Map","onText","text","textNode","createTextNode","appendChild","onOpenTag","element","nsLocation","Error","createElementNS","name","Object","keys","attributes","map","forEach","namespaceURI","get","attributeNode","createAttributeNS","value","setAttributeNode","onOpenTagStart","onAttribute","attribute","set","onCloseTag","parentNode","onProcessingInstruction","pi","createProcessingInstruction","target","body","onComment","comment","createComment","onDocType","data","qualifiedName","publicIdOrSystemId","systemId","source","match","buf","reg","lastIndex","exec","splitDoctypeDeclaration","publicId","replace","implementation","createDocumentType","onCdata","string","createCDATASection","slimdom","_slimdom","Promise","resolve","reject","mergedOptions","saxes","handler","on","error","entries","ENTITIES","write","close","Readable","chunk","read","readableHighWaterMark"],"mappings":"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"}