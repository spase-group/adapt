'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _slimdom = require('slimdom');
var saxes = require('saxes');
var stream = require('stream');

var DEFAULT_OPTIONS = {
  xmlns: true,
  position: false,
  additionalEntities: {}
};

var DEFAULT_NAMESPACES = {
  '': null,
  // Two namespace prefixes that are predetermined by the XML spec.
  //
  // See also:
  //   https://www.w3.org/TR/xml-names/#ns-decl
  xml: 'http://www.w3.org/XML/1998/namespace',
  xmlns: 'http://www.w3.org/2000/xmlns/'
};
/**
 * Records an array of overlapping objects that is shifted and unshifted as the parser traverses.
 */

function createNamespaceContext(additionalNsMapping) {
  var namespaces = [DEFAULT_NAMESPACES];

  if (additionalNsMapping !== undefined) {
    namespaces.unshift(additionalNsMapping);
  }

  return {
    // pop and push are actually shift and unshift to make searches more efficient
    push: function push(x) {
      return namespaces.unshift(x);
    },
    pop: function pop() {
      return namespaces.shift();
    },
    // Get the location associated with a prefix
    location: function location(prefix) {
      var _namespaces$find;

      return prefix === undefined ? prefix : (_namespaces$find = namespaces.find(function (ns) {
        return ns[prefix] !== undefined;
      })) == null ? void 0 : _namespaces$find[prefix];
    }
  };
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/**
 * The DOM node types enumeration. Only TEXT_NODE and COMMENT_NODE are used, so the rest is commented out.
 *
 * See also:
 *   https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
 */
var types = {
  // ELEMENT_NODE: 1,
  // ATTRIBUTE_NODE: 2,
  TEXT_NODE: 3,
  // CDATA_SECTION_NODE: 4,
  // ENTITY_REFERENCE_NODE: 5,
  // ENTITY_NODE: 6,
  // PROCESSING_INSTRUCTION_NODE: 7,
  COMMENT_NODE: 8 // DOCUMENT_NODE: 9,
  // DOCUMENT_TYPE_NODE: 10,
  // DOCUMENT_FRAGMENT_NODE: 11,
  // NOTATION_NODE: 12

};
/**
 * Create the context needed to track the positions in an XML string at which a Slimdom node was defined. Is based on
 * input from the saxes parser and fixes some unexpected behaviour by it.
 */

function createPositionTracker(parser) {
  var lastTrackedPosition = {
    // Line and column numbers are 1-based
    line: 1,
    column: 1,
    // Offset (start + end) are 0-based
    offset: 0
  };

  function updateLastTrackedPosition() {
    lastTrackedPosition = getCurrentPosition();
  } // Fixes some quirky results from saxes' position tracking:
  // - XML comments were always one character short


  function getCurrentPosition(node) {
    var position = {
      offset: parser.position,
      line: parser.line,
      column: parser.column + 1
    };

    if (!node) {
      return position;
    }

    if (node.nodeType === types.TEXT_NODE) {
      // For XML text nodes the position tracking is always received when the next node is instantiated, eg.
      // the opening tag of the next sibling element or closing tag would show up in the text substr.
      // Therefore fix endPosition by not counting the next element or closing tag.
      position.offset--;
      position.column--;
    } else if (node.nodeType === types.COMMENT_NODE) {
      // For XML comments the position tracking is always received one character too short.
      // This right here is a local fix, and rather crude.
      position.offset++;
      position.column++;
    }

    return position;
  } // Updates the tracker with new input from the saxes parser, and writes a "position" property to the DOM node
  // that was passed.


  function trackNodePosition(node) {
    var endPosition = getCurrentPosition(node);
    node.position = {
      line: lastTrackedPosition.line,
      column: lastTrackedPosition.column,
      start: lastTrackedPosition.offset,
      end: endPosition.offset
    };
    lastTrackedPosition = endPosition;
    return node;
  }

  function trackNodeClosePosition(node) {
    var endPosition = getCurrentPosition(node);
    node.closePosition = {
      line: lastTrackedPosition.line,
      column: lastTrackedPosition.column,
      start: lastTrackedPosition.offset,
      end: endPosition.offset
    };
    lastTrackedPosition = endPosition;
    return node;
  }

  function trackAttributePosition(attr, endPosition) {
    attr.position = {
      end: endPosition.offset
    };
    return attr;
  }

  return {
    getCurrentPosition: getCurrentPosition,
    trackAttributePosition: trackAttributePosition,
    trackNodeClosePosition: trackNodeClosePosition,
    trackNodePosition: trackNodePosition,
    updateLastTrackedPosition: updateLastTrackedPosition
  };
}
/**
 * No-op alternative for position tracking, when position tracking is disabled.
 */

var positionTrackerStubs = {
  getCurrentPosition: function getCurrentPosition() {
    return {
      offset: 0,
      line: 0,
      column: 0
    };
  },
  trackAttributePosition: function trackAttributePosition(attr) {
    return attr;
  },
  trackNodeClosePosition: function trackNodeClosePosition(node) {
    return node;
  },
  trackNodePosition: function trackNodePosition(node) {
    return node;
  },
  updateLastTrackedPosition: function updateLastTrackedPosition() {}
};

/*
 * Split the doctype string
 * Thanks to https://github.com/jindw/xmldom
 */
function splitDoctypeDeclaration(source, start) {
  if (start === void 0) {
    start = 0;
  }

  var match;
  var buf = [];
  var reg = /'[^']+'|"[^"]+"|[^\s<>/=]+=?|(\/?\s*>|<)/g;
  reg.lastIndex = start;
  reg.exec(source); //skip <

  while (match = reg.exec(source)) {
    buf.push(match[0]);
    if (match[1]) return buf;
  }

  return buf;
}

function parseDoctypeDeclaration(source) {
  var _splitDoctypeDeclarat = splitDoctypeDeclaration(source),
      qualifiedName = _splitDoctypeDeclarat[1],
      // @ts-ignore TS6133
  type = _splitDoctypeDeclarat[2],
      publicIdOrSystemId = _splitDoctypeDeclarat[3],
      systemId = _splitDoctypeDeclarat[4];

  return type === 'PUBLIC' ? {
    qualifiedName: qualifiedName,
    publicId: publicIdOrSystemId.replace(/^"(.*)"$/, '$1'),
    systemId: (systemId == null ? void 0 : systemId.replace(/^"(.*)"$/, '$1')) || null
  } : {
    qualifiedName: qualifiedName,
    publicId: null,
    systemId: publicIdOrSystemId.replace(/^"(.*)"$/, '$1')
  };
}

/*
 * Create the required callbacks for populating a new document from sax event handlers
 */

function createHandler(parser, options) {
  // A new XML DOM object that has the same API as the browser DOM implementation, but isomorphic and supports
  // namespaces.
  var document = new _slimdom.Document(); // The node into which new child nodes are inserted. Is rewritten as the handler traverses in and out of elements.

  var contextNode = document; // Helpers for other responsibilities

  var namespaces = createNamespaceContext(options.additionalNamespaces || {});

  var _ref = options.position ? createPositionTracker(parser) : positionTrackerStubs,
      trackNodePosition = _ref.trackNodePosition,
      trackNodeClosePosition = _ref.trackNodeClosePosition,
      updateLastTrackedPosition = _ref.updateLastTrackedPosition,
      getCurrentPosition = _ref.getCurrentPosition,
      trackAttributePosition = _ref.trackAttributePosition;

  var attributePositions = new Map(); // Return a bunch of methods that can be applied directly to a saxes parser instance.

  return {
    onText: function onText(text) {
      if (contextNode === document) {
        updateLastTrackedPosition();
        return;
      }

      var textNode = trackNodePosition(document.createTextNode(text));
      contextNode.appendChild(textNode);
    },
    onOpenTag: function onOpenTag(element) {
      // More namespace declarations might be applicable
      if (element.ns) {
        namespaces.push(element.ns);
      }

      var nsLocation = namespaces.location(element.prefix);

      if (nsLocation === undefined) {
        throw new Error("Could not resolve a namespace location for \"" + element.prefix + "\"");
      }

      var node = trackNodePosition(document.createElementNS(nsLocation, element.name));
      Object.keys(element.attributes).map(function (name) {
        return element.attributes[name];
      }).forEach(function (attr) {
        if (typeof attr === 'string') {
          // @TODO Find out why saxes sometimes uses strings instead of SaxesAttributeNs
          return;
        } // Default namespace declarations do not apply to attributes, so if an attribute
        // is not prefixed the namespace location is null


        var namespaceURI = attr.prefix === '' ? null : namespaces.location(attr.prefix); // @xmlns has no prefix but is in the XMLNS namespace

        if (attr.prefix === '' && attr.name === 'xmlns') {
          namespaceURI = namespaces.location('xmlns');
        }

        var position = attributePositions.get(attr.name);
        var attributeNode = trackAttributePosition(document.createAttributeNS(namespaceURI, attr.name), position);
        attributeNode.value = attr.value;
        node.setAttributeNode(attributeNode);
      });
      contextNode.appendChild(node);
      contextNode = node;
    },
    onOpenTagStart: function onOpenTagStart() {
      attributePositions = new Map();
    },
    onAttribute: function onAttribute(attribute) {
      attributePositions.set(attribute.name, getCurrentPosition());
    },
    onCloseTag: function onCloseTag() {
      // Update position tracking so that the closing tag of an element is not prepended to the following sibling
      trackNodeClosePosition(contextNode);

      if (!contextNode.parentNode) {
        throw new Error('End of the line!');
      } // Any traversal from now on is within a higher context element


      contextNode = contextNode.parentNode; // Less namespace declarations might now be applicable

      namespaces.pop();
    },
    onProcessingInstruction: function onProcessingInstruction(pi) {
      contextNode.appendChild(trackNodePosition(document.createProcessingInstruction(pi.target, pi.body)));
    },
    onComment: function onComment(comment) {
      contextNode.appendChild(trackNodePosition(document.createComment(comment)));
    },
    onDocType: function onDocType(data) {
      var _parseDoctypeDeclarat = parseDoctypeDeclaration("<!DOCTYPE " + data + ">"),
          qualifiedName = _parseDoctypeDeclarat.qualifiedName,
          publicId = _parseDoctypeDeclarat.publicId,
          systemId = _parseDoctypeDeclarat.systemId;

      contextNode.appendChild(trackNodePosition(document.implementation.createDocumentType(qualifiedName, publicId || '', systemId || '')));
    },
    onCdata: function onCdata(string) {
      contextNode.appendChild(trackNodePosition(document.createCDATASection(string)));
    },
    document: document
  };
}

/**
 * Asynchronously parse a string or readable stream of XML to a Slimdom document.
 */

function async(xml, options) {
  return new Promise(function (resolve, reject) {
    // Set up the sax parser
    var mergedOptions = _extends({}, DEFAULT_OPTIONS, options);

    var parser = new saxes.SaxesParser(mergedOptions);
    var handler = createHandler(parser, mergedOptions); // Bind the handler functions to saxes events

    parser.on('attribute', handler.onAttribute);
    parser.on('cdata', handler.onCdata);
    parser.on('closetag', handler.onCloseTag);
    parser.on('comment', handler.onComment);
    parser.on('doctype', handler.onDocType);
    parser.on('error', function (error) {
      reject(error);
    });
    parser.on('opentag', handler.onOpenTag);
    parser.on('opentagstart', handler.onOpenTagStart);
    parser.on('processinginstruction', handler.onProcessingInstruction);
    parser.on('text', handler.onText); // Handle additionalEntities

    if (options !== undefined && options.additionalEntities !== undefined) {
      for (var _i = 0, _Object$entries = Object.entries(options.additionalEntities); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _Object$entries[_i],
            entity = _Object$entries$_i[0],
            entityValue = _Object$entries$_i[1];
        parser.ENTITIES[entity] = entityValue;
      }
    } // Take input from either a string argument...


    if (typeof xml === 'string') {
      parser.write(xml).close();
      resolve(handler.document);
      return;
    } // Or take input from a readable string...


    if (xml instanceof stream.Readable) {
      xml.on('readable', function () {
        var chunk;

        while (chunk = xml.read(xml.readableHighWaterMark || 8 * 1024)) {
          parser.write(chunk);
        }
      });
      xml.on('end', function () {
        parser.close();
        resolve(handler.document);
      });
      return;
    } // Or throw on invalid input.


    reject(new Error("Unsupported input type " + typeof xml + "."));
  });
}

/**
 * Synchronously parse a string of XML to a Slimdom document.
 */

function sync(xml, options) {
  // Set up the sax parser
  var mergedOptions = _extends({}, DEFAULT_OPTIONS, options);

  var parser = new saxes.SaxesParser(mergedOptions);
  var handler = createHandler(parser, mergedOptions); // Bind the handler functions to saxes events

  parser.on('attribute', handler.onAttribute);
  parser.on('cdata', handler.onCdata);
  parser.on('closetag', handler.onCloseTag);
  parser.on('comment', handler.onComment);
  parser.on('doctype', handler.onDocType);
  parser.on('opentag', handler.onOpenTag);
  parser.on('opentagstart', handler.onOpenTagStart);
  parser.on('processinginstruction', handler.onProcessingInstruction);
  parser.on('text', handler.onText); // Handle additionalEntities

  if (options !== undefined && options.additionalEntities !== undefined) {
    for (var _i = 0, _Object$entries = Object.entries(options.additionalEntities); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _Object$entries[_i],
          entity = _Object$entries$_i[0],
          entityValue = _Object$entries$_i[1];
      parser.ENTITIES[entity] = entityValue;
    }
  }

  parser.write(xml).close();
  return handler.document;
}

// Workaround for `export * as slimdom`, which doesn't work well in some TS versions
var slimdom = _slimdom;

exports.DEFAULT_NAMESPACES = DEFAULT_NAMESPACES;
exports.DEFAULT_OPTIONS = DEFAULT_OPTIONS;
exports.async = async;
exports.slimdom = slimdom;
exports.sync = sync;
//# sourceMappingURL=slimdom-sax-parser.cjs.development.js.map
