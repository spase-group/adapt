/**
 * Interface AbstractRange
 *
 * Objects implementing the AbstractRange interface are known as ranges.
 *
 * @public
 */
declare interface AbstractRange {
    readonly startContainer: Node;
    readonly startOffset: number;
    readonly endContainer: Node;
    readonly endOffset: number;
    readonly collapsed: boolean;
}

/**
 * 3.9.2. Interface Attr
 *
 * @public
 */
export declare class Attr extends Node {
    get nodeType(): number;
    get nodeName(): string;
    get nodeValue(): string | null;
    set nodeValue(newValue: string | null);
    get textContent(): string | null;
    set textContent(newValue: string | null);
    lookupPrefix(namespace: string | null): string | null;
    lookupNamespaceURI(prefix: string | null): string | null;
    readonly namespaceURI: string | null;
    readonly prefix: string | null;
    readonly localName: string;
    readonly name: string;
    private _value;
    get value(): string;
    set value(value: string);
    ownerElement: Element | null;
    /**
     * (non-standard) use Document#createAttribute(NS) or Element#setAttribute(NS) to create
     * attribute nodes
     *
     * @param namespace - The namespace URI for the attribute
     * @param prefix    - The prefix for the attribute
     * @param localName - The local name for the attribute
     * @param value     - The value for the attribute
     * @param element   - The element for the attribute, or null if the attribute is not attached to
     *                    an element
     */
    constructor(namespace: string | null, prefix: string | null, localName: string, value: string, element: Element | null);
    /**
     * (non-standard) Creates a copy of this, not including its children.
     *
     * @param document - The node document to associate with the copy
     *
     * @returns A shallow copy of this
     */
    _copy(document: Document): Attr;
}

/**
 * @public
 */
export declare class CDATASection extends Text {
    get nodeType(): number;
    get nodeName(): string;
    /**
     * (non-standard) use Document#createCDATASection to create a CDATA section.
     *
     * @param data - The data for the node
     */
    constructor(data: string);
    /**
     * (non-standard) Creates a copy of this, not including its children.
     *
     * @param document - The node document to associate with the copy
     *
     * @returns A shallow copy of this
     */
    _copy(document: Document): CDATASection;
}

/**
 * 3.10. Interface CharacterData
 *
 * @public
 */
export declare abstract class CharacterData extends Node implements NonDocumentTypeChildNode, ChildNode {
    get nodeValue(): string | null;
    set nodeValue(newValue: string | null);
    get textContent(): string | null;
    set textContent(newValue: string | null);
    lookupPrefix(namespace: string | null): string | null;
    lookupNamespaceURI(prefix: string | null): string | null;
    before(...nodes: (Node | string)[]): void;
    after(...nodes: (Node | string)[]): void;
    replaceWith(...nodes: (Node | string)[]): void;
    remove(): void;
    get previousElementSibling(): Element | null;
    get nextElementSibling(): Element | null;
    /**
     * Each node inheriting from the CharacterData interface has an associated mutable string called
     * data.
     */
    protected _data: string;
    get data(): string;
    set data(newValue: string);
    get length(): number;
    /**
     * (non-standard) CharacterData should never be instantiated directly.
     *
     * @param data - The data to associate with the node
     */
    protected constructor(data: string);
    /**
     * Returns a substring of the node's data.
     *
     * @param offset - Offset at which to start the substring
     * @param count  - The number of code units to return
     *
     * @returns The specified substring
     */
    substringData(offset: number, count: number): string;
    /**
     * Appends data to the node's data.
     *
     * @param data - Data to append
     */
    appendData(data: string): void;
    /**
     * Inserts data at the specified position in the node's data.
     *
     * @param offset - Offset at which to insert
     * @param data   - Data to insert
     */
    insertData(offset: number, data: string): void;
    /**
     * Deletes data from the specified position.
     *
     * @param offset - Offset at which to delete
     * @param count  - Number of code units to delete
     */
    deleteData(offset: number, count: number): void;
    /**
     * Replaces data at the specified position.
     *
     * @param offset - Offset at which to replace
     * @param count  - Number of code units to remove
     * @param data   - Data to insert
     */
    replaceData(offset: number, count: number, data: string): void;
}

/**
 * 3.2.8. Mixin ChildNode
 */
declare interface ChildNode {
    before(...nodes: (Node | string)[]): void;
    after(...nodes: (Node | string)[]): void;
    replaceWith(...nodes: (Node | string)[]): void;
    remove(): void;
}

/**
 * @public
 */
export declare class Comment extends CharacterData {
    get nodeType(): number;
    get nodeName(): string;
    /**
     * Returns a new Comment node whose data is data and node document is current global object’s
     * associated Document.
     *
     * @param data - The data for the new comment
     */
    constructor(data?: string);
    /**
     * (non-standard) Creates a copy of this, not including its children.
     *
     * @param document - The node document to associate with the copy
     *
     * @returns A shallow copy of this
     */
    _copy(document: Document): Comment;
}

/**
 * 3.5. Interface Document
 *
 * @public
 */
export declare class Document extends Node implements NonElementParentNode, ParentNode {
    get nodeType(): number;
    get nodeName(): string;
    get nodeValue(): string | null;
    set nodeValue(_newValue: string | null);
    get textContent(): string | null;
    set textContent(_newValue: string | null);
    lookupPrefix(namespace: string | null): string | null;
    lookupNamespaceURI(prefix: string | null): string | null;
    get children(): Element[];
    firstElementChild: Element | null;
    lastElementChild: Element | null;
    childElementCount: number;
    prepend(...nodes: (Node | string)[]): void;
    append(...nodes: (Node | string)[]): void;
    replaceChildren(...nodes: (Node | string)[]): void;
    /**
     * Returns a reference to the DOMImplementation object associated with the document.
     */
    readonly implementation: DOMImplementation;
    /**
     * The doctype, or null if there is none.
     */
    doctype: DocumentType | null;
    /**
     * The document element, or null if there is none.
     */
    documentElement: Element | null;
    /**
     * Creates a new Document.
     *
     * Note: Unlike DOMImplementation#createDocument(), this constructor does not return an
     * XMLDocument object, but a document (Document object).
     */
    constructor();
    /**
     * Returns the list of elements with the given qualified name.
     *
     * @param qualifiedName - Qualified name of the elements to collect.
     *
     * @returns  The list of elements with matching qualified name.
     */
    getElementsByTagName(qualifiedName: string): Element[];
    /**
     * Returns the list of elements with the given namespace and local name.
     *
     * @param namespace - Namespace URI of the elements to collect.
     * @param localName - Local name of the elements to collect
     *
     * @returns  The list of elements with matching namespace and local name.
     */
    getElementsByTagNameNS(namespace: string | null, localName: string): Element[];
    /**
     * Creates a new element in the null namespace.
     *
     * @param localName - Local name of the element
     *
     * @returns The new element
     */
    createElement(localName: string): Element;
    /**
     * Creates a new element in the given namespace.
     *
     * @param namespace     - Namespace URI for the new element
     * @param qualifiedName - Qualified name for the new element
     *
     * @returns The new element
     */
    createElementNS(namespace: string | null, qualifiedName: string): Element;
    /**
     * Returns a new DocumentFragment node with its node document set to this.
     *
     * @returns The new document fragment
     */
    createDocumentFragment(): DocumentFragment;
    /**
     * Returns a new Text node with its data set to data and node document set to this.
     *
     * @param data - Data for the new text node
     *
     * @returns The new text node
     */
    createTextNode(data: string): Text;
    /**
     * Returns a new CDATA section with the given data and node document set to this.
     *
     * @param data - Data for the new CDATA section
     *
     * @returns The new CDATA section
     */
    createCDATASection(data: string): CDATASection;
    /**
     * Returns a new Comment node with its data set to data and node document set to this.
     *
     * @param data - Data for the new comment
     *
     * @returns The new comment node
     */
    createComment(data: string): Comment;
    /**
     * Creates a new processing instruction node, with target set to target, data set to data, and
     * node document set to this.
     *
     * @param target - Target for the new processing instruction
     * @param data   - Data for the new processing instruction
     *
     * @returns The new processing instruction
     */
    createProcessingInstruction(target: string, data: string): ProcessingInstruction;
    /**
     * Creates a copy of a node from an external document that can be inserted into the current
     * document.
     *
     * @param node - The node to import
     * @param deep - Whether to also import node's children
     */
    importNode<TNode extends Node>(node: TNode, deep?: boolean): TNode;
    /**
     * Adopts a node. The node and its subtree is removed from the document it's in (if any), and
     * its ownerDocument is changed to the current document. The node can then be inserted into the
     * current document.
     *
     * @param node - The node to adopt
     */
    adoptNode<TNode extends Node>(node: TNode): TNode;
    /**
     * Creates a new attribute node with the null namespace and given local name.
     *
     * @param localName - The local name of the attribute
     *
     * @returns The new attribute node
     */
    createAttribute(localName: string): Attr;
    /**
     * Creates a new attribute node with the given namespace and qualified name.
     *
     * @param namespace     - Namespace URI for the new attribute, or null for the null namespace
     * @param qualifiedName - Qualified name for the new attribute
     *
     * @returns The new attribute node
     */
    createAttributeNS(namespace: string | null, qualifiedName: string): Attr;
    /**
     * Creates a new live Range, initially positioned at the root of this document.
     *
     * @returns The new Range
     */
    createRange(): Range;
    /**
     * (non-standard) Creates a copy of this, not including its children.
     *
     * @param document - The node document to associate with the copy
     *
     * @returns A shallow copy of this
     */
    _copy(document: Document): Document;
}

/**
 * The document associated with the global object. Used when calling constructors directly.
 *
 * Do not mutate this instance. When possible, it is recommended to use `new slimdom.Document` to
 * create a new document, and then use the factory methods on that instance to create other nodes.
 *
 * @public
 */
export declare const document: Document;

/**
 * @public
 */
export declare class DocumentFragment extends Node implements NonElementParentNode, ParentNode {
    get nodeType(): number;
    get nodeName(): string;
    get nodeValue(): string | null;
    set nodeValue(newValue: string | null);
    get textContent(): string | null;
    set textContent(newValue: string | null);
    lookupPrefix(namespace: string | null): string | null;
    lookupNamespaceURI(prefix: string | null): string | null;
    get children(): Element[];
    firstElementChild: Element | null;
    lastElementChild: Element | null;
    childElementCount: number;
    prepend(...nodes: (Node | string)[]): void;
    append(...nodes: (Node | string)[]): void;
    replaceChildren(...nodes: (Node | string)[]): void;
    /**
     * Return a new DocumentFragment node whose node document is current global object’s associated
     * Document.
     */
    constructor();
    /**
     * (non-standard) Creates a copy of this, not including its children.
     *
     * @param document - The node document to associate with the copy
     *
     * @returns A shallow copy of this
     */
    _copy(document: Document): DocumentFragment;
}

/**
 * @public
 */
export declare class DocumentType extends Node implements ChildNode {
    get nodeType(): number;
    get nodeName(): string;
    get nodeValue(): string | null;
    set nodeValue(_newValue: string | null);
    get textContent(): string | null;
    set textContent(_newValue: string | null);
    lookupPrefix(namespace: string | null): string | null;
    lookupNamespaceURI(prefix: string | null): string | null;
    before(...nodes: (Node | string)[]): void;
    after(...nodes: (Node | string)[]): void;
    replaceWith(...nodes: (Node | string)[]): void;
    remove(): void;
    /**
     * The name of the doctype.
     */
    name: string;
    /**
     * The public ID of the doctype.
     */
    publicId: string;
    /**
     * The system ID of the doctype.
     */
    systemId: string;
    /**
     * (non-standard) Use DOMImplementation#createDocumentType instead.
     *
     * @param name     - The name of the doctype
     * @param publicId - The public ID of the doctype
     * @param systemId - The system ID of the doctype
     */
    constructor(name: string, publicId?: string, systemId?: string);
    /**
     * (non-standard) Creates a copy of this, not including its children.
     *
     * @param document - The node document to associate with the copy
     *
     * @returns A shallow copy of this
     */
    _copy(document: Document): DocumentType;
}

/**
 * Exception type used for DOM errors
 *
 * @public
 */
export declare class DOMException extends Error {
    readonly name: string;
    readonly message: string;
    readonly code: number;
    readonly stack: string | undefined;
    constructor(message?: string, name?: string);
}

/**
 * @public
 */
export declare class DOMImplementation {
    private _document;
    /**
     * (non-standard) Use Document#implementation to access instances of this class
     *
     * @param document - The document to associate with this instance
     */
    constructor(document: Document);
    /**
     * Returns a doctype, with the given qualifiedName, publicId, and systemId.
     *
     * @param qualifiedName - Qualified name for the doctype
     * @param publicId      - Public ID for the doctype
     * @param systemId      - System ID for the doctype
     *
     * @returns The new doctype node
     */
    createDocumentType(qualifiedName: string, publicId: string, systemId: string): DocumentType;
    /**
     * Returns an XMLDocument, with a document element whose local name is qualifiedName and whose
     * namespace is namespace (unless qualifiedName is the empty string), and with doctype, if it is
     * given, as its doctype.
     *
     * @param namespace     - The namespace for the root element
     * @param qualifiedName - The qualified name for the root element, or empty string to not create
     *                        a root element
     * @param doctype       - The doctype for the new document, or null to not add a doctype
     *
     * @returns The new XMLDocument
     */
    createDocument(namespace: string | null, qualifiedName: string | null, doctype?: DocumentType | null): XMLDocument;
    /**
     * Returns a HTML document with a basic tree already constructed.
     *
     * @param title - Optional title for the new HTML document
     *
     * @returns The new document
     */
    createHTMLDocument(title?: string | null): Document;
}

/**
 * 3.9. Interface Element
 *
 * @public
 */
export declare class Element extends Node implements ParentNode, NonDocumentTypeChildNode, ChildNode {
    get nodeType(): number;
    get nodeName(): string;
    get nodeValue(): string | null;
    set nodeValue(newValue: string | null);
    get textContent(): string | null;
    set textContent(newValue: string | null);
    lookupPrefix(namespace: string | null): string | null;
    lookupNamespaceURI(prefix: string | null): string | null;
    before(...nodes: (Node | string)[]): void;
    after(...nodes: (Node | string)[]): void;
    replaceWith(...nodes: (Node | string)[]): void;
    remove(): void;
    get children(): Element[];
    firstElementChild: Element | null;
    lastElementChild: Element | null;
    childElementCount: number;
    prepend(...nodes: (Node | string)[]): void;
    append(...nodes: (Node | string)[]): void;
    replaceChildren(...nodes: (Node | string)[]): void;
    get previousElementSibling(): Element | null;
    get nextElementSibling(): Element | null;
    readonly namespaceURI: string | null;
    readonly prefix: string | null;
    readonly localName: string;
    readonly tagName: string;
    /**
     * (non-standard) Use Document#createElement or Document#createElementNS to create an Element.
     *
     * @param namespace - Namespace for the element
     * @param prefix    - Prefix for the element
     * @param localName - Local name for the element
     */
    constructor(namespace: string | null, prefix: string | null, localName: string);
    /**
     * Returns whether the element has any attributes.
     *
     * @returns True if the element has attributes, otherwise false
     */
    hasAttributes(): boolean;
    /**
     * The attributes for the element.
     *
     * Non-standard: the spec defines this as a NamedNodeMap, while this implementation uses an
     * array.
     */
    readonly attributes: Attr[];
    /**
     * Get the value of the specified attribute.
     *
     * @param qualifiedName - The qualified name of the attribute
     *
     * @returns The value of the attribute, or null if no such attribute exists
     */
    getAttribute(qualifiedName: string): string | null;
    /**
     * Get the value of the specified attribute.
     *
     * @param namespace - The namespace of the attribute
     * @param localName - The local name of the attribute
     *
     * @returns The value of the attribute, or null if no such attribute exists
     */
    getAttributeNS(namespace: string | null, localName: string): string | null;
    /**
     * Sets the value of the specified attribute.
     *
     * @param qualifiedName - The qualified name of the attribute
     * @param value         - The new value for the attribute
     */
    setAttribute(qualifiedName: string, value: string): void;
    /**
     * Sets the value of the specified attribute.
     *
     * @param namespace     - The namespace of the attribute
     * @param qualifiedName - The qualified name of the attribute
     * @param value         - The value for the attribute
     */
    setAttributeNS(namespace: string | null, qualifiedName: string, value: string): void;
    /**
     * Removes the specified attribute.
     *
     * @param qualifiedName - The qualified name of the attribute
     */
    removeAttribute(qualifiedName: string): void;
    /**
     * Removes the specified attribute.
     *
     * @param namespace - The namespace of the attribute
     * @param localName - The local name of the attribute
     */
    removeAttributeNS(namespace: string | null, localName: string): void;
    /**
     * If force is not given, "toggles" qualifiedName, removing it if it is present and adding it if
     * it is not present. If force is true, adds qualifiedName. If force is false, removes
     * qualifiedName.
     *
     * Returns true if qualifiedName is now present, and false otherwise.
     *
     * @param qualifiedName - The qualified name of the attribute to toggle
     * @param force         - If true, adds the attribute, if false removes it
     */
    toggleAttribute(qualifiedName: string, force?: boolean): boolean;
    /**
     * Returns true if the specified attribute exists and false otherwise.
     *
     * @param qualifiedName - The qualified name of the attribute
     */
    hasAttribute(qualifiedName: string): boolean;
    /**
     * Returns true if the specified attribute exists and false otherwise.
     *
     * @param namespace - The namespace of the attribute
     * @param localName - The local name of the attribute
     */
    hasAttributeNS(namespace: string | null, localName: string): boolean;
    /**
     * Returns the specified attribute node, or null if no such attribute exists.
     *
     * @param qualifiedName - The qualified name of the attribute
     *
     * @returns The attribute, or null if no such attribute exists
     */
    getAttributeNode(qualifiedName: string): Attr | null;
    /**
     * Returns the specified attribute node, or null if no such attribute exists.
     *
     * @param namespace - The namespace of the attribute
     * @param localName - The local name of the attribute
     *
     * @returns The attribute, or null if no such attribute exists
     */
    getAttributeNodeNS(namespace: string | null, localName: string): Attr | null;
    /**
     * Sets an attribute given its node
     *
     * @param attr - The attribute node to set
     *
     * @returns The previous attribute node for the attribute
     */
    setAttributeNode(attr: Attr): Attr | null;
    /**
     * Sets an attribute given its node
     *
     * @param attr - The attribute node to set
     *
     * @returns The previous attribute node for the attribute
     */
    setAttributeNodeNS(attr: Attr): Attr | null;
    /**
     * Removes an attribute given its node
     *
     * @param attr - The attribute node to remove
     *
     * @returns The removed attribute node
     */
    removeAttributeNode(attr: Attr): Attr;
    /**
     * Returns the list of elements with the given qualified name.
     *
     * @param qualifiedName - Qualified name of the elements to collect.
     *
     * @returns  The list of elements with matching qualified name.
     */
    getElementsByTagName(qualifiedName: string): Element[];
    /**
     * Returns the list of elements with the given namespace and local name.
     *
     * @param namespace - Namespace URI of the elements to collect.
     * @param localName - Local name of the elements to collect
     *
     * @returns  The list of elements with matching namespace and local name.
     */
    getElementsByTagNameNS(namespace: string | null, localName: string): Element[];
    /**
     * (non-standard) Creates a copy of the given node
     *
     * @param document - The node document to associate with the copy
     * @param other    - The node to copy
     *
     * @returns A shallow copy of the node
     */
    _copy(document: Document): Element;
    /**
     * Returns a fragment of HTML or XML that represents the element's contents.
     */
    get innerHTML(): string;
    /**
     * Returns a fragment of HTML or XML that represents the element and its contents.
     */
    get outerHTML(): string;
}

declare type MutationCallback = (records: MutationRecord[], observer: MutationObserver) => void;

/**
 * 3.3.1. Interface MutationObserver
 *
 * A MutationObserver object can be used to observe mutations to the tree of nodes.
 *
 * @public
 */
export declare class MutationObserver {
    /**
     * The function that will be called when control returns to the event loop, if there are any
     * queued records. The function is passed the MutationRecords and the observer instance that
     * collected them.
     */
    _callback: MutationCallback;
    /**
     * The list of nodes on which this observer is a RegisteredObserver's observer.
     */
    _nodes: Node[];
    /**
     * The list of MutationRecord objects collected so far.
     */
    _recordQueue: MutationRecord[];
    /**
     * Tracks transient registered observers created for this observer, to simplify their removal.
     */
    _transients: RegisteredObserver[];
    /**
     * Constructs a MutationObserver object and sets its callback to callback. The callback is
     * invoked with a list of MutationRecord objects as first argument and the constructed
     * MutationObserver object as second argument. It is invoked after nodes registered with the
     * observe() method, are mutated.
     *
     * @param callback - Function called after mutations have been observed.
     */
    constructor(callback: MutationCallback);
    /**
     * Instructs the user agent to observe a given target (a node) and report any mutations based on
     * the criteria given by options (an object).
     *
     * NOTE: Adding an observer to an element is just like addEventListener, if you observe the
     * element multiple times it does not make a difference. Meaning if you observe element twice,
     * the observe callback does not fire twice, nor will you have to run disconnect() twice. In
     * other words, once an element is observed, observing it again with the same will do nothing.
     * However if the callback object is different it will of course add another observer to it.
     *
     * @param target  - Node (or root of subtree) to observe
     * @param options - Determines which types of mutations to observe
     */
    observe(target: Node, options: MutationObserverInit): void;
    /**
     * Stops the MutationObserver instance from receiving notifications of DOM mutations. Until the
     * observe() method is used again, observer's callback will not be invoked.
     */
    disconnect(): void;
    /**
     * Empties the MutationObserver instance's record queue and returns what was in there.
     *
     * @returns An Array of MutationRecord objects that were recorded.
     */
    takeRecords(): MutationRecord[];
}

/**
 * @public
 */
declare interface MutationObserverInit {
    /**
     * Whether to observe childList mutations.
     */
    childList?: boolean;
    /**
     * Whether to observe attribute mutations.
     */
    attributes?: boolean;
    /**
     * Whether to observe character data mutations.
     */
    characterData?: boolean;
    /**
     * Whether to observe mutations on any descendant in addition to those on the target.
     */
    subtree?: boolean;
    /**
     * Whether to record the previous value of attributes.
     */
    attributeOldValue?: boolean;
    /**
     * Whether to record the previous value of character data nodes.
     */
    characterDataOldValue?: boolean;
}

/**
 * 3.3.3. Interface MutationRecord
 *
 * A helper class which describes a specific mutation as it is observed by a MutationObserver.
 *
 * @public
 */
export declare class MutationRecord {
    /**
     * Returns "attributes" if it was an attribute mutation. "characterData" if it was a mutation to
     * a CharacterData node. And "childList" if it was a mutation to the tree of nodes.
     */
    type: string;
    /**
     * Returns the node the mutation affected, depending on the type. For "attributes", it is the
     * element whose attribute changed. For "characterData", it is the CharacterData node. For
     * "childList", it is the node whose children changed.
     */
    target: Node;
    /**
     * Children of target added in this mutation.
     *
     * (non-standard) According to the spec this should be a NodeList. This implementation uses an
     * array.
     */
    addedNodes: Node[];
    /**
     * Children of target removed in this mutation.
     *
     * (non-standard) According to the spec this should be a NodeList. This implementation uses an
     * array.
     */
    removedNodes: Node[];
    /**
     * The previous sibling of the added or removed nodes, or null otherwise.
     */
    previousSibling: Node | null;
    /**
     * The next sibling Node of the added or removed nodes, or null otherwise.
     */
    nextSibling: Node | null;
    /**
     * The local name of the changed attribute, or null otherwise.
     */
    attributeName: string | null;
    /**
     * The namespace of the changed attribute, or null otherwise.
     */
    attributeNamespace: string | null;
    /**
     * The return value depends on type. For "attributes", it is the value of the changed attribute
     * before the change. For "characterData", it is the data of the changed node before the change.
     * For "childList", it is null.
     */
    oldValue: string | null;
    /**
     * (non-standard) Constructs a MutationRecord
     *
     * @param type   - The value for the type property
     * @param target - The value for the target property
     */
    constructor(type: string, target: Node);
}

declare interface MutationRecordInit {
    name?: string;
    namespace?: string | null;
    oldValue?: string | null;
    addedNodes?: Node[];
    removedNodes?: Node[];
    previousSibling?: Node | null;
    nextSibling?: Node | null;
}

/**
 * 3.4. Interface Node
 *
 * @public
 */
export declare abstract class Node {
    static ELEMENT_NODE: number;
    static ATTRIBUTE_NODE: number;
    static TEXT_NODE: number;
    static CDATA_SECTION_NODE: number;
    static ENTITY_REFERENCE_NODE: number;
    static ENTITY_NODE: number;
    static PROCESSING_INSTRUCTION_NODE: number;
    static COMMENT_NODE: number;
    static DOCUMENT_NODE: number;
    static DOCUMENT_TYPE_NODE: number;
    static DOCUMENT_FRAGMENT_NODE: number;
    static NOTATION_NODE: number;
    ELEMENT_NODE: number;
    ATTRIBUTE_NODE: number;
    TEXT_NODE: number;
    CDATA_SECTION_NODE: number;
    ENTITY_REFERENCE_NODE: number;
    ENTITY_NODE: number;
    PROCESSING_INSTRUCTION_NODE: number;
    COMMENT_NODE: number;
    DOCUMENT_NODE: number;
    DOCUMENT_TYPE_NODE: number;
    DOCUMENT_FRAGMENT_NODE: number;
    NOTATION_NODE: number;
    /**
     * Returns the type of node, represented by a number.
     */
    abstract get nodeType(): number;
    /**
     * Returns a string appropriate for the type of node.
     */
    abstract get nodeName(): string;
    /**
     * A reference to the Document node in which the current node resides.
     */
    ownerDocument: Document | null;
    /**
     * The parent node of the current node.
     */
    parentNode: Node | null;
    /**
     * The parent if it is an element, or null otherwise.
     */
    get parentElement(): Element | null;
    /**
     * Returns true if this has children, and false otherwise.
     */
    hasChildNodes(): boolean;
    /**
     * The node's children.
     *
     * Non-standard: implemented as an array rather than a NodeList.
     */
    childNodes: Node[];
    /**
     * The first child node of the current node, or null if it has no children.
     */
    firstChild: Node | null;
    /**
     * The last child node of the current node, or null if it has no children.
     */
    lastChild: Node | null;
    /**
     * The first preceding sibling of the current node, or null if it has none.
     */
    previousSibling: Node | null;
    /**
     * The first following sibling of the current node, or null if it has none.
     */
    nextSibling: Node | null;
    /**
     * The value of the node.
     */
    abstract get nodeValue(): string | null;
    abstract set nodeValue(value: string | null);
    /**
     * The textContent of the node.
     */
    abstract get textContent(): string | null;
    abstract set textContent(value: string | null);
    /**
     * (non-standard)
     * Each node has a registered observer list of zero or more registered observers, which is
     * initially empty.
     */
    _registeredObservers: RegisteredObservers;
    /**
     * Puts the specified node and all of its subtree into a "normalized" form. In a normalized
     * subtree, no text nodes in the subtree are empty and there are no adjacent text nodes.
     */
    normalize(): void;
    /**
     * Returns a copy of the current node.
     *
     * @param deep - Whether to also clone the node's descendants
     *
     * @returns A copy of the current node
     */
    cloneNode(deep?: boolean): this;
    /**
     * Returns true if other is an inclusive descendant of this, and false otherwise
     * (including when other is null).
     *
     * @param childNode - Node to check
     *
     * @returns Whether childNode is an inclusive descendant of the current node
     */
    contains(other: Node | null): boolean;
    /**
     *
     *
     * @param namespace - The namespace to look up
     *
     * @returns The prefix for the given namespace, or null if none was found
     */
    abstract lookupPrefix(namespace: string | null): string | null;
    /**
     * Returns the namespace for the given prefix.
     *
     * @param prefix - The prefix to look up
     *
     * @returns The namespace for the given prefix, or null if the prefix is not defined
     */
    abstract lookupNamespaceURI(prefix: string | null): string | null;
    /**
     * Return true if defaultNamespace is the same as namespace, and false otherwise.
     *
     * @param namespace - The namespace to check
     *
     * @returns Whether namespace is the default namespace
     */
    isDefaultNamespace(namespace: string | null): boolean;
    /**
     * Inserts the specified node before child within this.
     *
     * If child is null, the new node is appended after the last child node of the current node.
     *
     * @param node  - Node to insert
     * @param child - Childnode of the current node before which to insert, or null to append
     *                newNode at the end
     *
     * @returns The node that was inserted
     */
    insertBefore<TNode extends Node>(node: TNode, child: Node | null): TNode;
    /**
     * Adds node to the end of the list of children of this.
     *
     * If the node already exists it is removed from its current parent node, then added.
     *
     * @param node - Node to append
     *
     * @returns The node that was inserted
     */
    appendChild<TNode extends Node>(node: TNode): TNode;
    /**
     * Replaces child with node within this and returns child.
     *
     * @param node  - Node to insert
     * @param child - Node to remove
     *
     * @returns The node that was removed
     */
    replaceChild<TChild extends Node>(node: Node, child: TChild): TChild;
    /**
     * Removes child from this and returns the removed node.
     *
     * @param child - Child of the current node to remove
     *
     * @returns The node that was removed
     */
    removeChild<TChild extends Node>(child: TChild): TChild;
    /**
     * (non-standard) Creates a copy of this, not including its children.
     *
     * @param document - The node document to associate with the copy
     *
     * @returns A shallow copy of this
     */
    abstract _copy(document: Document): Node;
}

/**
 * 3.2.7. Mixin NonDocumentTypeChildNode
 */
declare interface NonDocumentTypeChildNode {
    readonly previousElementSibling: Element | null;
    readonly nextElementSibling: Element | null;
}

/**
 * 3.2.4. Mixin NonElementParentNode
 */
declare interface NonElementParentNode {
}

/**
 * 3.2.6. Mixin ParentNode
 */
declare interface ParentNode {
    readonly children: Element[];
    firstElementChild: Element | null;
    lastElementChild: Element | null;
    childElementCount: number;
    prepend(...nodes: (Node | string)[]): void;
    append(...nodes: (Node | string)[]): void;
    replaceChildren(...nodes: (Node | string)[]): void;
}

/**
 * 3.13. Interface ProcessingInstruction
 *
 * @public
 */
export declare class ProcessingInstruction extends CharacterData {
    get nodeType(): number;
    get nodeName(): string;
    target: string;
    /**
     * (non-standard) Use Document#createProcessingInstruction to create a processing instruction.
     *
     * @param target - The target of the processing instruction
     * @param data   - The data of the processing instruction
     */
    constructor(target: string, data: string);
    /**
     * (non-standard) Creates a copy of this, not including its children.
     *
     * @param document - The node document to associate with the copy
     *
     * @returns A shallow copy of this
     */
    _copy(document: Document): ProcessingInstruction;
}

/**
 * Interface Range
 *
 * Objects implementing the Range interface are known as live ranges.
 *
 * @public
 */
export declare class Range implements AbstractRange {
    startContainer: Node;
    startOffset: number;
    endContainer: Node;
    endOffset: number;
    get collapsed(): boolean;
    /**
     * Get the common ancestor of the range's boundary position nodes.
     *
     * Note: for efficiency reasons, this implementation deviates from the algorithm given in 4.2.
     */
    get commonAncestorContainer(): Node;
    /**
     * The Range() constructor, when invoked, must return a new live range with (current global
     * object’s associated Document, 0) as its start and end.
     */
    constructor();
    /**
     * Sets the start boundary point of the range.
     *
     * @param node   - The new start container
     * @param offset - The new start offset
     */
    setStart(node: Node, offset: number): void;
    /**
     * Sets the end boundary point of the range.
     *
     * @param node   - The new end container
     * @param offset - The new end offset
     */
    setEnd(node: Node, offset: number): void;
    /**
     * Sets the start boundary point of the range to the position just before the given node.
     *
     * @param node - The node to set the range's start before
     */
    setStartBefore(node: Node): void;
    /**
     * Sets the start boundary point of the range to the position just after the given node.
     *
     * @param node - The node to set the range's start before
     */
    setStartAfter(node: Node): void;
    /**
     * Sets the end boundary point of the range to the position just before the given node.
     *
     * @param node - The node to set the range's end before
     */
    setEndBefore(node: Node): void;
    /**
     * Sets the end boundary point of the range to the position just after the given node.
     *
     * @param node - The node to set the range's end before
     */
    setEndAfter(node: Node): void;
    /**
     * Sets the range's boundary points to the same position.
     *
     * @param toStart - If true, set both points to the start of the range, otherwise set them to
     *                  the end
     */
    collapse(toStart?: boolean): void;
    selectNode(node: Node): void;
    selectNodeContents(node: Node): void;
    static START_TO_START: number;
    static START_TO_END: number;
    static END_TO_END: number;
    static END_TO_START: number;
    compareBoundaryPoints(how: number, sourceRange: Range): number;
    /**
     * Returns a range with the same start and end as this.
     *
     * @returns A copy of this
     */
    cloneRange(): Range;
    /**
     * Stops tracking the range.
     *
     * (non-standard) According to the spec, this method must do nothing. However, it is not yet
     * possible in all browsers to allow garbage collection while keeping track of active ranges to
     * be updated by mutations. Therefore, unless your code will only run in environments that
     * implement the WeakRef proposal (https://github.com/tc39/proposal-weakrefs), make sure to call
     * this method to stop updating the range and free up its resources.
     */
    detach(): void;
    /**
     * Returns true if the given point is after or equal to the start point and before or equal to
     * the end point of this.
     *
     * @param node   - Node of point to check
     * @param offset - Offset of point to check
     *
     * @returns Whether the point is in the range
     */
    isPointInRange(node: Node, offset: number): boolean;
    /**
     * Compares the given point to the range's boundary points.
     *
     * @param node   - Node of point to check
     * @param offset - Offset of point to check
     *
     * @returns -1, 0 or 1 depending on whether the point is before, inside or after the range,
     *         respectively
     */
    comparePoint(node: Node, offset: number): number;
    /**
     * Returns true if range overlaps the range from before node to after node.
     *
     * @param node - The node to check
     *
     * @returns Whether the range intersects node
     */
    intersectsNode(node: Node): boolean;
}

/**
 * A registered observer consists of an observer (a MutationObserver object) and options (a
 * MutationObserverInit dictionary).
 *
 * A transient registered observer is a registered observer that also consists of a source (a
 * registered observer).
 *
 * Transient registered observers are used to track mutations within a given node’s descendants
 * after node has been removed so they do not get lost when subtree is set to true on node’s parent.
 */
declare class RegisteredObserver {
    /**
     * The observer that is registered.
     */
    observer: MutationObserver;
    /**
     * The Node that is being observed by the given observer.
     */
    node: Node;
    /**
     * The options for the registered observer.
     */
    options: MutationObserverInit;
    /**
     * A transient observer is an observer that has a source which is an observer.
     */
    source: RegisteredObserver | null;
    /**
     * @param observer - The observer being registered
     * @param node     - The node being observed
     * @param options  - Options for the registration
     * @param source   - If non-null, creates a transient registered observer for the given
     *                   registered observer
     */
    constructor(observer: MutationObserver, node: Node, options: MutationObserverInit, source?: RegisteredObserver);
    /**
     * Adds the given mutationRecord to the NotifyList of the registered MutationObserver. It only
     * adds the record when it's type isn't blocked by one of the flags of this registered
     * MutationObserver options (formally the MutationObserverInit object).
     *
     * @param type                - The type of mutation record to queue
     * @param target              - The target node
     * @param data                - The data for the mutation record
     * @param interestedObservers - Array of mutation observer objects to append to
     * @param pairedStrings       - Paired strings for the mutation observer objects
     */
    collectInterestedObservers(type: string, target: Node, data: MutationRecordInit, interestedObservers: MutationObserver[], pairedStrings: (string | null | undefined)[]): void;
}

/**
 * Each node has an associated list of registered observers.
 */
declare class RegisteredObservers {
    /**
     * The node for which this RegisteredObservers lists registered MutationObserver objects.
     */
    private _node;
    private _registeredObservers;
    /**
     * @param node - Node for which this instance holds RegisteredObserver instances.
     */
    constructor(node: Node);
    /**
     * Registers a given MutationObserver with the given options.
     *
     * @param observer - Observer to create a registration for
     * @param options  - Options for the registration
     */
    register(observer: MutationObserver, options: MutationObserverInit): void;
    /**
     * Removes the given transient registered observer.
     *
     * Transient registered observers never have a corresponding entry in the observer's list of
     * nodes. They are guaranteed to be present in the array, as MutationObserver#_transients and
     * RegisteredObservers#_registeredObservers are kept in sync.
     *
     * @param transientRegisteredObserver - The registered observer to remove
     */
    removeTransientRegisteredObserver(transientRegisteredObserver: RegisteredObserver): void;
    /**
     * Remove any registered observer on the associated node for which observer is the observer.
     *
     * As this only occurs for all nodes at once, it is the caller's responsibility to remove the
     * associated node from the observer's list of nodes.
     *
     * @param observer - Observer for which to remove the registration
     */
    removeForObserver(observer: MutationObserver): void;
    /**
     * Determines interested observers for the given record.
     *
     * @param type                - The type of mutation record to queue
     * @param target              - The target node
     * @param data                - The data for the mutation record
     * @param interestedObservers - Array of mutation observer objects to append to
     * @param pairedStrings       - Paired strings for the mutation observer objects
     */
    collectInterestedObservers(type: string, target: Node, data: MutationRecordInit, interestedObservers: MutationObserver[], pairedStrings: (string | null | undefined)[]): void;
    /**
     * Append transient registered observers for any registered observers whose options' subtree is
     * true.
     *
     * @param node - Node to append the transient registered observers to
     */
    appendTransientRegisteredObservers(node: Node): void;
    /**
     * Appends a transient registered observer for the given registered observer.
     *
     * @param source - The source registered observer
     */
    registerTransient(source: RegisteredObserver): void;
}

/**
 * Serializes root into a string using an XML serialization. Throws if the result would not be
 * well-formed XML.
 *
 * Non-standard: the dom-parsing spec does not provide a way to serialize arbitrary nodes while
 * enforcing well-formedness.
 *
 * @public
 *
 * @param root - The node to serialize
 *
 * @returns The XML resulting from serialization
 */
export declare function serializeToWellFormedString(root: Node): string;

/**
 * Interface StaticRange
 *
 * Updating live ranges in response to node tree mutations can be expensive. For every node tree
 * change, all affected Range objects need to be updated. Even if the application is uninterested in
 * some live ranges, it still has to pay the cost of keeping them up-to-date when a mutation occurs.
 *
 * A StaticRange object is a lightweight range that does not update when the node tree mutates. It
 * is therefore not subject to the same maintenance cost as live ranges.
 *
 * @public
 */
export declare class StaticRange implements AbstractRange {
    readonly startContainer: Node;
    readonly startOffset: number;
    readonly endContainer: Node;
    readonly endOffset: number;
    readonly collapsed: boolean;
    /**
     * The StaticRange(init) constructor, when invoked, must run these steps:
     *
     * @param init - Dictionary representing the properties to set on the StaticRange
     */
    constructor(init: StaticRangeInit);
}

declare interface StaticRangeInit {
    startContainer: Node;
    startOffset: number;
    endContainer: Node;
    endOffset: number;
}

/**
 * 3.11. Interface Text
 *
 * @public
 */
export declare class Text extends CharacterData {
    get nodeType(): number;
    get nodeName(): string;
    /**
     * Returns a new Text node whose data is data and node document is current global object’s
     * associated Document.
     *
     * @param data - The data for the new text node
     */
    constructor(data?: string);
    /**
     * Splits data at the given offset and returns the remainder as Text node.
     *
     * @param offset - The offset at which to split
     *
     * @returns a text node containing the second half of the split node's data
     */
    splitText(offset: number): Text;
    /**
     * (non-standard) Creates a copy of this, not including its children.
     *
     * @param document - The node document to associate with the copy
     *
     * @returns A shallow copy of this
     */
    _copy(document: Document): Text;
    /**
     * Returns the combined data of all direct Text node siblings.
     *
     * @returns the concatenation of the data of the contiguous Text nodes of this, in
     *          tree order.
     */
    get wholeText(): string;
}

/**
 * Append an attribute attribute to an element without the usual checks.
 *
 * @public
 *
 * @param attribute - The attribute to append
 * @param element   - The element to append attribute to
 */
export declare function unsafeAppendAttribute(attribute: Attr, element: Element): void;

/**
 * Create an Attr node without the usual validation of the given names.
 *
 * @public
 *
 * @param namespace - The namespace URI for the new node
 * @param prefix    - The prefix for the new node
 * @param localName - The local name for the new node
 * @param value     - The value for the new node
 * @param element   - The owner element for the new node
 *
 * @returns A new Attr node with the given values
 */
export declare function unsafeCreateAttribute(namespace: string | null, prefix: string | null, localName: string, value: string, ownerElement: Element | null): Attr;

/**
 * Create an Element node without the usual validation of the given names.
 *
 * @public
 *
 * @param document  - The node document for the new element
 * @param localName - The local name for the new element
 * @param namespace - The namespace URI for the new element, or null for the null namespace
 * @param prefix    - The prefix for the new element, or null for no prefix
 *
 * @returns The new element
 */
export declare function unsafeCreateElement(document: Document, localName: string, namespace: string | null, prefix?: string | null): Element;

/**
 * @public
 */
export declare class XMLDocument extends Document {
    /**
     * (non-standard) Creates a copy of this, not including its children.
     *
     * @param document - The node document to associate with the copy
     *
     * @returns A shallow copy of this
     */
    _copy(document: Document): XMLDocument;
}

/**
 * 2.2 The XMLSerializer interface
 *
 * @public
 */
export declare class XMLSerializer {
    /**
     * Constructs a new XMLSerializer object.
     */
    constructor();
    /**
     * Serializes root into a string using an XML serialization. Throws a TypeError exception if
     * root is not a Node.
     *
     * @param root - The node to serialize
     *
     * @returns The XML resulting from serialization
     */
    serializeToString(root: Node): string;
}

export { }
