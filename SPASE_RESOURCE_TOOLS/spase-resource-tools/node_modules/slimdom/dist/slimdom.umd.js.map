{"version":3,"file":"slimdom.umd.js","sources":["../src/mutation-observer/RegisteredObserver.ts","../src/mutation-observer/RegisteredObservers.ts","../src/mutation-observer/NotifyList.ts","../src/context/WeakRef.ts","../src/context/Context.ts","../src/util/NodeType.ts","../src/util/treeHelpers.ts","../src/util/cloneNode.ts","../src/util/errorHelpers.ts","../src/mixins.ts","../src/mutation-observer/MutationRecord.ts","../src/mutation-observer/queueMutationRecord.ts","../src/util/mutationAlgorithms.ts","../src/util/treeMutations.ts","../src/util/typeHelpers.ts","../src/Node.ts","../src/util/attrMutations.ts","../src/Attr.ts","../src/CharacterData.ts","../src/Text.ts","../src/CDATASection.ts","../src/Comment.ts","../src/DocumentType.ts","../src/util/namespaceHelpers.ts","../src/dom-parsing/NamespacePrefixMap.ts","../src/dom-parsing/serializationAlgorithms.ts","../src/Element.ts","../src/util/createElementNS.ts","../src/DOMImplementation.ts","../src/Document.ts","../src/DocumentFragment.ts","../src/ProcessingInstruction.ts","../src/Range.ts","../src/XMLDocument.ts","../src/index.ts","../src/mutation-observer/MutationObserver.ts","../src/dom-parsing/XMLSerializer.ts","../src/unsafe.ts"],"sourcesContent":["import { MutationObserverInit, default as MutationObserver } from './MutationObserver';\nimport { MutationRecordInit, default as MutationRecord } from './MutationRecord';\nimport Node from '../Node';\n\n/**\n * A registered observer consists of an observer (a MutationObserver object) and options (a\n * MutationObserverInit dictionary).\n *\n * A transient registered observer is a registered observer that also consists of a source (a\n * registered observer).\n *\n * Transient registered observers are used to track mutations within a given node’s descendants\n * after node has been removed so they do not get lost when subtree is set to true on node’s parent.\n */\nexport default class RegisteredObserver {\n\t/**\n\t * The observer that is registered.\n\t */\n\tpublic observer: MutationObserver;\n\n\t/**\n\t * The Node that is being observed by the given observer.\n\t */\n\tpublic node: Node;\n\n\t/**\n\t * The options for the registered observer.\n\t */\n\tpublic options: MutationObserverInit;\n\n\t/**\n\t * A transient observer is an observer that has a source which is an observer.\n\t */\n\tpublic source: RegisteredObserver | null = null;\n\n\t/**\n\t * @param observer - The observer being registered\n\t * @param node     - The node being observed\n\t * @param options  - Options for the registration\n\t * @param source   - If non-null, creates a transient registered observer for the given\n\t *                   registered observer\n\t */\n\tconstructor(\n\t\tobserver: MutationObserver,\n\t\tnode: Node,\n\t\toptions: MutationObserverInit,\n\t\tsource?: RegisteredObserver\n\t) {\n\t\tthis.observer = observer;\n\t\tthis.node = node;\n\t\tthis.options = options;\n\t\tthis.source = source || null;\n\t\tif (source) {\n\t\t\tobserver._transients.push(this);\n\t\t}\n\t}\n\n\t/**\n\t * Adds the given mutationRecord to the NotifyList of the registered MutationObserver. It only\n\t * adds the record when it's type isn't blocked by one of the flags of this registered\n\t * MutationObserver options (formally the MutationObserverInit object).\n\t *\n\t * @param type                - The type of mutation record to queue\n\t * @param target              - The target node\n\t * @param data                - The data for the mutation record\n\t * @param interestedObservers - Array of mutation observer objects to append to\n\t * @param pairedStrings       - Paired strings for the mutation observer objects\n\t */\n\tpublic collectInterestedObservers(\n\t\ttype: string,\n\t\ttarget: Node,\n\t\tdata: MutationRecordInit,\n\t\tinterestedObservers: MutationObserver[],\n\t\tpairedStrings: (string | null | undefined)[]\n\t) {\n\t\t// (continued from RegisteredObservers#queueMutationRecord)\n\n\t\t// 3.1. Let options be registered's options.\n\t\t// 3.2. If none of the following are true\n\t\t// node is not target and options[\"subtree\"] is false\n\t\tif (this.node !== target && !this.options.subtree) {\n\t\t\treturn;\n\t\t}\n\n\t\t// type is \"attributes\" and options[\"attributes\"] is not true\n\t\tif (type === 'attributes' && !this.options.attributes) {\n\t\t\treturn;\n\t\t}\n\n\t\t// type is \"attributes\", options[\"attributeFilter\"] exists, and options[\"attributeFilter\"]\n\t\t// does not contain name or namespace is non-null\n\t\t// (attributeFilter not implemented)\n\n\t\t// type is \"characterData\" and options[\"characterData\"] is not true\n\t\tif (type === 'characterData' && !this.options.characterData) {\n\t\t\treturn;\n\t\t}\n\n\t\t// type is \"childList\" and options[\"childList\"] is false\n\t\tif (type === 'childList' && !this.options.childList) {\n\t\t\treturn;\n\t\t}\n\n\t\t// then:\n\n\t\t// 3.2.1. Let mo be registered's observer.\n\t\t// 3.2.2. If interestedObservers[mo] does not exist, then set interestedObservers[mo] to\n\t\t// null\n\t\tlet index = interestedObservers.indexOf(this.observer);\n\t\tif (index < 0) {\n\t\t\tindex = interestedObservers.length;\n\t\t\tinterestedObservers.push(this.observer);\n\t\t\tpairedStrings.push(undefined);\n\t\t}\n\n\t\t// 3.2.3. If either type is \"attributes\" and options[\"attributeOldValue\"] is true, or type\n\t\t// is \"characterData\" and options[\"characterDataOldValue\"] is true, then set\n\t\t// interestedObservers[mo] to oldValue.\n\t\tif (\n\t\t\t(type === 'attributes' && this.options.attributeOldValue) ||\n\t\t\t(type === 'characterData' && this.options.characterDataOldValue)\n\t\t) {\n\t\t\tpairedStrings[index] = data.oldValue;\n\t\t}\n\t}\n}\n","import { MutationObserverInit, default as MutationObserver } from './MutationObserver';\nimport { MutationRecordInit } from './MutationRecord';\nimport RegisteredObserver from './RegisteredObserver';\nimport Node from '../Node';\n\n/**\n * Each node has an associated list of registered observers.\n */\nexport default class RegisteredObservers {\n\t/**\n\t * The node for which this RegisteredObservers lists registered MutationObserver objects.\n\t */\n\tprivate _node: Node;\n\n\tprivate _registeredObservers: RegisteredObserver[] = [];\n\n\t/**\n\t * @param node - Node for which this instance holds RegisteredObserver instances.\n\t */\n\tconstructor(node: Node) {\n\t\tthis._node = node;\n\t}\n\n\t/**\n\t * Registers a given MutationObserver with the given options.\n\t *\n\t * @param observer - Observer to create a registration for\n\t * @param options  - Options for the registration\n\t */\n\tpublic register(observer: MutationObserver, options: MutationObserverInit) {\n\t\t// (continuing from MutationObserver#observe)\n\t\t// 7. For each registered registered of target’s registered observer list, if registered's\n\t\t// observer is this:\n\t\tconst registeredObservers = this._registeredObservers;\n\t\tlet hasRegisteredObserverForObserver = false;\n\t\tregisteredObservers.forEach((registered) => {\n\t\t\tif (registered.observer !== observer) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\thasRegisteredObserverForObserver = true;\n\n\t\t\t// 7.1. For each node of this's node list, remove all transient registered\n\t\t\t// observers whose source is registered from node's registered observer list.\n\t\t\tremoveTransientRegisteredObserversForSource(registered);\n\n\t\t\t// 7.2. Set registered’s options to options.\n\t\t\tregistered.options = options;\n\t\t});\n\n\t\t// 8. Otherwise:\n\t\tif (!hasRegisteredObserverForObserver) {\n\t\t\t// 8.1. Append a new registered observer whose observer is this and\n\t\t\t// options is options to target's registered observer list.\n\t\t\tthis._registeredObservers.push(new RegisteredObserver(observer, this._node, options));\n\t\t\t// 8.2. Append target to this's node list.\n\t\t\tobserver._nodes.push(this._node);\n\t\t}\n\t}\n\n\t/**\n\t * Removes the given transient registered observer.\n\t *\n\t * Transient registered observers never have a corresponding entry in the observer's list of\n\t * nodes. They are guaranteed to be present in the array, as MutationObserver#_transients and\n\t * RegisteredObservers#_registeredObservers are kept in sync.\n\t *\n\t * @param transientRegisteredObserver - The registered observer to remove\n\t */\n\tpublic removeTransientRegisteredObserver(\n\t\ttransientRegisteredObserver: RegisteredObserver\n\t): void {\n\t\tthis._registeredObservers.splice(\n\t\t\tthis._registeredObservers.indexOf(transientRegisteredObserver),\n\t\t\t1\n\t\t);\n\t}\n\n\t/**\n\t * Remove any registered observer on the associated node for which observer is the observer.\n\t *\n\t * As this only occurs for all nodes at once, it is the caller's responsibility to remove the\n\t * associated node from the observer's list of nodes.\n\t *\n\t * @param observer - Observer for which to remove the registration\n\t */\n\tpublic removeForObserver(observer: MutationObserver): void {\n\t\t// Filter the array in-place\n\t\tlet write = 0;\n\t\tfor (let read = 0, l = this._registeredObservers.length; read < l; ++read) {\n\t\t\tconst registered = this._registeredObservers[read];\n\t\t\tif (registered.observer === observer) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (read !== write) {\n\t\t\t\tthis._registeredObservers[write] = registered;\n\t\t\t}\n\t\t\t++write;\n\t\t}\n\t\tthis._registeredObservers.length = write;\n\t}\n\n\t/**\n\t * Determines interested observers for the given record.\n\t *\n\t * @param type                - The type of mutation record to queue\n\t * @param target              - The target node\n\t * @param data                - The data for the mutation record\n\t * @param interestedObservers - Array of mutation observer objects to append to\n\t * @param pairedStrings       - Paired strings for the mutation observer objects\n\t */\n\tpublic collectInterestedObservers(\n\t\ttype: string,\n\t\ttarget: Node,\n\t\tdata: MutationRecordInit,\n\t\tinterestedObservers: MutationObserver[],\n\t\tpairedStrings: (string | null | undefined)[]\n\t) {\n\t\t// (continuing from queueMutationRecord)\n\t\t// 3. ...and then for each registered of node's registered observer list:\n\t\tthis._registeredObservers.forEach((registeredObserver) => {\n\t\t\tregisteredObserver.collectInterestedObservers(\n\t\t\t\ttype,\n\t\t\t\ttarget,\n\t\t\t\tdata,\n\t\t\t\tinterestedObservers,\n\t\t\t\tpairedStrings\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * Append transient registered observers for any registered observers whose options' subtree is\n\t * true.\n\t *\n\t * @param node - Node to append the transient registered observers to\n\t */\n\tpublic appendTransientRegisteredObservers(node: Node): void {\n\t\tthis._registeredObservers.forEach((registeredObserver) => {\n\t\t\tif (registeredObserver.options.subtree) {\n\t\t\t\tnode._registeredObservers.registerTransient(registeredObserver);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Appends a transient registered observer for the given registered observer.\n\t *\n\t * @param source - The source registered observer\n\t */\n\tpublic registerTransient(source: RegisteredObserver): void {\n\t\tthis._registeredObservers.push(\n\t\t\tnew RegisteredObserver(source.observer, this._node, source.options, source)\n\t\t);\n\t\t// Note that node is not added to the transient observer's observer's list of nodes.\n\t}\n}\n\n/**\n * Removes all transient registered observers whose observer is observer.\n *\n * @param observer - The mutation observer object to remove transient registered observers for\n */\nexport function removeTransientRegisteredObserversForObserver(observer: MutationObserver): void {\n\tobserver._transients.forEach((transientRegisteredObserver) => {\n\t\ttransientRegisteredObserver.node._registeredObservers.removeTransientRegisteredObserver(\n\t\t\ttransientRegisteredObserver\n\t\t);\n\t});\n\tobserver._transients.length = 0;\n}\n\n/**\n * Removes all transient registered observer whose source is source.\n *\n * @param source - The registered observer to remove transient registered observers for\n */\nexport function removeTransientRegisteredObserversForSource(source: RegisteredObserver): void {\n\tfor (let i = source.observer._transients.length - 1; i >= 0; --i) {\n\t\tconst transientRegisteredObserver = source.observer._transients[i];\n\t\tif (transientRegisteredObserver.source !== source) {\n\t\t\treturn;\n\t\t}\n\n\t\ttransientRegisteredObserver.node._registeredObservers.removeTransientRegisteredObserver(\n\t\t\ttransientRegisteredObserver\n\t\t);\n\t\tsource.observer._transients.splice(i, 1);\n\t}\n}\n","import { default as MutationObserver } from './MutationObserver';\nimport MutationRecord from './MutationRecord';\nimport { removeTransientRegisteredObserversForObserver } from './RegisteredObservers';\n\ntype AnyCallback = (...args: any[]) => void;\ndeclare const queueMicrotask: undefined | ((callback: AnyCallback) => void);\n\n/* istanbul ignore next */\nfunction queueMicrotaskWithAppropriateApi(\n\tcallback: AnyCallback,\n\tthisArg: NotifySet,\n\t...args: any[]\n): void {\n\tif (typeof queueMicrotask === 'function') {\n\t\tqueueMicrotask(() => callback.apply(thisArg, args));\n\t\treturn;\n\t}\n\n\t// Fall back to Promise.then callbacks - these run as microtasks, but handle errors differently\n\tPromise.resolve().then(() => callback.apply(thisArg, args));\n}\n\n/**\n * Tracks MutationObserver instances which have a non-empty record queue and schedules their\n * callbacks to be called.\n */\nexport default class NotifySet {\n\tprivate _notifySet: Set<MutationObserver> = new Set();\n\tprivate _mutationObserverMicrotaskQueued: boolean = false;\n\n\t/**\n\t * Appends a given MutationRecord to the recordQueue of the given MutationObserver and schedules\n\t * it for reporting.\n\t *\n\t * @param observer - The observer for which to enqueue the record\n\t * @param record   - The record to enqueue\n\t */\n\tappendRecord(observer: MutationObserver, record: MutationRecord) {\n\t\tobserver._recordQueue.push(record);\n\t\tthis._notifySet.add(observer);\n\t}\n\n\t/**\n\t * To queue a mutation observer microtask, run these steps:\n\t */\n\tpublic queueMutationObserverMicrotask() {\n\t\t// 1. If the surrounding agent's mutation observer microtask queued is true, then return.\n\t\tif (this._mutationObserverMicrotaskQueued) {\n\t\t\treturn;\n\t\t}\n\n\t\t// 2. Set the surrounding agent's mutation observer microtask queued to true.\n\t\tthis._mutationObserverMicrotaskQueued = true;\n\n\t\t// 3. Queue a microtask to notify mutation observers.\n\t\tqueueMicrotaskWithAppropriateApi(() => {\n\t\t\tthis._notifyMutationObservers();\n\t\t}, this);\n\t}\n\n\t/**\n\t * To notify mutation observers, run these steps:\n\t */\n\tprivate _notifyMutationObservers() {\n\t\t// 1. Set the surrounding agent's mutation observer microtask queued to false.\n\t\tthis._mutationObserverMicrotaskQueued = false;\n\n\t\t// 2. Let notifySet be a clone of the surrounding agent's mutation observers\n\t\tconst notifySet = Array.from(this._notifySet);\n\t\t// Clear the notify set - for efficiency this set only tracks observers that have a\n\t\t// non-empty queue\n\t\tthis._notifySet.clear();\n\n\t\t// 3. Let signalSet be a clone of the surrounding agent's signal slots.\n\t\t// 4. Empty the surrounding agent's signal slots.\n\t\t// (shadow dom not implemented)\n\n\t\t// 5. For each mo of notifySet:\n\t\t// [HTML]\n\t\tnotifySet.forEach((mo) => {\n\t\t\tqueueMicrotaskWithAppropriateApi(\n\t\t\t\t(mo: MutationObserver) => {\n\t\t\t\t\t// 5.1. Let records be a clone of mo’s record queue.\n\t\t\t\t\t// 5.2. Empty mo’s record queue.\n\t\t\t\t\tconst records = mo.takeRecords();\n\n\t\t\t\t\t// 5.3. For each node of mo's node list, remove all transient registered\n\t\t\t\t\t// observers whose observer is mo from node's registered observer list.\n\t\t\t\t\tremoveTransientRegisteredObserversForObserver(mo);\n\n\t\t\t\t\t// 5.4. If records is not empty, then invoke mo’s callback with « records, mo »,\n\t\t\t\t\t// and mo. If this throws an exception, catch it, and report the exception.\n\t\t\t\t\t// (A try/catch is not necessary here, as this microtask does nothing else and\n\t\t\t\t\t// letting the exception through will likely cause the environment to report it)\n\t\t\t\t\tif (records.length > 0) {\n\t\t\t\t\t\tmo._callback(records, mo);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tthis,\n\t\t\t\tmo\n\t\t\t);\n\t\t});\n\n\t\t// 6. For each slot of signalSet, fire an event named slotchange, with its bubbles attribute\n\t\t// set to true, at slot.\n\t\t// (shadow dom not implemented)\n\t}\n}\n","// TODO: remove when interface is included in dom.d.ts typings\nexport interface WeakRef<T> {\n\tderef(): T | undefined;\n}\ninterface WeakRefConstructor<T> {\n\tnew (target: T): WeakRef<T>;\n}\ndeclare var WeakRef: WeakRefConstructor<any>;\n\nclass FakeWeakRef<T> implements WeakRef<T> {\n\tprivate _target: T;\n\n\tconstructor(target: T) {\n\t\tthis._target = target;\n\t}\n\n\tpublic deref(): T {\n\t\treturn this._target;\n\t}\n}\n\nexport function createWeakRef<T>(target: T): WeakRef<T> {\n\tif (typeof WeakRef === 'function') {\n\t\treturn new WeakRef(target);\n\t}\n\n\treturn new FakeWeakRef(target);\n}\n","import Attr from '../Attr';\nimport CDATASection from '../CDATASection';\nimport Comment from '../Comment';\nimport Document from '../Document';\nimport DocumentFragment from '../DocumentFragment';\nimport DocumentType from '../DocumentType';\nimport DOMImplementation from '../DOMImplementation';\nimport Element from '../Element';\nimport Node from '../Node';\nimport ProcessingInstruction from '../ProcessingInstruction';\nimport Range from '../Range';\nimport Text from '../Text';\nimport XMLDocument from '../XMLDocument';\n\nimport NotifySet from '../mutation-observer/NotifyList';\n\nimport { createWeakRef, WeakRef } from './WeakRef';\n\nexport type AttrConstructor = new (\n\tnamespace: string | null,\n\tprefix: string | null,\n\tlocalName: string,\n\tvalue: string,\n\telement: Element | null\n) => Attr;\nexport type CDATASectionConstructor = new (data: string) => CDATASection;\nexport type CommentConstructor = new (data: string) => Comment;\nexport type DocumentConstructor = new () => Document;\nexport type DocumentFragmentConstructor = new () => DocumentFragment;\nexport type DocumentTypeConstructor = new (\n\tname: string,\n\tpublicId?: string,\n\tsystemId?: string\n) => DocumentType;\nexport type DOMImplementationConstructor = new (document: Document) => DOMImplementation;\nexport type ElementConstructor = new (\n\tnamespace: string | null,\n\tprefix: string | null,\n\tlocalName: string\n) => Element;\nexport type ProcessingInstructionConstructor = new (\n\ttarget: string,\n\tdata: string\n) => ProcessingInstruction;\nexport type RangeConstructor = new () => Range;\nexport type TextConstructor = new (data: string) => Text;\nexport type XMLDocumentConstructor = new () => XMLDocument;\n\nexport interface Context {\n\tdocument: Document;\n\n\t_notifySet: NotifySet;\n\n\tAttr: AttrConstructor;\n\tCDATASection: CDATASectionConstructor;\n\tComment: CommentConstructor;\n\tDocument: DocumentConstructor;\n\tDocumentFragment: DocumentFragmentConstructor;\n\tDocumentType: DocumentTypeConstructor;\n\tDOMImplementation: DOMImplementationConstructor;\n\tElement: ElementConstructor;\n\tProcessingInstruction: ProcessingInstructionConstructor;\n\tRange: RangeConstructor;\n\tText: TextConstructor;\n\tXMLDocument: XMLDocumentConstructor;\n\n\tforEachRange(cb: (range: Range) => void): void;\n\taddRange(range: Range): void;\n\tremoveRange(range: Range): void;\n}\n\n/**\n * The DefaultContext is comparable to the global object in that it tracks its associated document.\n * It also serves as a way to inject the constructors for the constructable types, avoiding cyclic\n * dependencies.\n */\nexport class DefaultContext implements Context {\n\tpublic document!: Document;\n\n\t/**\n\t * The NotifyList instance is shared between all MutationObserver objects. It holds references\n\t * to all MutationObserver instances that have collected records, and is responsible for\n\t * invoking their callbacks when control returns to the event loop.\n\t */\n\tpublic _notifySet: NotifySet = new NotifySet();\n\n\tpublic Attr!: AttrConstructor;\n\tpublic CDATASection!: CDATASectionConstructor;\n\tpublic Comment!: CommentConstructor;\n\tpublic Document!: DocumentConstructor;\n\tpublic DocumentFragment!: DocumentFragmentConstructor;\n\tpublic DocumentType!: DocumentTypeConstructor;\n\tpublic DOMImplementation!: DOMImplementationConstructor;\n\tpublic Element!: ElementConstructor;\n\tpublic ProcessingInstruction!: ProcessingInstructionConstructor;\n\tpublic Range!: RangeConstructor;\n\tpublic Text!: TextConstructor;\n\tpublic XMLDocument!: XMLDocumentConstructor;\n\n\tprivate _ranges: WeakRef<Range>[] = [];\n\n\tpublic forEachRange(cb: (range: Range) => void): void {\n\t\tlet numRanges = this._ranges.length;\n\t\tfor (let i = numRanges - 1; i >= 0; --i) {\n\t\t\tconst r = this._ranges[i].deref();\n\t\t\tif (r === undefined) {\n\t\t\t\t// Weak ref lost, remove\n\t\t\t\tthis._ranges[i] = this._ranges[numRanges - 1];\n\t\t\t\tthis._ranges.pop();\n\t\t\t\tnumRanges -= 1;\n\t\t\t} else {\n\t\t\t\tcb(r);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic addRange(range: Range): void {\n\t\tthis._ranges.push(createWeakRef(range));\n\t}\n\n\tpublic removeRange(range: Range): void {\n\t\tlet numRanges = this._ranges.length;\n\t\tfor (let i = numRanges - 1; i >= 0; --i) {\n\t\t\tconst r = this._ranges[i].deref();\n\t\t\tif (r === undefined || r === range) {\n\t\t\t\tthis._ranges[i] = this._ranges[numRanges - 1];\n\t\t\t\tthis._ranges.pop();\n\t\t\t\tnumRanges -= 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// TODO: make it possible to create multiple contexts by binding constructors to each instance\nexport const defaultContext = new DefaultContext();\n\nexport function getContext(instance: Node | Range): Context {\n\treturn defaultContext;\n}\n","import Node from '../Node';\n\nexport const enum NodeType {\n\tELEMENT_NODE = 1,\n\tATTRIBUTE_NODE = 2,\n\tTEXT_NODE = 3,\n\tCDATA_SECTION_NODE = 4,\n\tENTITY_REFERENCE_NODE = 5, // legacy\n\tENTITY_NODE = 6, // legacy\n\tPROCESSING_INSTRUCTION_NODE = 7,\n\tCOMMENT_NODE = 8,\n\tDOCUMENT_NODE = 9,\n\tDOCUMENT_TYPE_NODE = 10,\n\tDOCUMENT_FRAGMENT_NODE = 11,\n\tNOTATION_NODE = 12, // legacy\n}\n\n/**\n * Checks whether the given node's nodeType is one of the specified values\n *\n * @param node  - The node to test\n * @param types - Possible nodeTypes for node\n *\n * @returns Whether node.nodeType is one of the specified values\n */\nexport function isNodeOfType(node: Node, ...types: NodeType[]): boolean {\n\treturn types.some((t) => node.nodeType === t);\n}\n","import CharacterData from '../CharacterData';\nimport Document from '../Document';\nimport Element from '../Element';\nimport Node from '../Node';\nimport { NodeType, isNodeOfType } from './NodeType';\n\n/**\n * 3.2. Node Tree: to determine the length of a node, switch on node:\n *\n * @param node - The node to determine the length of\n *\n * @returns The length of the node\n */\nexport function determineLengthOfNode(node: Node): number {\n\tswitch (node.nodeType) {\n\t\t// DocumentType: Zero.\n\t\t// (not necessary, as doctypes never have children)\n\n\t\t// Text, ProcessingInstruction, Comment: The number of code units in its data.\n\t\tcase NodeType.TEXT_NODE:\n\t\tcase NodeType.PROCESSING_INSTRUCTION_NODE:\n\t\tcase NodeType.COMMENT_NODE:\n\t\t\treturn (node as CharacterData).data.length;\n\n\t\t// Any other node: Its number of children.\n\t\tdefault:\n\t\t\treturn node.childNodes.length;\n\t}\n}\n\n/**\n * Get inclusive ancestors of the given node.\n *\n * @param node - Node to get inclusive ancestors of\n *\n * @returns Node's inclusive ancestors, in tree order\n */\nexport function getInclusiveAncestors(node: Node): Node[] {\n\tlet ancestor: Node | null = node;\n\tlet ancestors: Node[] = [];\n\twhile (ancestor) {\n\t\tancestors.unshift(ancestor);\n\t\tancestor = ancestor.parentNode;\n\t}\n\n\treturn ancestors;\n}\n\n/**\n * Get the node document associated with the given node.\n *\n * @param node - The node to get the node document for\n *\n * @returns The node document for node\n */\nexport function getNodeDocument(node: Node): Document {\n\tif (isNodeOfType(node, NodeType.DOCUMENT_NODE)) {\n\t\treturn node as Document;\n\t}\n\n\treturn node.ownerDocument!;\n}\n\n/**\n * Determine the index of the given node among its siblings.\n *\n * @param node - Node to determine the index of\n *\n * @returns The index of node in its parent's children\n */\nexport function getNodeIndex(node: Node): number {\n\treturn node.parentNode!.childNodes.indexOf(node);\n}\n\n/**\n * The root of an object is itself, if its parent is null, or else it is the root of its parent.\n *\n * @param node - Node to get the root of\n *\n * @returns The root of node\n */\nexport function getRootOfNode(node: Node): Node {\n\twhile (node.parentNode) {\n\t\tnode = node.parentNode;\n\t}\n\n\treturn node;\n}\n\n/**\n * Invokes callback on each inclusive descendant of node, in tree order\n *\n * @param node     - Root of the subtree to process\n * @param callback - Callback to invoke for each descendant, should not modify node's position in\n *                   the tree\n */\nexport function forEachInclusiveDescendant(node: Node, callback: (node: Node) => void): void {\n\tcallback(node);\n\tfor (let child = node.firstChild; child; child = child.nextSibling) {\n\t\tforEachInclusiveDescendant(child, callback);\n\t}\n}\n\n/**\n * The list of elements with qualified name qualifiedName for a node root is the HTMLCollection\n * returned by the following algorithm:\n *\n * (this implementation returns a non-live array instead)\n *\n * @param qualifiedName - The qualifiedName of elements to return, or '*' to return all elements\n * @param root          - The root of the subtree from which to collect matching descendants\n */\nexport function getListOfElementsWithQualifiedName(qualifiedName: string, root: Node): Element[] {\n\tconst elements: Element[] = [];\n\tforEachInclusiveDescendant(root, (node) => {\n\t\t// Only matches descendant elements\n\t\tif (node === root || node.nodeType !== NodeType.ELEMENT_NODE) {\n\t\t\treturn;\n\t\t}\n\t\tconst element = node as Element;\n\n\t\tif (\n\t\t\t// 1. If qualifiedName is \"*\" (U+002A), return a HTMLCollection rooted at root, whose\n\t\t\t// filter matches only descendant elements.\n\t\t\tqualifiedName === '\\u002a' ||\n\t\t\t// 2. Otherwise, if root’s node document is an HTML document, return a HTMLCollection\n\t\t\t// rooted at root, whose filter matches the following descendant elements:\n\t\t\t//    - Whose namespace is the HTML namespace and whose qualified name is qualifiedName,\n\t\t\t//      in ASCII lowercase.\n\t\t\t//    - Whose namespace is not the HTML namespace and whose qualified name is\n\t\t\t//      qualifiedName.\n\t\t\t// (html documents not implemented)\n\n\t\t\t// 3. Otherwise, return a HTMLCollection rooted at root, whose filter matches descendant\n\t\t\t// elements whose qualified name is qualifiedName.\n\t\t\telement.nodeName === qualifiedName\n\t\t) {\n\t\t\telements.push(element);\n\t\t}\n\t});\n\n\treturn elements;\n}\n\n/**\n * The list of elements with namespace namespace and local name localName for a node root is the\n * HTMLCollection returned by the following algorithm:\n *\n * (this implementation returns a non-live array instead)\n *\n * @param namespace - The namespace of the elements to return, or '*' to match any namespace\n * @param localName - The local name of the elements to return, or '*' to match any local name\n * @param root      - The root of the subtree from which to collect matching descendants\n */\nexport function getListOfElementsWithNamespaceAndLocalName(\n\tnamespace: string | null,\n\tlocalName: string,\n\troot: Node\n): Element[] {\n\t// 1. If namespace is the empty string, set it to null.\n\tif (namespace === '') {\n\t\tnamespace = null;\n\t}\n\n\tconst elements: Element[] = [];\n\tforEachInclusiveDescendant(root, (node) => {\n\t\t// Only matches descendant elements\n\t\tif (node === root || node.nodeType !== NodeType.ELEMENT_NODE) {\n\t\t\treturn;\n\t\t}\n\t\tconst element = node as Element;\n\n\t\tif (\n\t\t\t// 2. If both namespace and localName are \"*\" (U+002A), return a HTMLCollection\n\t\t\t//    rooted at root, whose filter matches descendant elements.\n\t\t\t// 3. Otherwise, if namespace is \"*\" (U+002A), return a HTMLCollection rooted at\n\t\t\t//    root, whose filter matches descendant elements whose local name is localName.\n\t\t\t// 4. Otherwise, if localName is \"*\" (U+002A), return a HTMLCollection rooted at\n\t\t\t//    root, whose filter matches descendant elements whose namespace is namespace.\n\t\t\t// 5. Otherwise, return a HTMLCollection rooted at root, whose filter matches\n\t\t\t//    descendant elements whose namespace is namespace and local name is localName.\n\t\t\t(namespace === '\\u002a' || element.namespaceURI === namespace) &&\n\t\t\t(localName === '\\u002a' || element.localName === localName)\n\t\t) {\n\t\t\telements.push(element);\n\t\t}\n\t});\n\n\treturn elements;\n}\n","import Document from '../Document';\nimport Node from '../Node';\n\nimport { getNodeDocument } from './treeHelpers';\n\n// 3.4. Interface Node\n\n/**\n * To clone a node, with an optional document and clone children flag, run these steps:\n *\n * @param node          - The node to clone\n * @param cloneChildren - Whether to also clone node's descendants\n * @param document      - The document used to create the copy\n */\nexport default function cloneNode<TNode extends Node>(\n\tnode: TNode,\n\tcloneChildren: boolean,\n\tdocument?: Document\n): TNode {\n\t// 1. If document is not given, let document be node’s node document.\n\tif (!document) {\n\t\tdocument = getNodeDocument(node);\n\t}\n\n\t// 2. If node is an element, then:\n\t// 2.1. Let copy be the result of creating an element, given document, node’s local name, node’s\n\t// namespace, node’s namespace prefix, and node’s is value, with the synchronous custom elements\n\t// flag unset.\n\t// 2.2. For each attribute in node’s attribute list:\n\t// 2.2.1. Let copyAttribute be a clone of attribute.\n\t// 2.2.2. Append copyAttribute to copy.\n\t// 3. Otherwise, let copy be a node that implements the same interfaces as node, and fulfills\n\t// these additional requirements, switching on node:\n\t// Document: Set copy’s encoding, content type, URL, origin, type, and mode, to those of node.\n\t// DocumentType: Set copy’s name, public ID, and system ID, to those of node.\n\t// Attr: Set copy’s namespace, namespace prefix, local name, and value, to those of node.\n\t// Text, Comment: Set copy’s data, to that of node.\n\t// ProcessingInstruction: Set copy’s target and data to those of node.\n\t// Any other node: —\n\t// 4. Set copy’s node document and document to copy, if copy is a document, and set copy’s node\n\t// document to document otherwise.\n\t// (all handled by _copy method)\n\tlet copy = node._copy(document) as TNode;\n\n\t// 5. Run any cloning steps defined for node in other applicable specifications and pass copy,\n\t// node, document and the clone children flag if set, as parameters.\n\t// (cloning steps not implemented)\n\n\t// 6. If the clone children flag is set, clone all the children of node and append them to copy,\n\t// with document as specified and the clone children flag being set.\n\tif (cloneChildren) {\n\t\tfor (let child = node.firstChild; child; child = child.nextSibling) {\n\t\t\tcopy.appendChild(cloneNode(child, true, document));\n\t\t}\n\t}\n\n\t// 7. Return copy.\n\treturn copy;\n}\n","export function expectArity(args: IArguments, minArity: number): void {\n\t// According to WebIDL overload resolution semantics, only a lower bound applies to the number\n\t// of arguments provided\n\tif (args.length < minArity) {\n\t\tthrow new TypeError(`Function should be called with at least ${minArity} arguments`);\n\t}\n}\n\nexport function expectObject<T>(value: T, Constructor: Function): void {\n\tif (!(value instanceof Constructor)) {\n\t\tthrow new TypeError(`Value should be an instance of ${Constructor.name}`);\n\t}\n}\n\nconst codeByName: Record<string, number> = {\n\tIndexSizeError: 1,\n\tHierarchyRequestError: 3,\n\tWrongDocumentError: 4,\n\tInvalidCharacterError: 5,\n\tNotFoundError: 8,\n\tNotSupportedError: 9,\n\tInUseAttributeError: 10,\n\tInvalidStateError: 11,\n\tNamespaceError: 14,\n\tInvalidNodeTypeError: 24,\n};\n\n/**\n * Exception type used for DOM errors\n *\n * @public\n */\nexport class DOMException extends Error {\n\tpublic readonly name: string;\n\tpublic readonly message: string;\n\tpublic readonly code: number;\n\tpublic readonly stack: string | undefined;\n\n\tconstructor(message: string = '', name: string = 'Error') {\n\t\tsuper(message);\n\n\t\tthis.message = message;\n\t\tthis.name = name;\n\t\tthis.code = codeByName[name] || 0;\n\t\tthis.stack = new Error(message).stack;\n\t}\n}\n\nfunction createDOMException(name: string, message: string): Error {\n\treturn new DOMException(`${name}: ${message}`, name);\n}\n\nexport function throwHierarchyRequestError(message: string): never {\n\tthrow createDOMException('HierarchyRequestError', message);\n}\n\nexport function throwIndexSizeError(message: string): never {\n\tthrow createDOMException('IndexSizeError', message);\n}\n\nexport function throwInUseAttributeError(message: string): never {\n\tthrow createDOMException('InUseAttributeError', message);\n}\n\nexport function throwInvalidCharacterError(message: string): never {\n\tthrow createDOMException('InvalidCharacterError', message);\n}\n\nexport function throwInvalidNodeTypeError(message: string): never {\n\tthrow createDOMException('InvalidNodeTypeError', message);\n}\n\nexport function throwInvalidStateError(message: string): never {\n\tthrow createDOMException('InvalidStateError', message);\n}\n\nexport function throwNamespaceError(message: string): never {\n\tthrow createDOMException('NamespaceError', message);\n}\n\nexport function throwNotFoundError(message: string): never {\n\tthrow createDOMException('NotFoundError', message);\n}\n\nexport function throwNotSupportedError(message: string): never {\n\tthrow createDOMException('NotSupportedError', message);\n}\n\nexport function throwWrongDocumentError(message: string): never {\n\tthrow createDOMException('WrongDocumentError', message);\n}\n","import CharacterData from './CharacterData';\nimport Document from './Document';\nimport DocumentFragment from './DocumentFragment';\nimport Element from './Element';\nimport Node from './Node';\n\nimport { NodeType, isNodeOfType } from './util/NodeType';\n\n/**\n * 3.2.4. Mixin NonElementParentNode\n */\nexport interface NonElementParentNode {}\n// Document implements NonElementParentNode;\n// DocumentFragment implements NonElementParentNode;\n\n/**\n * 3.2.6. Mixin ParentNode\n */\nexport interface ParentNode {\n\treadonly children: Element[];\n\n\tfirstElementChild: Element | null;\n\tlastElementChild: Element | null;\n\tchildElementCount: number;\n\n\tprepend(...nodes: (Node | string)[]): void;\n\tappend(...nodes: (Node | string)[]): void;\n\treplaceChildren(...nodes: (Node | string)[]): void;\n}\n// Document implements ParentNode;\n// DocumentFragment implements ParentNode;\n// Element implements ParentNode;\n\nexport function asParentNode(node: Node): ParentNode | null {\n\t// This is only called from treeMutations.js, where node can never be anything other than these\n\t/* istanbul ignore else */\n\tif (\n\t\tisNodeOfType(\n\t\t\tnode,\n\t\t\tNodeType.ELEMENT_NODE,\n\t\t\tNodeType.DOCUMENT_NODE,\n\t\t\tNodeType.DOCUMENT_FRAGMENT_NODE\n\t\t)\n\t) {\n\t\treturn node as Element | Document | DocumentFragment;\n\t}\n\n\t/* istanbul ignore next */\n\treturn null;\n}\n\n/**\n * Returns the element children of node.\n *\n * (Non-standard) According to the spec, the children getter should return a live HTMLCollection.\n * This implementation returns a static array instead.\n *\n * @param node - The node to get element children of\n *\n * @returns The\n */\nexport function getChildren(node: ParentNode): Element[] {\n\tconst elements: Element[] = [];\n\tfor (let child = node.firstElementChild; child; child = child.nextElementSibling) {\n\t\telements.push(child);\n\t}\n\treturn elements;\n}\n\n/**\n * 3.2.7. Mixin NonDocumentTypeChildNode\n */\nexport interface NonDocumentTypeChildNode {\n\treadonly previousElementSibling: Element | null;\n\treadonly nextElementSibling: Element | null;\n}\n// Element implements NonDocumentTypeChildNode;\n// CharacterData implements NonDocumentTypeChildNode;\n\nexport function asNonDocumentTypeChildNode(node: Node): NonDocumentTypeChildNode | null {\n\tif (\n\t\tisNodeOfType(\n\t\t\tnode,\n\t\t\tNodeType.ELEMENT_NODE,\n\t\t\tNodeType.COMMENT_NODE,\n\t\t\tNodeType.PROCESSING_INSTRUCTION_NODE,\n\t\t\tNodeType.TEXT_NODE,\n\t\t\tNodeType.CDATA_SECTION_NODE\n\t\t)\n\t) {\n\t\treturn node as Element | CharacterData;\n\t}\n\n\treturn null;\n}\n\nexport function getPreviousElementSibling(node: Node): Element | null {\n\tfor (let sibling = node.previousSibling; sibling; sibling = sibling.previousSibling) {\n\t\tif (isNodeOfType(sibling, NodeType.ELEMENT_NODE)) {\n\t\t\treturn sibling as Element;\n\t\t}\n\t}\n\n\treturn null;\n}\n\nexport function getNextElementSibling(node: Node): Element | null {\n\tfor (let sibling = node.nextSibling; sibling; sibling = sibling.nextSibling) {\n\t\tif (isNodeOfType(sibling, NodeType.ELEMENT_NODE)) {\n\t\t\treturn sibling as Element;\n\t\t}\n\t}\n\n\treturn null;\n}\n\n/**\n * 3.2.8. Mixin ChildNode\n */\nexport interface ChildNode {\n\tbefore(...nodes: (Node | string)[]): void;\n\tafter(...nodes: (Node | string)[]): void;\n\treplaceWith(...nodes: (Node | string)[]): void;\n\tremove(): void;\n}\n// DocumentType implements ChildNode;\n// Element implements ChildNode;\n// CharacterData implements ChildNode;\n","import Node from '../Node';\n\nexport interface MutationRecordInit {\n\tname?: string;\n\tnamespace?: string | null;\n\toldValue?: string | null;\n\taddedNodes?: Node[];\n\tremovedNodes?: Node[];\n\tpreviousSibling?: Node | null;\n\tnextSibling?: Node | null;\n}\n\n/**\n * 3.3.3. Interface MutationRecord\n *\n * A helper class which describes a specific mutation as it is observed by a MutationObserver.\n *\n * @public\n */\nexport default class MutationRecord {\n\t/**\n\t * Returns \"attributes\" if it was an attribute mutation. \"characterData\" if it was a mutation to\n\t * a CharacterData node. And \"childList\" if it was a mutation to the tree of nodes.\n\t */\n\tpublic type: string;\n\n\t/**\n\t * Returns the node the mutation affected, depending on the type. For \"attributes\", it is the\n\t * element whose attribute changed. For \"characterData\", it is the CharacterData node. For\n\t * \"childList\", it is the node whose children changed.\n\t */\n\tpublic target: Node;\n\n\t/**\n\t * Children of target added in this mutation.\n\t *\n\t * (non-standard) According to the spec this should be a NodeList. This implementation uses an\n\t * array.\n\t */\n\tpublic addedNodes: Node[] = [];\n\n\t/**\n\t * Children of target removed in this mutation.\n\t *\n\t * (non-standard) According to the spec this should be a NodeList. This implementation uses an\n\t * array.\n\t */\n\tpublic removedNodes: Node[] = [];\n\n\t/**\n\t * The previous sibling of the added or removed nodes, or null otherwise.\n\t */\n\tpublic previousSibling: Node | null = null;\n\n\t/**\n\t * The next sibling Node of the added or removed nodes, or null otherwise.\n\t */\n\tpublic nextSibling: Node | null = null;\n\n\t/**\n\t * The local name of the changed attribute, or null otherwise.\n\t */\n\tpublic attributeName: string | null = null;\n\n\t/**\n\t * The namespace of the changed attribute, or null otherwise.\n\t */\n\tpublic attributeNamespace: string | null = null;\n\n\t/**\n\t * The return value depends on type. For \"attributes\", it is the value of the changed attribute\n\t * before the change. For \"characterData\", it is the data of the changed node before the change.\n\t * For \"childList\", it is null.\n\t */\n\tpublic oldValue: string | null = null;\n\n\t/**\n\t * (non-standard) Constructs a MutationRecord\n\t *\n\t * @param type   - The value for the type property\n\t * @param target - The value for the target property\n\t */\n\tconstructor(type: string, target: Node) {\n\t\tthis.type = type;\n\t\tthis.target = target;\n\t}\n}\n","import { getContext } from '../context/Context';\nimport MutationObserver from './MutationObserver';\nimport { MutationRecordInit, default as MutationRecord } from './MutationRecord';\nimport Node from '../Node';\n\n/**\n * 3.3.2. Queuing a mutation record\n *\n * To queue a mutation record of type for target with name, namespace, oldValue, addedNodes,\n * removedNodes, previousSibling and nextSibling, run these steps:\n * namespace namespace, oldValue oldValue, addedNodes addedNodes, removedNodes removedNodes,\n *\n * To queue a tree mutation record for target with addedNodes, removedNodes, previousSibling, and\n * nextSibling, run these steps:\n *  - Assert: either addedNodes or removedNodes is not empty.\n *  - Queue a mutation record of \"childList\" for target with null, null, null, addedNodes,\n *    removedNodes, previousSibling, and nextSibling.\n *\n * @param type   - The type of mutation record to queue\n * @param target - The target node\n * @param data   - The data for the mutation record\n */\nexport default function queueMutationRecord(type: string, target: Node, data: MutationRecordInit) {\n\t// 1. Let interested observers be an empty map\n\tconst interestedObservers: MutationObserver[] = [];\n\tconst pairedStrings: (string | null | undefined)[] = [];\n\n\t// 2. Let nodes be the inclusive ancestors of target.\n\t// 3. For each node in nodes, ...:\n\tfor (let node: Node | null = target; node; node = node.parentNode) {\n\t\tnode._registeredObservers.collectInterestedObservers(\n\t\t\ttype,\n\t\t\ttarget,\n\t\t\tdata,\n\t\t\tinterestedObservers,\n\t\t\tpairedStrings\n\t\t);\n\t}\n\n\tconst context = getContext(target);\n\n\t// 4. For each observer → mappedOldValue of interestedObservers:\n\tinterestedObservers.forEach((observer, index) => {\n\t\tconst mappedOldValue = pairedStrings[index];\n\n\t\t// 4.1. Let record be a new MutationRecord object with its type set to type and target set\n\t\t// to target,\n\t\tconst record = new MutationRecord(type, target);\n\n\t\t// ...attributeName set to to name, attributeNamespace set to namespace...\n\t\tif (data.name !== undefined && data.namespace !== undefined) {\n\t\t\trecord.attributeName = data.name;\n\t\t\trecord.attributeNamespace = data.namespace;\n\t\t}\n\n\t\t// ...oldValue set to mappedOldValue...\n\t\tif (mappedOldValue !== undefined) {\n\t\t\trecord.oldValue = mappedOldValue;\n\t\t}\n\n\t\t// ...addedNodes set to addedNodes...\n\t\tif (data.addedNodes !== undefined) {\n\t\t\trecord.addedNodes = data.addedNodes;\n\t\t}\n\n\t\t// ...removedNodes set to removedNodes...\n\t\tif (data.removedNodes !== undefined) {\n\t\t\trecord.removedNodes = data.removedNodes;\n\t\t}\n\n\t\t// ...previousSibling set to previousSibling...\n\t\tif (data.previousSibling !== undefined) {\n\t\t\trecord.previousSibling = data.previousSibling;\n\t\t}\n\n\t\t// ...and nextSibling set to nextSibling.\n\t\tif (data.nextSibling !== undefined) {\n\t\t\trecord.nextSibling = data.nextSibling;\n\t\t}\n\n\t\t// 4.2. Enqueue record to observer’s record queue.\n\t\tcontext._notifySet.appendRecord(observer, record);\n\t});\n\n\t// 5. Queue a mutation observer microtask.\n\tcontext._notifySet.queueMutationObserverMicrotask();\n}\n","import { throwHierarchyRequestError, throwNotFoundError } from './errorHelpers';\nimport { NodeType, isNodeOfType } from './NodeType';\nimport { getNodeDocument, getNodeIndex, forEachInclusiveDescendant } from './treeHelpers';\nimport { insertIntoChildren, removeFromChildren } from './treeMutations';\nimport Document from '../Document';\nimport DocumentFragment from '../DocumentFragment';\nimport Element from '../Element';\nimport { ParentNode, ChildNode } from '../mixins';\nimport Node from '../Node';\nimport { getContext } from '../context/Context';\nimport queueMutationRecord from '../mutation-observer/queueMutationRecord';\nimport Text from '../Text';\n\n// 3.2.3. Mutation algorithms\n\n/**\n * To ensure pre-insertion validity of a node into a parent before a child, run these steps:\n */\nfunction ensurePreInsertionValidity(node: Node, parent: Node, child: Node | null): void {\n\t// 1. If parent is not a Document, DocumentFragment, or Element node, throw a\n\t// HierarchyRequestError.\n\tif (\n\t\t!isNodeOfType(\n\t\t\tparent,\n\t\t\tNodeType.DOCUMENT_NODE,\n\t\t\tNodeType.DOCUMENT_FRAGMENT_NODE,\n\t\t\tNodeType.ELEMENT_NODE\n\t\t)\n\t) {\n\t\tthrowHierarchyRequestError('parent must be a Document, DocumentFragment or Element node');\n\t}\n\n\t// 2. If node is a host-including inclusive ancestor of parent, throw a HierarchyRequestError.\n\tif (node.contains(parent)) {\n\t\tthrowHierarchyRequestError('node must not be an inclusive ancestor of parent');\n\t}\n\n\t// 3. If child is non-null and its parent is not parent, then throw a NotFoundError.\n\tif (child && child.parentNode !== parent) {\n\t\tthrowNotFoundError('child is not a child of parent');\n\t}\n\n\t// 4. If node is not a DocumentFragment, DocumentType, Element, Text, ProcessingInstruction, or\n\t// Comment node, throw a HierarchyRequestError.\n\tif (\n\t\t!isNodeOfType(\n\t\t\tnode,\n\t\t\tNodeType.DOCUMENT_FRAGMENT_NODE,\n\t\t\tNodeType.DOCUMENT_TYPE_NODE,\n\t\t\tNodeType.ELEMENT_NODE,\n\t\t\tNodeType.TEXT_NODE,\n\t\t\tNodeType.CDATA_SECTION_NODE,\n\t\t\tNodeType.PROCESSING_INSTRUCTION_NODE,\n\t\t\tNodeType.COMMENT_NODE\n\t\t)\n\t) {\n\t\tthrowHierarchyRequestError(\n\t\t\t'node must be a DocumentFragment, DocumentType, Element, Text, ProcessingInstruction ' +\n\t\t\t\t'or Comment node'\n\t\t);\n\t}\n\n\t// 5. If either node is a Text node and parent is a document, or node is a doctype and parent is\n\t// not a document, throw a HierarchyRequestError.\n\tif (isNodeOfType(node, NodeType.TEXT_NODE) && isNodeOfType(parent, NodeType.DOCUMENT_NODE)) {\n\t\tthrowHierarchyRequestError('can not insert a Text node under a Document');\n\t}\n\tif (\n\t\tisNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE) &&\n\t\t!isNodeOfType(parent, NodeType.DOCUMENT_NODE)\n\t) {\n\t\tthrowHierarchyRequestError('can only insert a DocumentType node under a Document');\n\t}\n\n\t// 6. If parent is a document, and any of the statements below, switched on node, are true,\n\t// throw a HierarchyRequestError.\n\tif (isNodeOfType(parent, NodeType.DOCUMENT_NODE)) {\n\t\tconst parentDocument = parent as Document;\n\t\tswitch (node.nodeType) {\n\t\t\t// DocumentFragment node\n\t\t\tcase NodeType.DOCUMENT_FRAGMENT_NODE:\n\t\t\t\t// If node has more than one element child or has a Text node child.\n\t\t\t\tconst fragment = node as DocumentFragment;\n\t\t\t\tif (fragment.firstElementChild !== fragment.lastElementChild) {\n\t\t\t\t\tthrowHierarchyRequestError(\n\t\t\t\t\t\t'can not insert more than one element under a Document'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tArray.from(fragment.childNodes).some((child) =>\n\t\t\t\t\t\tisNodeOfType(child, NodeType.TEXT_NODE)\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tthrowHierarchyRequestError('can not insert a Text node under a Document');\n\t\t\t\t}\n\t\t\t\t// Otherwise, if node has one element child and either parent has an element child,\n\t\t\t\t// child is a doctype, or child is non-null and a doctype is following child.\n\t\t\t\tif (\n\t\t\t\t\tfragment.firstElementChild &&\n\t\t\t\t\t(parentDocument.documentElement ||\n\t\t\t\t\t\t(child && isNodeOfType(child, NodeType.DOCUMENT_TYPE_NODE)) ||\n\t\t\t\t\t\t(child &&\n\t\t\t\t\t\t\tparentDocument.doctype &&\n\t\t\t\t\t\t\tgetNodeIndex(child) < getNodeIndex(parentDocument.doctype)))\n\t\t\t\t) {\n\t\t\t\t\tthrowHierarchyRequestError(\n\t\t\t\t\t\t'Document should contain at most one doctype, followed by at most one ' +\n\t\t\t\t\t\t\t'element'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// element\n\t\t\tcase NodeType.ELEMENT_NODE:\n\t\t\t\t// parent has an element child, child is a doctype, or child is non-null and a\n\t\t\t\t// doctype is following child.\n\t\t\t\tif (\n\t\t\t\t\tparentDocument.documentElement ||\n\t\t\t\t\t(child && isNodeOfType(child, NodeType.DOCUMENT_TYPE_NODE)) ||\n\t\t\t\t\t(child &&\n\t\t\t\t\t\tparentDocument.doctype &&\n\t\t\t\t\t\tgetNodeIndex(child) < getNodeIndex(parentDocument.doctype))\n\t\t\t\t) {\n\t\t\t\t\tthrowHierarchyRequestError(\n\t\t\t\t\t\t'Document should contain at most one doctype, followed by at most one ' +\n\t\t\t\t\t\t\t'element'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// doctype\n\t\t\tcase NodeType.DOCUMENT_TYPE_NODE:\n\t\t\t\t// parent has a doctype child, child is non-null and an element is preceding child,\n\t\t\t\t// or child is null and parent has an element child.\n\t\t\t\tif (\n\t\t\t\t\tparentDocument.doctype ||\n\t\t\t\t\t(child &&\n\t\t\t\t\t\tparentDocument.documentElement &&\n\t\t\t\t\t\tgetNodeIndex(parentDocument.documentElement) < getNodeIndex(child)) ||\n\t\t\t\t\t(!child && parentDocument.documentElement)\n\t\t\t\t) {\n\t\t\t\t\tthrowHierarchyRequestError(\n\t\t\t\t\t\t'Document should contain at most one doctype, followed by at most one ' +\n\t\t\t\t\t\t\t'element'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * To pre-insert a node into a parent before a child, run these steps:\n *\n * @param node   - Node to pre-insert\n * @param parent - Parent to insert under\n * @param child  - Child to insert before, or null to insert at the end of parent\n *\n * @returns The inserted node\n */\nexport function preInsertNode<TNode extends Node>(\n\tnode: TNode,\n\tparent: Node,\n\tchild: Node | null\n): TNode {\n\t// 1. Ensure pre-insertion validity of node into parent before child.\n\tensurePreInsertionValidity(node, parent, child);\n\n\t// 2. Let referenceChild be child.\n\tlet referenceChild = child;\n\n\t// 3. If referenceChild is node, set it to node’s next sibling.\n\tif (referenceChild === node) {\n\t\treferenceChild = node.nextSibling;\n\t}\n\n\t// 4. Adopt node into parent's node document.\n\tadoptNode(node, getNodeDocument(parent));\n\n\t// 5. Insert node into parent before referenceChild.\n\tinsertNode(node, parent, referenceChild);\n\n\t// 6. Return node.\n\treturn node;\n}\n\n/**\n * To insert a node into a parent before a child, with an optional suppress observers flag, run\n * these steps:\n *\n * @param node              - Node to insert\n * @param parent            - Parent to insert under\n * @param child             - Child to insert before, or null to insert at end of parent\n * @param suppressObservers - Whether to skip enqueueing a mutation record for this mutation\n */\nexport function insertNode(\n\tnode: Node,\n\tparent: Node,\n\tchild: Node | null,\n\tsuppressObservers: boolean = false\n): void {\n\t// 1. Let nodes be node’s children if node is a DocumentFragment node; otherwise « node ».\n\tconst isDocumentFragment = isNodeOfType(node, NodeType.DOCUMENT_FRAGMENT_NODE);\n\tconst nodes = isDocumentFragment ? Array.from(node.childNodes) : [node];\n\n\t// 2. Let count be nodes's size.\n\tconst count = nodes.length;\n\n\t// 3. If count is 0, then return.\n\tif (count === 0) {\n\t\treturn;\n\t}\n\n\t// 4. If node is a DocumentFragment node, then:\n\tif (isDocumentFragment) {\n\t\t// 4.1 Remove its children with the suppress observers flag set.\n\t\tnodes.forEach((n) => removeNode(n, true));\n\n\t\t// 4.2 Queue a tree mutation record for node with « », nodes, null, and null.\n\t\t// Note: This step intentionally does not pay attention to the suppress observers flag.\n\t\tqueueMutationRecord('childList', node, {\n\t\t\tremovedNodes: nodes,\n\t\t});\n\t}\n\n\t// 5. If child is non-null, then:\n\tif (child !== null) {\n\t\tconst childIndex = getNodeIndex(child);\n\t\tconst context = getContext(node);\n\t\tcontext.forEachRange((range) => {\n\t\t\t// 2.1. For each live range whose start node is parent and start offset is greater than\n\t\t\t// child’s index, increase its start offset by count.\n\t\t\tif (range.startContainer === parent && range.startOffset > childIndex) {\n\t\t\t\trange.startOffset += count;\n\t\t\t}\n\n\t\t\t// 2.2. For each live range whose end node is parent and end offset is greater than\n\t\t\t// child’s index, increase its end offset by count.\n\t\t\tif (range.endContainer === parent && range.endOffset > childIndex) {\n\t\t\t\trange.endOffset += count;\n\t\t\t}\n\t\t});\n\t}\n\n\t// 6. Let previousSibling be child’s previous sibling or parent’s last child if child is null.\n\tlet previousSibling = child === null ? parent.lastChild : child.previousSibling;\n\n\t// 7. For each node in nodes, in tree order:\n\tnodes.forEach((node) => {\n\t\t// 7.1. If child is null, then append node to parent’s children.\n\t\t// 7.2. Otherwise, insert node into parent’s children before child’s index.\n\t\tinsertIntoChildren(node, parent, child);\n\n\t\t// 7.3. If parent is a shadow host and node is a slottable, then assign a slot for node.\n\t\t// (shadow dom not implemented)\n\n\t\t// 7.4. If parent's root is a shadow root, and parent is a slot whose assigned nodes is the\n\t\t// empty list, then run signal a slot change for parent.\n\t\t// 7.5. Run assign slottables for a tree with node’s tree.\n\t\t// (shadow dom not implemented)\n\n\t\t// 7.6. For each shadow-including inclusive descendant inclusiveDescendant of node, in\n\t\t// shadow-including tree order:\n\t\t// 7.6.1. Run the insertion steps with inclusiveDescendant.\n\t\t// (insertion steps not implemented)\n\n\t\t// 7.6.2. If inclusiveDescendant is connected, then:\n\t\t// 7.6.2.1. If inclusiveDescendant is custom, then enqueue a custom element callback\n\t\t// reaction with inclusiveDescendant, callback name \"connectedCallback\", and an empty\n\t\t// argument list.\n\t\t// 7.6.2.2. Otherwise, try to upgrade inclusiveDescendant. If this successfully upgrades\n\t\t// inclusiveDescendant, its connectedCallback will be enqueued automatically during the\n\t\t// upgrade an element algorithm.\n\t\t// (custom elements not implemented)\n\t});\n\n\t// 8. If suppress observers flag is unset, queue a tree mutation record for parent with nodes,\n\t// « », previousSibling and child.\n\tif (!suppressObservers) {\n\t\tqueueMutationRecord('childList', parent, {\n\t\t\taddedNodes: nodes,\n\t\t\tnextSibling: child,\n\t\t\tpreviousSibling: previousSibling,\n\t\t});\n\t}\n\n\t// 9. Run the children changed steps for parent\n\t// (children changed steps not implemented)\n}\n\n/**\n * To append a node to a parent\n *\n * @param node   - Node to append\n * @param parent - Parent to append to\n *\n * @returns The appended node\n */\nexport function appendNode<TNode extends Node>(node: TNode, parent: Node): TNode {\n\t// pre-insert node into parent before null.\n\treturn preInsertNode(node, parent, null);\n}\n\n/**\n * To replace a child with node within a parent, run these steps:\n *\n * @param child  - The child node to replace\n * @param node   - The node to replace child with\n * @param parent - The parent to replace under\n *\n * @returns The old child node\n */\nexport function replaceChildWithNode<TChild extends Node>(\n\tchild: TChild,\n\tnode: Node,\n\tparent: Node\n): TChild {\n\t// 1. If parent is not a Document, DocumentFragment, or Element node, throw a\n\t// HierarchyRequestError.\n\tif (\n\t\t!isNodeOfType(\n\t\t\tparent,\n\t\t\tNodeType.DOCUMENT_NODE,\n\t\t\tNodeType.DOCUMENT_FRAGMENT_NODE,\n\t\t\tNodeType.ELEMENT_NODE\n\t\t)\n\t) {\n\t\tthrowHierarchyRequestError('Can not replace under a non-parent node');\n\t}\n\n\t// 2. If node is a host-including inclusive ancestor of parent, throw a HierarchyRequestError.\n\tif (node.contains(parent)) {\n\t\tthrowHierarchyRequestError('Can not insert a node under its own descendant');\n\t}\n\n\t// 3. If child’s parent is not parent, then throw a NotFoundError.\n\tif (child.parentNode !== parent) {\n\t\tthrowNotFoundError('child is not a child of parent');\n\t}\n\n\t// 4. If node is not a DocumentFragment, DocumentType, Element, Text, ProcessingInstruction, or\n\t// Comment node, throw a HierarchyRequestError.\n\tif (\n\t\t!isNodeOfType(\n\t\t\tnode,\n\t\t\tNodeType.DOCUMENT_FRAGMENT_NODE,\n\t\t\tNodeType.DOCUMENT_TYPE_NODE,\n\t\t\tNodeType.ELEMENT_NODE,\n\t\t\tNodeType.TEXT_NODE,\n\t\t\tNodeType.CDATA_SECTION_NODE,\n\t\t\tNodeType.PROCESSING_INSTRUCTION_NODE,\n\t\t\tNodeType.COMMENT_NODE\n\t\t)\n\t) {\n\t\tthrowHierarchyRequestError(\n\t\t\t\"Can not insert a node that isn't a DocumentFragment, DocumentType, Element, Text, \" +\n\t\t\t\t'ProcessingInstruction or Comment'\n\t\t);\n\t}\n\n\t// 5. If either node is a Text node and parent is a document, or node is a doctype and parent is\n\t// not a document, throw a HierarchyRequestError.\n\tif (isNodeOfType(node, NodeType.TEXT_NODE) && isNodeOfType(parent, NodeType.DOCUMENT_NODE)) {\n\t\tthrowHierarchyRequestError('can not insert a Text node under a Document');\n\t}\n\tif (\n\t\tisNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE) &&\n\t\t!isNodeOfType(parent, NodeType.DOCUMENT_NODE)\n\t) {\n\t\tthrowHierarchyRequestError('can only insert a DocumentType node under a Document');\n\t}\n\n\t// 6. If parent is a document, and any of the statements below, switched on node, are true,\n\t// throw a HierarchyRequestError.\n\tif (isNodeOfType(parent, NodeType.DOCUMENT_NODE)) {\n\t\tconst parentDocument = parent as Document;\n\t\tswitch (node.nodeType) {\n\t\t\t// DocumentFragment node\n\t\t\tcase NodeType.DOCUMENT_FRAGMENT_NODE:\n\t\t\t\t// If node has more than one element child or has a Text node child.\n\t\t\t\tconst fragment = node as DocumentFragment;\n\t\t\t\tif (fragment.firstElementChild !== fragment.lastElementChild) {\n\t\t\t\t\tthrowHierarchyRequestError(\n\t\t\t\t\t\t'can not insert more than one element under a Document'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tArray.from(fragment.childNodes).some((child) =>\n\t\t\t\t\t\tisNodeOfType(child, NodeType.TEXT_NODE)\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tthrowHierarchyRequestError('can not insert a Text node under a Document');\n\t\t\t\t}\n\t\t\t\t// Otherwise, if node has one element child and either parent has an element child\n\t\t\t\t// that is not child or a doctype is following child.\n\t\t\t\tif (\n\t\t\t\t\tfragment.firstElementChild &&\n\t\t\t\t\t((parentDocument.documentElement &&\n\t\t\t\t\t\tparentDocument.documentElement !== (child as Node)) ||\n\t\t\t\t\t\t(child &&\n\t\t\t\t\t\t\tparentDocument.doctype &&\n\t\t\t\t\t\t\tgetNodeIndex(child) < getNodeIndex(parentDocument.doctype)))\n\t\t\t\t) {\n\t\t\t\t\tthrowHierarchyRequestError(\n\t\t\t\t\t\t'Document should contain at most one doctype, followed by at most one ' +\n\t\t\t\t\t\t\t'element'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// element\n\t\t\tcase NodeType.ELEMENT_NODE:\n\t\t\t\t// parent has an element child that is not child or a doctype is following child.\n\t\t\t\tif (\n\t\t\t\t\t(parentDocument.documentElement &&\n\t\t\t\t\t\tparentDocument.documentElement !== (child as Node)) ||\n\t\t\t\t\t(parentDocument.doctype &&\n\t\t\t\t\t\tgetNodeIndex(child) < getNodeIndex(parentDocument.doctype))\n\t\t\t\t) {\n\t\t\t\t\tthrowHierarchyRequestError(\n\t\t\t\t\t\t'Document should contain at most one doctype, followed by at most one ' +\n\t\t\t\t\t\t\t'element'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t// doctype\n\t\t\tcase NodeType.DOCUMENT_TYPE_NODE:\n\t\t\t\t// parent has a doctype child that is not child, or an element is preceding child.\n\t\t\t\tif (\n\t\t\t\t\t(parentDocument.doctype && parentDocument.doctype !== (child as Node)) ||\n\t\t\t\t\t(parentDocument.documentElement &&\n\t\t\t\t\t\tgetNodeIndex(parentDocument.documentElement) < getNodeIndex(child))\n\t\t\t\t) {\n\t\t\t\t\tthrowHierarchyRequestError(\n\t\t\t\t\t\t'Document should contain at most one doctype, followed by at most one ' +\n\t\t\t\t\t\t\t'element'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\t// The above statements differ from the pre-insert algorithm.\n\t}\n\n\t// 7. Let referenceChild be child’s next sibling.\n\tlet referenceChild = child.nextSibling;\n\n\t// 8. If referenceChild is node, set it to node’s next sibling.\n\tif (referenceChild === node) {\n\t\treferenceChild = node.nextSibling;\n\t}\n\n\t// 9. Let previousSibling be child’s previous sibling.\n\tconst previousSibling = child.previousSibling;\n\n\t// 10. Adopt node into parent's node document\n\tadoptNode(node, getNodeDocument(parent));\n\n\t// 11. Let removedNodes be the empty set.\n\tlet removedNodes: Node[] = [];\n\n\t// 12. If child’s parent is non-null, then:\n\tif (child.parentNode !== null) {\n\t\t// 11.1. Set removedNodes to « child ».\n\t\tremovedNodes.push(child);\n\n\t\t// 11.2. Remove child with the suppress observers flag set.\n\t\tremoveNode(child, true);\n\t}\n\t// The above can only be false if child is node.\n\n\t// 13. Let nodes be node’s children if node is a DocumentFragment node; otherwise « node ».\n\tconst nodes = isNodeOfType(node, NodeType.DOCUMENT_FRAGMENT_NODE)\n\t\t? Array.from(node.childNodes)\n\t\t: [node];\n\n\t// 14. Insert node into parent before referenceChild with the suppress observers flag set.\n\tinsertNode(node, parent, referenceChild, true);\n\n\t// 15. Queue a tree mutation record for parent with nodes, removedNodes, previousSibling and\n\t// referenceChild.\n\tqueueMutationRecord('childList', parent, {\n\t\taddedNodes: nodes,\n\t\tremovedNodes: removedNodes,\n\t\tnextSibling: referenceChild,\n\t\tpreviousSibling: previousSibling,\n\t});\n\n\t// 16. Return child.\n\treturn child;\n}\n\n/**\n * To replace all with a node within a parent, run these steps:\n *\n * @param node   New node to insert, or null to remove all nodes under parent\n * @param parent Parent to replace under\n */\nfunction replaceAllWithNode(node: Node | null, parent: Node): void {\n\t// 1. If node is non-null, then adopt node into parent's node document\n\tif (node !== null) {\n\t\tadoptNode(node, getNodeDocument(parent));\n\t}\n\n\t// 2. Let removedNodes be parent’s children.\n\tconst removedNodes = Array.from(parent.childNodes);\n\n\t// 3. Let addedNodes be the empty set.\n\tlet addedNodes: Node[] = [];\n\n\tif (node !== null) {\n\t\t// 4. If node is a DocumentFragment node, then set addedNodes to node's children.\n\t\tif (isNodeOfType(node, NodeType.DOCUMENT_FRAGMENT_NODE)) {\n\t\t\tnode.childNodes.forEach((child) => {\n\t\t\t\taddedNodes.push(child);\n\t\t\t});\n\t\t} else {\n\t\t\t// 5. Otherwise, if node is non-null, set addedNodes to « node ».\n\t\t\taddedNodes.push(node);\n\t\t}\n\t}\n\n\t// 6. Remove all parent’s children, in tree order, with the suppress observers flag set.\n\tremovedNodes.forEach((child) => {\n\t\tremoveNode(child, true);\n\t});\n\n\t// 7. If node is non-null, then insert node into parent before null with the suppress observers\n\t// flag set.\n\tif (node !== null) {\n\t\tinsertNode(node, parent, null, true);\n\t}\n\n\t// 8. If either addedNodes or removedNodes is not empty, then queue a tree mutation record for\n\t// parent with addedNodes, removedNodes, null, and null.\n\tif (addedNodes.length > 0 || removedNodes.length > 0) {\n\t\tqueueMutationRecord('childList', parent, {\n\t\t\taddedNodes,\n\t\t\tremovedNodes,\n\t\t});\n\t}\n\n\t// This algorithm does not make any checks with regards to the node tree constraints.\n\t// Specification authors need to use it wisely.\n}\n\n/**\n * To pre-remove a child from a parent, run these steps:\n *\n * @param child  - Child node to remove\n * @param parent - Parent under which to remove child\n *\n * @returns The removed child\n */\nexport function preRemoveChild<TChild extends Node>(child: TChild, parent: Node): TChild {\n\t// 1. If child’s parent is not parent, then throw a NotFoundError.\n\tif (child.parentNode !== parent) {\n\t\tthrowNotFoundError('child is not a child of parent');\n\t}\n\n\t// 2. Remove child.\n\tremoveNode(child);\n\n\t// 3. Return child.\n\treturn child;\n}\n\n/**\n * To remove a node, with an optional suppress observers flag, run these steps:\n *\n * @param node              - Child to remove\n * @param suppressObservers - Whether to skip enqueueing a mutation record for this mutation\n */\nexport function removeNode(node: Node, suppressObservers: boolean = false): void {\n\t// 1. Let parent be node's parent\n\t// 2. Assert: parent is non-null.\n\tconst parent = node.parentNode!;\n\n\t// 3. Let index be node’s index.\n\tconst index = getNodeIndex(node);\n\n\tconst context = getContext(node);\n\tcontext.forEachRange((range) => {\n\t\t// 4. For each live range whose start node is an inclusive descendant of node, set its start\n\t\t// to (parent, index).\n\t\tif (node.contains(range.startContainer)) {\n\t\t\trange.startContainer = parent;\n\t\t\trange.startOffset = index;\n\t\t}\n\n\t\t// 5. For each live range whose end node is an inclusive descendant of node, set its end to\n\t\t// (parent, index).\n\t\tif (node.contains(range.endContainer)) {\n\t\t\trange.endContainer = parent;\n\t\t\trange.endOffset = index;\n\t\t}\n\n\t\t// 6. For each live range whose start node is parent and start offset is greater than index,\n\t\t// decrease its start offset by one.\n\t\tif (range.startContainer === parent && range.startOffset > index) {\n\t\t\trange.startOffset -= 1;\n\t\t}\n\n\t\t// 7. For each live range whose end node is parent and end offset is greater than index,\n\t\t// decrease its end offset by one.\n\t\tif (range.endContainer === parent && range.endOffset > index) {\n\t\t\trange.endOffset -= 1;\n\t\t}\n\t});\n\n\t// 8. For each NodeIterator object iterator whose root’s node document is node’s node document,\n\t// run the NodeIterator pre-removing steps given node and iterator.\n\t// (NodeIterator not implemented)\n\n\t// 9. Let oldPreviousSibling be node’s previous sibling.\n\tconst oldPreviousSibling = node.previousSibling;\n\n\t// 10. Let oldNextSibling be node’s next sibling.\n\tconst oldNextSibling = node.nextSibling;\n\n\t// 11. Remove node from its parent’s children.\n\tremoveFromChildren(node, parent);\n\n\t// 12. If node is assigned, then run assign slottables for node’s assigned slot.\n\t// (shadow dom not implemented)\n\n\t// 13. If parent's root is a shadow root, and parent is a slot whose assigned nodes is the empty\n\t// list, then run signal a slot change for parent.\n\t// (shadow dom not implemented)\n\n\t// 14. If node has an inclusive descendant that is a slot, then:\n\t// 14.1. Run assign slottables for a tree with parent’s tree.\n\t// 14.2. Run assign slottables for a tree with node’s tree.\n\t// (shadow dom not implemented)\n\n\t// 15. Run the removing steps with node and parent.\n\t// (removing steps not implemented)\n\n\t// 16. Let isParentConnected be parent's connected.\n\t// 17. If node is custom and isParentConnected is true, then enqueue a custom element callback\n\t// reaction with node, callback name \"disconnectedCallback\", and an empty argument list.\n\t// It is intentional for now that custom elements do not get parent passed. This might change in\n\t// the future if there is a need.\n\t// (custom elements not implemented)\n\n\t// 18. For each shadow-including descendant descendant of node, in shadow-including tree order,\n\t// then:\n\t// 18.1. Run the removing steps with descendant.\n\t// (shadow dom not implemented)\n\n\t// 18.2. If descendant is custom and isParentConnected is true, then enqueue a custom element\n\t// callback reaction with descendant, callback name \"disconnectedCallback\", and an empty\n\t// argument list.\n\t// (custom elements not implemented)\n\n\t// 19. For each inclusive ancestor inclusiveAncestor of parent, and then for each registered of\n\t// inclusiveAncestor's registered observer list, if registered's options's subtree is true, then\n\t// append a new transient registered observer whose observer is registered's observer, options\n\t// is registered's options, and source is registered to node's registered observer list.\n\tfor (\n\t\tlet inclusiveAncestor: Node | null = parent;\n\t\tinclusiveAncestor;\n\t\tinclusiveAncestor = inclusiveAncestor.parentNode\n\t) {\n\t\tinclusiveAncestor._registeredObservers.appendTransientRegisteredObservers(node);\n\t}\n\n\t// 20. If suppress observers flag is unset, queue a tree mutation record for parent with « »,\n\t// « node », oldPreviousSibling, and oldNextSibling\n\tif (!suppressObservers) {\n\t\tqueueMutationRecord('childList', parent, {\n\t\t\tremovedNodes: [node],\n\t\t\tnextSibling: oldNextSibling,\n\t\t\tpreviousSibling: oldPreviousSibling,\n\t\t});\n\t}\n\n\t// 21. Run the children changed steps for parent\n\t// (children changed steps not implemented)\n}\n\n/**\n * 3.5. Interface Document\n *\n * To adopt a node into a document, with an optional forceDocumentFragmentAdoption, run these steps:\n *\n * (forceDocumentFragmentAdoption is only set to true for HTML template, so is not implemented here)\n *\n * @param node     - Node to adopt\n * @param document - Document to adopt node into\n */\nexport function adoptNode(node: Node, document: Document): void {\n\t// 1. If forceDocumentFragmentAdoption is not given, then set it false.\n\t// (value unused)\n\n\t// 2. Let oldDocument be node’s node document.\n\tconst oldDocument = getNodeDocument(node);\n\n\t// 2. If node’s parent is non-null, remove node.\n\tif (node.parentNode) {\n\t\tremoveNode(node);\n\t}\n\n\t// 3. If document is not oldDocument, then:\n\tif (document === oldDocument) {\n\t\treturn;\n\t}\n\n\t// 3.1. For each inclusiveDescendant in node’s shadow-including inclusive descendants:\n\tforEachInclusiveDescendant(node, (inclusiveDescendant) => {\n\t\t// 3.1.1. If forceDocumentFragmentAdoption is false, inclusiveDescendant is a\n\t\t// DocumentFragment node, inclusiveDescendant is node, and node's host is non-null, then\n\t\t// continue\n\t\t// Note: this is only reasonable as long as all adopt callers remove the children of node.\n\t\t// (shadow dom and HTML templates not implemented)\n\n\t\t// 3.1.2. Set inclusiveDescendant’s node document to document.\n\t\t// (calling code ensures that node is never a Document)\n\t\tinclusiveDescendant.ownerDocument = document;\n\n\t\t// 3.1.3. If inclusiveDescendant is an element, then set the node document of each attribute\n\t\t// in inclusiveDescendant’s attribute list to document.\n\t\tif (isNodeOfType(inclusiveDescendant, NodeType.ELEMENT_NODE)) {\n\t\t\tfor (const attr of (inclusiveDescendant as Element).attributes) {\n\t\t\t\tattr.ownerDocument = document;\n\t\t\t}\n\t\t}\n\t});\n\n\t// 3.2. For each inclusiveDescendant in node’s shadow-including inclusive descendants that is\n\t// custom, enqueue a custom element callback reaction with inclusiveDescendant, callback name\n\t// \"adoptedCallback\", and an argument list containing oldDocument and document.\n\t// (custom element support has not been implemented)\n\n\t// 3.3. For each inclusiveDescendant in node’s shadow-including inclusive descendants, in\n\t// shadow-including tree order, run the adopting steps with inclusiveDescendant and oldDocument.\n\t// (adopting steps not implemented)\n}\n\n/**\n * The descendant text content of a node node is the concatenation of the data of all the Text node\n * descendants of node, in tree order.\n *\n * @param node Root node\n *\n * @returns  The concatenation of data of all the Text node descendants of the given node, in tree\n *           order\n */\nexport function getDescendantTextContent(node: Node): string {\n\tconst data: string[] = [];\n\tforEachInclusiveDescendant(node, (descendant) => {\n\t\t// CDATASection is a subtype of Text\n\t\tif (!isNodeOfType(descendant, NodeType.TEXT_NODE, NodeType.CDATA_SECTION_NODE)) {\n\t\t\treturn;\n\t\t}\n\n\t\tdata.push((descendant as Text).data);\n\t});\n\treturn data.join('');\n}\n\n/**\n * Implementation of the textContent setter for DocumentFragment and Element\n *\n * @param parent    Node for which to set textContent\n * @param newValue  New textContent value\n */\nexport function stringReplaceAll(parent: Node, newValue: string): void {\n\t// 1. Let node be null.\n\tlet node = null;\n\n\t// 2. If the given value is not the empty string, then set node to a new Text node whose data is\n\t// the given value and node document is parent’s node document.\n\tif (newValue !== '') {\n\t\tconst context = getContext(parent);\n\t\tnode = new context.Text(newValue);\n\t}\n\n\t// 3. Replace all with node within the this.\n\treplaceAllWithNode(node, parent);\n}\n\n/**\n * To convert nodes into a node, given nodes and document, run these steps:\n *\n * @param nodes    Nodes and/or strings to convert\n * @param document Document used to create new nodes\n *\n * @returns A single node representing nodes\n */\nfunction convertNodesIntoNode(nodes: (Node | string)[], document: Document): Node {\n\t// 1. Let node be null.\n\t// (created as needed in branches below)\n\n\t// 2. Replace each string in nodes with a new Text node whose data is the string and node\n\t// document is document.\n\tconst actualNodes: Node[] = nodes.map((nodeOrString) => {\n\t\t// IDL actually coerces every non-node (e.g., null) into a string here\n\t\tif (nodeOrString instanceof Node) {\n\t\t\treturn nodeOrString;\n\t\t}\n\t\treturn document.createTextNode(String(nodeOrString));\n\t});\n\n\t// 3. If nodes contains one node, set node to that node.\n\tif (actualNodes.length === 1) {\n\t\treturn actualNodes[0];\n\t} else {\n\t\t// 4. Otherwise, set node to a new DocumentFragment whose node document is document, and then\n\t\t// append each node in nodes, if any, to it.\n\t\tconst node = document.createDocumentFragment();\n\t\tactualNodes.forEach((child) => {\n\t\t\tnode.appendChild(child);\n\t\t});\n\t\treturn node;\n\t}\n\n\t// 5. Return node.\n\t// (done in branches above)\n}\n\n/**\n * The prepend(nodes) method, when invoked, must run these steps:\n *\n * @param thisObject - The ParentNode on which the method is invoked\n * @param nodes      - The nodes (and/or strings) to prepend\n */\nexport function prependNodes(thisObject: Node & ParentNode, nodes: (Node | string)[]): void {\n\t// 1. Let node be the result of converting nodes into a node given nodes and this’s node\n\t// document.\n\tconst node = convertNodesIntoNode(nodes, getNodeDocument(thisObject));\n\n\t// 2. Pre-insert node into this before the this’s first child.\n\tpreInsertNode(node, thisObject, thisObject.firstChild);\n}\n\n/**\n * The append(nodes) method, when invoked, must run these steps:\n *\n * @param thisObject - The ParentNode on which the method is invoked\n * @param nodes      - The nodes (and/or strings) to append\n */\nexport function appendNodes(thisObject: Node & ParentNode, nodes: (Node | string)[]): void {\n\t// 1. Let node be the result of converting nodes into a node given nodes and this’s node\n\t// document.\n\tconst node = convertNodesIntoNode(nodes, getNodeDocument(thisObject));\n\n\t// 2. Append node to this\n\tappendNode(node, thisObject);\n}\n\n/**\n * The replaceChildren(nodes) method, when invoked, must run these steps:\n *\n * @param thisObject - The ParentNode on which the method is invoked\n * @param nodes      - The nodes (and/or strings) to replace the children with\n */\nexport function replaceChildren(thisObject: Node & ParentNode, nodes: (Node | string)[]): void {\n\t// 1. Let node be the result of converting nodes into a node given nodes and this's node\n\t// document.\n\tconst node = convertNodesIntoNode(nodes, getNodeDocument(thisObject));\n\n\t// 2. Ensure pre-insertion validity of node into this before null.\n\tensurePreInsertionValidity(node, thisObject, null);\n\n\t// 3. Replace all with node within this.\n\treplaceAllWithNode(node, thisObject);\n}\n\n/**\n * The before(nodes) method, when invoked, must run these steps:\n *\n * @param thisObject - The ChildNode on which the method is invoked\n * @param nodes        The nodes (and/or strings) to insert\n */\nexport function insertNodesBefore(thisObject: Node & ChildNode, nodes: (Node | string)[]): void {\n\t// 1. Let parent be this’s parent.\n\tconst parent = thisObject.parentNode;\n\n\t// 2. If parent is null, then return.\n\tif (parent === null) {\n\t\treturn;\n\t}\n\n\t// 3. Let viablePreviousSibling be this’s first preceding sibling not in nodes, and\n\t// null otherwise.\n\tlet viablePreviousSibling = thisObject.previousSibling;\n\twhile (viablePreviousSibling !== null && nodes.indexOf(viablePreviousSibling) >= 0) {\n\t\tviablePreviousSibling = viablePreviousSibling.previousSibling;\n\t}\n\n\t// 4. Let node be the result of converting nodes into a node, given nodes and this’s\n\t// node document.\n\tconst node = convertNodesIntoNode(nodes, getNodeDocument(thisObject));\n\n\t// 5. If viablePreviousSibling is null, set it to parent’s first child, and to\n\t// viablePreviousSibling’s next sibling otherwise.\n\t// (it makes more sense to rename this as it will no longer be a previous sibling to the\n\t// inserted nodes)\n\tconst referenceNode =\n\t\tviablePreviousSibling === null ? parent.firstChild : viablePreviousSibling.nextSibling;\n\n\t// 6. Pre-insert node into parent before viablePreviousSibling.\n\tpreInsertNode(node, parent, referenceNode);\n}\n\n/**\n * The after(nodes) method, when invoked, must run these steps:\n *\n * @param thisObject - The ChildNode on which the method is invoked\n * @param nodes      - The nodes (and/or strings) to insert\n */\nexport function insertNodesAfter(thisObject: Node & ChildNode, nodes: (Node | string)[]): void {\n\t// 1. Let parent be this’s parent.\n\tconst parent = thisObject.parentNode;\n\n\t// 2. If parent is null, then return.\n\tif (parent === null) {\n\t\treturn;\n\t}\n\n\t// 3. Let viableNextSibling be this’s first following sibling not in nodes, and null\n\t// otherwise.\n\tlet viableNextSibling = thisObject.nextSibling;\n\twhile (viableNextSibling !== null && nodes.indexOf(viableNextSibling) >= 0) {\n\t\tviableNextSibling = viableNextSibling.nextSibling;\n\t}\n\n\t// 4. Let node be the result of converting nodes into a node, given nodes and this’s\n\t// node document.\n\tconst node = convertNodesIntoNode(nodes, getNodeDocument(thisObject));\n\n\t// 5. Pre-insert node into parent before viableNextSibling.\n\tpreInsertNode(node, parent, viableNextSibling);\n}\n\n/**\n * The replaceWith(nodes) method, when invoked, must run these steps:\n *\n * @param thisObject - The ChildNode on which the method is invoked\n * @param nodes      - The nodes (and/or strings) to insert\n */\nexport function replaceWithNodes(thisObject: Node & ChildNode, nodes: (Node | string)[]): void {\n\t// 1. Let parent be this’s parent.\n\tconst parent = thisObject.parentNode;\n\n\t// 2. If parent is null, then return.\n\tif (parent === null) {\n\t\treturn;\n\t}\n\n\t// 3. Let viableNextSibling be this’s first following sibling not in nodes, and null\n\t// otherwise.\n\tlet viableNextSibling = thisObject.nextSibling;\n\twhile (viableNextSibling !== null && nodes.indexOf(viableNextSibling) >= 0) {\n\t\tviableNextSibling = viableNextSibling.nextSibling;\n\t}\n\n\t// 4. Let node be the result of converting nodes into a node, given nodes and this’s\n\t// node document.\n\tconst node = convertNodesIntoNode(nodes, getNodeDocument(thisObject));\n\n\t// 5. If this’s parent is parent, replace the this with node within parent.\n\t// Note: this could have been inserted into node.\n\tif (thisObject.parentNode === parent) {\n\t\treplaceChildWithNode(thisObject, node, parent);\n\t} else {\n\t\t// 6. Otherwise, pre-insert node into parent before viableNextSibling.\n\t\tpreInsertNode(node, parent, viableNextSibling);\n\t}\n}\n\n/**\n * The remove() method, when invoked, must run these steps:\n *\n * @param thisObject The ChildNode on which the method is invoked\n */\nexport function removeFromParent(thisObject: Node & ChildNode): void {\n\t// 1. If this’s parent is null, then return.\n\tif (thisObject.parentNode === null) {\n\t\treturn;\n\t}\n\n\t// 2. Remove the this.\n\tremoveNode(thisObject);\n}\n","import { asParentNode, asNonDocumentTypeChildNode } from '../mixins';\nimport Document from '../Document';\nimport DocumentType from '../DocumentType';\nimport Element from '../Element';\nimport Node from '../Node';\n\nimport { NodeType, isNodeOfType } from './NodeType';\n\n/**\n * Insert node into parent's children before referenceNode.\n *\n * Updates the pointers that model the tree, as well as precomputing derived properties.\n *\n * @param node           - Node to insert\n * @param parent         - Parent to insert under\n * @param referenceChild - Child to insert before\n */\nexport function insertIntoChildren(node: Node, parent: Node, referenceChild: Node | null): void {\n\t// Node\n\tnode.parentNode = parent;\n\tconst previousSibling: Node | null =\n\t\treferenceChild === null ? parent.lastChild : referenceChild.previousSibling;\n\tconst nextSibling: Node | null = referenceChild === null ? null : referenceChild;\n\tnode.previousSibling = previousSibling;\n\tnode.nextSibling = nextSibling;\n\tif (previousSibling) {\n\t\tpreviousSibling.nextSibling = node;\n\t} else {\n\t\tparent.firstChild = node;\n\t}\n\tif (nextSibling) {\n\t\tnextSibling.previousSibling = node;\n\t\tparent.childNodes.splice(parent.childNodes.indexOf(nextSibling), 0, node);\n\t} else {\n\t\tparent.lastChild = node;\n\t\tparent.childNodes.push(node);\n\t}\n\n\t// ParentNode\n\tif (isNodeOfType(node, NodeType.ELEMENT_NODE)) {\n\t\tconst element = node as Element;\n\t\tconst parentNode = asParentNode(parent);\n\t\t// Functions calling this will ensure parent is always a ParentNode\n\t\t/* istanbul ignore else */\n\t\tif (parentNode) {\n\t\t\tlet previousElementSibling: Element | null = null;\n\t\t\tfor (let sibling = previousSibling; sibling; sibling = sibling.previousSibling) {\n\t\t\t\tif (isNodeOfType(sibling, NodeType.ELEMENT_NODE)) {\n\t\t\t\t\tpreviousElementSibling = sibling as Element;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tconst siblingNonDocumentTypeChildNode = asNonDocumentTypeChildNode(sibling);\n\t\t\t\tif (siblingNonDocumentTypeChildNode) {\n\t\t\t\t\tpreviousElementSibling = siblingNonDocumentTypeChildNode.previousElementSibling;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet nextElementSibling: Element | null = null;\n\t\t\tfor (let sibling = nextSibling; sibling; sibling = sibling.nextSibling) {\n\t\t\t\tif (isNodeOfType(sibling, NodeType.ELEMENT_NODE)) {\n\t\t\t\t\tnextElementSibling = sibling as Element;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tconst siblingNonDocumentTypeChildNode = asNonDocumentTypeChildNode(sibling);\n\t\t\t\t// An element can never be inserted before a doctype\n\t\t\t\t/* istanbul ignore else */\n\t\t\t\tif (siblingNonDocumentTypeChildNode) {\n\t\t\t\t\tnextElementSibling = siblingNonDocumentTypeChildNode.nextElementSibling;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!previousElementSibling) {\n\t\t\t\tparentNode.firstElementChild = element;\n\t\t\t}\n\t\t\tif (!nextElementSibling) {\n\t\t\t\tparentNode.lastElementChild = element;\n\t\t\t}\n\t\t\tparentNode.childElementCount += 1;\n\t\t}\n\t}\n\n\t// Document\n\tif (isNodeOfType(parent, NodeType.DOCUMENT_NODE)) {\n\t\tconst parentDocument = parent as Document;\n\t\tif (isNodeOfType(node, NodeType.ELEMENT_NODE)) {\n\t\t\tparentDocument.documentElement = node as Element;\n\t\t} else if (isNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE)) {\n\t\t\tparentDocument.doctype = node as DocumentType;\n\t\t}\n\t}\n}\n\n/**\n * Remove node from parent's children.\n *\n * Updates the pointers that model the tree, as well as precomputing derived properties.\n *\n * @param node   - Node to remove\n * @param parent - Parent to remove from\n */\nexport function removeFromChildren(node: Node, parent: Node) {\n\tconst previousSibling = node.previousSibling;\n\tconst nextSibling = node.nextSibling;\n\tconst isElement = isNodeOfType(node, NodeType.ELEMENT_NODE);\n\tconst previousElementSibling = isElement ? (node as Element).previousElementSibling : null;\n\tconst nextElementSibling = isElement ? (node as Element).nextElementSibling : null;\n\n\t// Node\n\tnode.parentNode = null;\n\tnode.previousSibling = null;\n\tnode.nextSibling = null;\n\tif (previousSibling) {\n\t\tpreviousSibling.nextSibling = nextSibling;\n\t} else {\n\t\tparent.firstChild = nextSibling;\n\t}\n\tif (nextSibling) {\n\t\tnextSibling.previousSibling = previousSibling;\n\t} else {\n\t\tparent.lastChild = previousSibling;\n\t}\n\tparent.childNodes.splice(parent.childNodes.indexOf(node), 1);\n\n\t// ParentNode\n\tif (isElement) {\n\t\tconst parentNode = asParentNode(parent);\n\t\t// Functions calling this will ensure parent is always a ParentNode\n\t\t/* istanbul ignore else */\n\t\tif (parentNode) {\n\t\t\tif (parentNode.firstElementChild === node) {\n\t\t\t\tparentNode.firstElementChild = nextElementSibling;\n\t\t\t}\n\t\t\tif (parentNode.lastElementChild === node) {\n\t\t\t\tparentNode.lastElementChild = previousElementSibling;\n\t\t\t}\n\t\t\tparentNode.childElementCount -= 1;\n\t\t}\n\t}\n\n\t// Document\n\tif (isNodeOfType(parent, NodeType.DOCUMENT_NODE)) {\n\t\tconst parentDocument = parent as Document;\n\t\tif (isNodeOfType(node, NodeType.ELEMENT_NODE)) {\n\t\t\tparentDocument.documentElement = null;\n\t\t} else if (isNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE)) {\n\t\t\tparentDocument.doctype = null;\n\t\t}\n\t}\n}\n","import { expectObject } from './errorHelpers';\n\nexport function asUnsignedLong(number: number): number {\n\treturn number >>> 0;\n}\n\nexport function legacyNullToEmptyString(value: string | null): string {\n\t// Treat null as empty string\n\tif (value === null) {\n\t\treturn '';\n\t}\n\n\t// Coerce other values to string\n\treturn String(value);\n}\n\nexport function ifNullActAsIfEmptyString(value: string | null | undefined): string {\n\t// Treat both undefined and null as empty string\n\tif (value === undefined || value === null) {\n\t\treturn '';\n\t}\n\n\t// Coerce other values to string\n\treturn String(value);\n}\n\nexport function asObject<T>(value: T, Constructor: any): T {\n\texpectObject(value, Constructor);\n\n\treturn value;\n}\n\nexport function asNullableObject<T>(value: T | null | undefined, Constructor: any): T | null {\n\tif (value === undefined || value === null) {\n\t\treturn null;\n\t}\n\n\treturn asObject(value, Constructor);\n}\n\nexport function asNullableString(value: string | null | undefined): string | null {\n\t// Treat undefined as null\n\tif (value === undefined) {\n\t\treturn null;\n\t}\n\n\treturn value;\n}\n","import Element from './Element';\nimport Document from './Document';\nimport Text from './Text';\nimport { getContext } from './context/Context';\nimport RegisteredObservers from './mutation-observer/RegisteredObservers';\nimport cloneNode from './util/cloneNode';\nimport { expectArity } from './util/errorHelpers';\nimport {\n\tpreInsertNode,\n\tappendNode,\n\treplaceChildWithNode,\n\tpreRemoveChild,\n\tremoveNode,\n} from './util/mutationAlgorithms';\nimport { NodeType, isNodeOfType } from './util/NodeType';\nimport { getNodeDocument } from './util/treeHelpers';\nimport { asNullableObject, asNullableString, asObject } from './util/typeHelpers';\n\n/**\n * 3.4. Interface Node\n *\n * @public\n */\nexport default abstract class Node {\n\t// Node types are exposed as properties of the constructor\n\tstatic ELEMENT_NODE: number = NodeType.ELEMENT_NODE;\n\tstatic ATTRIBUTE_NODE: number = NodeType.ATTRIBUTE_NODE;\n\tstatic TEXT_NODE: number = NodeType.TEXT_NODE;\n\tstatic CDATA_SECTION_NODE: number = NodeType.CDATA_SECTION_NODE;\n\tstatic ENTITY_REFERENCE_NODE: number = NodeType.ENTITY_REFERENCE_NODE; // legacy\n\tstatic ENTITY_NODE: number = NodeType.ENTITY_NODE; // legacy\n\tstatic PROCESSING_INSTRUCTION_NODE: number = NodeType.PROCESSING_INSTRUCTION_NODE;\n\tstatic COMMENT_NODE: number = NodeType.COMMENT_NODE;\n\tstatic DOCUMENT_NODE: number = NodeType.DOCUMENT_NODE;\n\tstatic DOCUMENT_TYPE_NODE: number = NodeType.DOCUMENT_TYPE_NODE;\n\tstatic DOCUMENT_FRAGMENT_NODE: number = NodeType.DOCUMENT_FRAGMENT_NODE;\n\tstatic NOTATION_NODE: number = NodeType.NOTATION_NODE; // legacy\n\n\t// Node types also exist as instance properties, assigned to the prototype below\n\tpublic ELEMENT_NODE!: number;\n\tpublic ATTRIBUTE_NODE!: number;\n\tpublic TEXT_NODE!: number;\n\tpublic CDATA_SECTION_NODE!: number;\n\tpublic ENTITY_REFERENCE_NODE!: number; // legacy\n\tpublic ENTITY_NODE!: number; // legacy\n\tpublic PROCESSING_INSTRUCTION_NODE!: number;\n\tpublic COMMENT_NODE!: number;\n\tpublic DOCUMENT_NODE!: number;\n\tpublic DOCUMENT_TYPE_NODE!: number;\n\tpublic DOCUMENT_FRAGMENT_NODE!: number;\n\tpublic NOTATION_NODE!: number; // legacy\n\n\t/**\n\t * Returns the type of node, represented by a number.\n\t */\n\tpublic abstract get nodeType(): number;\n\n\t/**\n\t * Returns a string appropriate for the type of node.\n\t */\n\tpublic abstract get nodeName(): string;\n\n\t/**\n\t * A reference to the Document node in which the current node resides.\n\t */\n\tpublic ownerDocument: Document | null = null;\n\n\t/**\n\t * The parent node of the current node.\n\t */\n\tpublic parentNode: Node | null = null;\n\n\t/**\n\t * The parent if it is an element, or null otherwise.\n\t */\n\tpublic get parentElement(): Element | null {\n\t\treturn this.parentNode && isNodeOfType(this.parentNode, NodeType.ELEMENT_NODE)\n\t\t\t? (this.parentNode as Element)\n\t\t\t: null;\n\t}\n\n\t/**\n\t * Returns true if this has children, and false otherwise.\n\t */\n\tpublic hasChildNodes(): boolean {\n\t\treturn !!this.childNodes.length;\n\t}\n\n\t/**\n\t * The node's children.\n\t *\n\t * Non-standard: implemented as an array rather than a NodeList.\n\t */\n\tpublic childNodes: Node[] = [];\n\n\t/**\n\t * The first child node of the current node, or null if it has no children.\n\t */\n\tpublic firstChild: Node | null = null;\n\n\t/**\n\t * The last child node of the current node, or null if it has no children.\n\t */\n\tpublic lastChild: Node | null = null;\n\n\t/**\n\t * The first preceding sibling of the current node, or null if it has none.\n\t */\n\tpublic previousSibling: Node | null = null;\n\n\t/**\n\t * The first following sibling of the current node, or null if it has none.\n\t */\n\tpublic nextSibling: Node | null = null;\n\n\t/**\n\t * The value of the node.\n\t */\n\tpublic abstract get nodeValue(): string | null;\n\tpublic abstract set nodeValue(value: string | null);\n\n\t/**\n\t * The textContent of the node.\n\t */\n\tpublic abstract get textContent(): string | null;\n\tpublic abstract set textContent(value: string | null);\n\n\t/**\n\t * (non-standard)\n\t * Each node has a registered observer list of zero or more registered observers, which is\n\t * initially empty.\n\t */\n\tpublic _registeredObservers: RegisteredObservers = new RegisteredObservers(this);\n\n\t/**\n\t * Puts the specified node and all of its subtree into a \"normalized\" form. In a normalized\n\t * subtree, no text nodes in the subtree are empty and there are no adjacent text nodes.\n\t */\n\tpublic normalize(): void {\n\t\t// for each descendant exclusive Text node node of this:\n\t\tlet node = this.firstChild;\n\t\tlet index = 0;\n\t\tconst document = getNodeDocument(this);\n\t\twhile (node) {\n\t\t\tlet nextNode = node.nextSibling;\n\t\t\tif (!isNodeOfType(node, NodeType.TEXT_NODE)) {\n\t\t\t\t// Process descendants\n\t\t\t\tnode.normalize();\n\t\t\t\tnode = nextNode;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst textNode = node as Text;\n\t\t\t// 1. Let length be node’s length.\n\t\t\tlet length = textNode.length;\n\n\t\t\t// 2. If length is zero, then remove node and continue with the next exclusive Text\n\t\t\t// node, if any.\n\t\t\tif (length === 0) {\n\t\t\t\tremoveNode(node);\n\t\t\t\t--index;\n\t\t\t\tnode = nextNode;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// 3. Let data be the concatenation of the data of node’s contiguous exclusive Text\n\t\t\t// nodes (excluding itself), in tree order.\n\t\t\tlet data = '';\n\t\t\tconst siblingsToRemove = [];\n\t\t\tfor (\n\t\t\t\tlet sibling = textNode.nextSibling;\n\t\t\t\tsibling && isNodeOfType(sibling, NodeType.TEXT_NODE);\n\t\t\t\tsibling = sibling.nextSibling\n\t\t\t) {\n\t\t\t\tdata += (sibling as Text).data;\n\t\t\t\tsiblingsToRemove.push(sibling);\n\t\t\t}\n\n\t\t\t// 4. Replace data with node node, offset length, count 0, and data data.\n\t\t\tif (data) {\n\t\t\t\ttextNode.replaceData(length, 0, data);\n\t\t\t}\n\n\t\t\t// 5. Let currentNode be node’s next sibling.\n\t\t\t// 6. While currentNode is an exclusive Text node:\n\t\t\tconst context = getContext(this);\n\t\t\tfor (let i = 0, l = siblingsToRemove.length; i < l; ++i) {\n\t\t\t\tconst currentNode = siblingsToRemove[i];\n\t\t\t\tconst currentNodeIndex = index + i + 1;\n\n\t\t\t\tcontext.forEachRange((range) => {\n\t\t\t\t\t// 6.1. For each live range whose start node is currentNode, add length to its\n\t\t\t\t\t// start offset and set its start node to node.\n\t\t\t\t\tif (range.startContainer === currentNode) {\n\t\t\t\t\t\trange.startOffset += length;\n\t\t\t\t\t\trange.startContainer = textNode;\n\t\t\t\t\t}\n\n\t\t\t\t\t// 6.2. For each live range whose end node is currentNode, add length to its end\n\t\t\t\t\t// offset and set its end node to node.\n\t\t\t\t\tif (range.endContainer === currentNode) {\n\t\t\t\t\t\trange.endOffset += length;\n\t\t\t\t\t\trange.endContainer = textNode;\n\t\t\t\t\t}\n\n\t\t\t\t\t// 6.3. For each live range whose start node is currentNode’s parent and start\n\t\t\t\t\t// offset is currentNode’s index, set its start node to node and its start\n\t\t\t\t\t// offset to length.\n\t\t\t\t\tif (range.startContainer === this && range.startOffset === currentNodeIndex) {\n\t\t\t\t\t\trange.startContainer = textNode;\n\t\t\t\t\t\trange.startOffset = length;\n\t\t\t\t\t}\n\n\t\t\t\t\t// 6.4. For each live range whose end node is currentNode’s parent and end\n\t\t\t\t\t// offset is currentNode’s index, set its end node to node and its end offset to\n\t\t\t\t\t// length.\n\t\t\t\t\tif (range.endContainer === this && range.endOffset === currentNodeIndex) {\n\t\t\t\t\t\trange.endContainer = textNode;\n\t\t\t\t\t\trange.endOffset = length;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// 6.5. Add currentNode’s length to length.\n\t\t\t\tlength += (currentNode as Text).length;\n\n\t\t\t\t// 6.6. Set currentNode to its next sibling.\n\t\t\t\t// (see for-loop increment)\n\t\t\t}\n\n\t\t\t// 7. Remove node’s contiguous exclusive Text nodes (excluding itself), in tree order.\n\t\t\twhile (siblingsToRemove.length) {\n\t\t\t\tremoveNode(siblingsToRemove.shift() as Node);\n\t\t\t}\n\n\t\t\t// Move to next node\n\t\t\tnode = node.nextSibling;\n\t\t\t++index;\n\t\t}\n\t}\n\n\t/**\n\t * Returns a copy of the current node.\n\t *\n\t * @param deep - Whether to also clone the node's descendants\n\t *\n\t * @returns A copy of the current node\n\t */\n\tpublic cloneNode(deep: boolean = false): this {\n\t\treturn cloneNode(this, deep);\n\t}\n\n\t/**\n\t * Returns true if other is an inclusive descendant of this, and false otherwise\n\t * (including when other is null).\n\t *\n\t * @param childNode - Node to check\n\t *\n\t * @returns Whether childNode is an inclusive descendant of the current node\n\t */\n\tpublic contains(other: Node | null): boolean {\n\t\texpectArity(arguments, 1);\n\t\tother = asNullableObject(other, Node);\n\n\t\twhile (other && other != this) {\n\t\t\tother = other.parentNode;\n\t\t}\n\t\treturn other === this;\n\t}\n\n\t/**\n\t *\n\t *\n\t * @param namespace - The namespace to look up\n\t *\n\t * @returns The prefix for the given namespace, or null if none was found\n\t */\n\tpublic abstract lookupPrefix(namespace: string | null): string | null;\n\n\t/**\n\t * Returns the namespace for the given prefix.\n\t *\n\t * @param prefix - The prefix to look up\n\t *\n\t * @returns The namespace for the given prefix, or null if the prefix is not defined\n\t */\n\tpublic abstract lookupNamespaceURI(prefix: string | null): string | null;\n\n\t/**\n\t * Return true if defaultNamespace is the same as namespace, and false otherwise.\n\t *\n\t * @param namespace - The namespace to check\n\t *\n\t * @returns Whether namespace is the default namespace\n\t */\n\tpublic isDefaultNamespace(namespace: string | null): boolean {\n\t\texpectArity(arguments, 1);\n\t\tnamespace = asNullableString(namespace);\n\n\t\t// 1. If namespace is the empty string, then set it to null.\n\t\tif (namespace === '') {\n\t\t\tnamespace = null;\n\t\t}\n\n\t\t// 2. Let defaultNamespace be the result of running locate a namespace for this\n\t\t// using null.\n\t\tconst defaultNamespace = this.lookupNamespaceURI(null);\n\n\t\t// 3. Return true if defaultNamespace is the same as namespace, and false otherwise.\n\t\treturn defaultNamespace === namespace;\n\t}\n\n\t/**\n\t * Inserts the specified node before child within this.\n\t *\n\t * If child is null, the new node is appended after the last child node of the current node.\n\t *\n\t * @param node  - Node to insert\n\t * @param child - Childnode of the current node before which to insert, or null to append\n\t *                newNode at the end\n\t *\n\t * @returns The node that was inserted\n\t */\n\tpublic insertBefore<TNode extends Node>(node: TNode, child: Node | null): TNode {\n\t\texpectArity(arguments, 2);\n\t\tnode = asObject(node, Node);\n\t\tchild = asNullableObject(child, Node);\n\n\t\treturn preInsertNode(node, this, child);\n\t}\n\n\t/**\n\t * Adds node to the end of the list of children of this.\n\t *\n\t * If the node already exists it is removed from its current parent node, then added.\n\t *\n\t * @param node - Node to append\n\t *\n\t * @returns The node that was inserted\n\t */\n\tpublic appendChild<TNode extends Node>(node: TNode): TNode {\n\t\texpectArity(arguments, 1);\n\t\tnode = asObject(node, Node);\n\n\t\treturn appendNode(node, this);\n\t}\n\n\t/**\n\t * Replaces child with node within this and returns child.\n\t *\n\t * @param node  - Node to insert\n\t * @param child - Node to remove\n\t *\n\t * @returns The node that was removed\n\t */\n\tpublic replaceChild<TChild extends Node>(node: Node, child: TChild): TChild {\n\t\texpectArity(arguments, 2);\n\t\tnode = asObject(node, Node);\n\t\tchild = asObject(child, Node);\n\n\t\treturn replaceChildWithNode(child, node, this);\n\t}\n\n\t/**\n\t * Removes child from this and returns the removed node.\n\t *\n\t * @param child - Child of the current node to remove\n\t *\n\t * @returns The node that was removed\n\t */\n\tpublic removeChild<TChild extends Node>(child: TChild): TChild {\n\t\texpectArity(arguments, 1);\n\t\tchild = asObject(child, Node);\n\n\t\treturn preRemoveChild(child, this);\n\t}\n\n\t/**\n\t * (non-standard) Creates a copy of this, not including its children.\n\t *\n\t * @param document - The node document to associate with the copy\n\t *\n\t * @returns A shallow copy of this\n\t */\n\tpublic abstract _copy(document: Document): Node;\n}\n\nNode.prototype.ELEMENT_NODE = NodeType.ELEMENT_NODE;\nNode.prototype.ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE;\nNode.prototype.TEXT_NODE = NodeType.TEXT_NODE;\nNode.prototype.CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE;\nNode.prototype.ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE; // legacy\nNode.prototype.ENTITY_NODE = NodeType.ENTITY_NODE; // legacy\nNode.prototype.PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE;\nNode.prototype.COMMENT_NODE = NodeType.COMMENT_NODE;\nNode.prototype.DOCUMENT_NODE = NodeType.DOCUMENT_NODE;\nNode.prototype.DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE;\nNode.prototype.DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE;\nNode.prototype.NOTATION_NODE = NodeType.NOTATION_NODE; // legacy\n","import Attr from '../Attr';\nimport Element from '../Element';\nimport queueMutationRecord from '../mutation-observer/queueMutationRecord';\n\n/**\n * To handle attribute changes for an attribute attribute with element, oldValue, and newValue, run\n * these steps:\n *\n * @param attribute - The attribute that is being changed\n * @param element   - The element that has the attribute\n * @param oldValue  - The old value for the attribute\n * @param newValue  - The new value for the attribute\n */\nexport function handleAttributeChanges(\n\tattribute: Attr,\n\telement: Element,\n\toldValue: string | null,\n\tnewValue: string | null\n): void {\n\t// 1. Queue a mutation record of \"attributes\" for element with attribute’s local name,\n\t// attribute's namespace, oldValue, « », « », null, and null.\n\tqueueMutationRecord('attributes', element, {\n\t\tname: attribute.localName,\n\t\tnamespace: attribute.namespaceURI,\n\t\toldValue,\n\t});\n\n\t// 2. If element is custom, then enqueue a custom element callback reaction with element,\n\t// callback name \"attributeChangedCallback\", and an argument list containing attribute’s local\n\t// name, attribute’s value, value, and attribute’s namespace.\n\t// (custom elements not implemented)\n\n\t// 3. Run the attribute change steps with element, attribute’s local name, oldValue, newValue,\n\t// and attribute’s namespace.\n\t// (attribute change steps not implemented)\n}\n\n/**\n * To change an attribute attribute to value, run these steps:\n *\n * @param attribute - The attribute to change\n * @param value     - The new value for the attribute\n */\nexport function changeAttribute(attribute: Attr, value: string): void {\n\t// 1. Handle attribute changes for attribute with attribute’s element, attribute’s value, and\n\t// value.\n\thandleAttributeChanges(attribute, attribute.ownerElement!, attribute.value, value);\n\n\t// 2. Set attribute’s value to value.\n\t(attribute as any)._value = value;\n}\n\n/**\n * To append an attribute attribute to an element element, run these steps:\n *\n * @param attribute - The attribute to append\n * @param element   - The element to append attribute to\n */\nexport function appendAttribute(attribute: Attr, element: Element): void {\n\t// 1. Handle attribute changes for attribute with element, null and attribute's value.\n\thandleAttributeChanges(attribute, element, null, attribute.value);\n\n\t// 2. Append attribute to element’s attribute list.\n\telement.attributes.push(attribute);\n\n\t// 3. Set attribute’s element to element.\n\tattribute.ownerElement = element;\n}\n\n/**\n * To remove an attribute attribute, run these steps:\n *\n * @param attribute - The attribute to remove\n */\nexport function removeAttribute(attribute: Attr): void {\n\tconst attributeElement = attribute.ownerElement!;\n\t// 1. Handle attribute changes for attribute with attribute’s element, attribute’s value, and\n\t// null.\n\thandleAttributeChanges(attribute, attributeElement, attribute.value, null);\n\n\t// 2. Remove attribute from attribute's element’s attribute list.\n\tattributeElement.attributes.splice(attributeElement.attributes.indexOf(attribute), 1);\n\n\t// 3. Set attribute’s element to null.\n\tattribute.ownerElement = null;\n}\n\n/**\n * To replace an attribute oldAttr with an attribute newAttr, run these steps:\n *\n * @param oldAttr - The attribute to replace\n * @param newAttr - The attribute to replace oldAttr with\n */\nexport function replaceAttribute(oldAttr: Attr, newAttr: Attr): void {\n\tconst oldAttrElement = oldAttr.ownerElement!;\n\t// 1. Handle attribute changes for oldAttr with oldAttr’s element, oldAttr’s value,\n\t// and newAttr’s value.\n\thandleAttributeChanges(oldAttr, oldAttrElement, oldAttr.value, newAttr.value);\n\n\t// 4. Replace oldAttr by newAttr in element’s attribute list.\n\toldAttrElement.attributes.splice(oldAttrElement.attributes.indexOf(oldAttr), 1, newAttr);\n\n\t// 5. Set newAttr’s element to oldAttr's element.\n\tnewAttr.ownerElement = oldAttrElement;\n\n\t// 6. Set oldAttr’s element to null.\n\toldAttr.ownerElement = null;\n}\n","import Document from './Document';\nimport Element from './Element';\nimport Node from './Node';\nimport { getContext } from './context/Context';\nimport { changeAttribute } from './util/attrMutations';\nimport { expectArity } from './util/errorHelpers';\nimport { NodeType } from './util/NodeType';\nimport { ifNullActAsIfEmptyString } from './util/typeHelpers';\n\n/**\n * 3.9.2. Interface Attr\n *\n * @public\n */\nexport default class Attr extends Node {\n\t// Node\n\n\tpublic get nodeType(): number {\n\t\treturn NodeType.ATTRIBUTE_NODE;\n\t}\n\n\tpublic get nodeName(): string {\n\t\t// Return the qualified name\n\t\treturn this.name;\n\t}\n\n\tpublic get nodeValue(): string | null {\n\t\treturn this._value;\n\t}\n\n\tpublic set nodeValue(newValue: string | null) {\n\t\tnewValue = ifNullActAsIfEmptyString(newValue);\n\n\t\t// Set an existing attribute value with this and new value.\n\t\tsetExistingAttributeValue(this, newValue);\n\t}\n\n\tpublic get textContent(): string | null {\n\t\treturn this._value;\n\t}\n\n\tpublic set textContent(newValue: string | null) {\n\t\tnewValue = ifNullActAsIfEmptyString(newValue);\n\n\t\t// Set an existing attribute value with this and new value.\n\t\tsetExistingAttributeValue(this, newValue);\n\t}\n\n\tpublic lookupPrefix(namespace: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\n\t\t// 1. If namespace is null or the empty string, then return null.\n\t\t// (not necessary due to recursion)\n\n\t\t// 2. Switch on this:\n\t\t// Attr - Return the result of locating a namespace prefix for its element, if its element\n\t\t// is non-null, and null otherwise.\n\t\tif (this.ownerElement !== null) {\n\t\t\treturn this.ownerElement.lookupPrefix(namespace);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic lookupNamespaceURI(prefix: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\n\t\t// 1. If prefix is the empty string, then set it to null.\n\t\t// (not necessary due to recursion)\n\n\t\t// 2. Return the result of running locate a namespace for this using prefix.\n\n\t\t// To locate a namespace for a node using prefix, switch on node: Attr\n\t\t// 1. If its element is null, then return null.\n\t\tif (this.ownerElement === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// 2. Return the result of running locate a namespace on its element using prefix.\n\t\treturn this.ownerElement.lookupNamespaceURI(prefix);\n\t}\n\n\t// Attr\n\n\tpublic readonly namespaceURI: string | null;\n\tpublic readonly prefix: string | null;\n\tpublic readonly localName: string;\n\tpublic readonly name: string;\n\n\tprivate _value: string;\n\n\tpublic get value(): string {\n\t\treturn this._value;\n\t}\n\n\tpublic set value(value: string) {\n\t\tsetExistingAttributeValue(this, value);\n\t}\n\n\tpublic ownerElement: Element | null;\n\n\t/**\n\t * (non-standard) use Document#createAttribute(NS) or Element#setAttribute(NS) to create\n\t * attribute nodes\n\t *\n\t * @param namespace - The namespace URI for the attribute\n\t * @param prefix    - The prefix for the attribute\n\t * @param localName - The local name for the attribute\n\t * @param value     - The value for the attribute\n\t * @param element   - The element for the attribute, or null if the attribute is not attached to\n\t *                    an element\n\t */\n\tconstructor(\n\t\tnamespace: string | null,\n\t\tprefix: string | null,\n\t\tlocalName: string,\n\t\tvalue: string,\n\t\telement: Element | null\n\t) {\n\t\tsuper();\n\n\t\tthis.namespaceURI = namespace;\n\t\tthis.prefix = prefix;\n\t\tthis.localName = localName;\n\t\tthis.name = prefix === null ? localName : `${prefix}:${localName}`;\n\t\tthis._value = value;\n\t\tthis.ownerElement = element;\n\t}\n\n\t/**\n\t * (non-standard) Creates a copy of this, not including its children.\n\t *\n\t * @param document - The node document to associate with the copy\n\t *\n\t * @returns A shallow copy of this\n\t */\n\tpublic _copy(document: Document): Attr {\n\t\t// Set copy’s namespace, namespace prefix, local name, and value, to those of node.\n\t\tconst context = getContext(document);\n\t\tconst copy = new context.Attr(\n\t\t\tthis.namespaceURI,\n\t\t\tthis.prefix,\n\t\t\tthis.localName,\n\t\t\tthis.value,\n\t\t\tnull\n\t\t);\n\t\tcopy.ownerDocument = document;\n\t\treturn copy;\n\t}\n}\n\n/**\n * To set an existing attribute value, given an attribute attribute and string value, run these\n * steps:\n *\n * @param attribute - The attribute to set the value of\n * @param value     - The new value for attribute\n */\nfunction setExistingAttributeValue(attribute: Attr, value: string) {\n\tvalue = String(value);\n\n\t// 1. If attribute’s element is null, then set attribute’s value to value.\n\tconst element = attribute.ownerElement;\n\tif (element === null) {\n\t\t(attribute as any)._value = value;\n\t} else {\n\t\t// 2. Otherwise, change attribute to value.\n\t\tchangeAttribute(attribute, value);\n\t}\n}\n","import {\n\tNonDocumentTypeChildNode,\n\tChildNode,\n\tgetNextElementSibling,\n\tgetPreviousElementSibling,\n} from './mixins';\nimport Element from './Element';\nimport Node from './Node';\nimport { getContext } from './context/Context';\nimport queueMutationRecord from './mutation-observer/queueMutationRecord';\nimport { expectArity, throwIndexSizeError } from './util/errorHelpers';\nimport {\n\tasUnsignedLong,\n\tifNullActAsIfEmptyString,\n\tlegacyNullToEmptyString,\n} from './util/typeHelpers';\nimport {\n\tinsertNodesBefore,\n\tinsertNodesAfter,\n\treplaceWithNodes,\n\tremoveFromParent,\n} from './util/mutationAlgorithms';\n\n/**\n * 3.10. Interface CharacterData\n *\n * @public\n */\nexport default abstract class CharacterData\n\textends Node\n\timplements NonDocumentTypeChildNode, ChildNode\n{\n\t// Node\n\n\tpublic get nodeValue(): string | null {\n\t\treturn this._data;\n\t}\n\n\tpublic set nodeValue(newValue: string | null) {\n\t\tnewValue = ifNullActAsIfEmptyString(newValue);\n\n\t\t// Set an existing attribute value with this and new value.\n\t\treplaceData(this, 0, this.length, newValue);\n\t}\n\n\tpublic get textContent(): string | null {\n\t\treturn this._data;\n\t}\n\n\tpublic set textContent(newValue: string | null) {\n\t\tnewValue = ifNullActAsIfEmptyString(newValue);\n\n\t\t// Set an existing attribute value with this and new value.\n\t\treplaceData(this, 0, this.length, newValue);\n\t}\n\n\tpublic lookupPrefix(namespace: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\n\t\t// 1. If namespace is null or the empty string, then return null.\n\t\t// (not necessary due to recursion)\n\n\t\t// 2. Switch on this:\n\t\t// Any other node - Return the result of locating a namespace prefix for its parent element,\n\t\t// if its parent element is non-null, and null otherwise.\n\t\tconst parentElement = this.parentElement;\n\t\tif (parentElement !== null) {\n\t\t\treturn parentElement.lookupPrefix(namespace);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic lookupNamespaceURI(prefix: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\n\t\t// 1. If prefix is the empty string, then set it to null.\n\t\t// (not necessary due to recursion)\n\n\t\t// 2. Return the result of running locate a namespace for this using prefix.\n\n\t\t// To locate a namespace for a node using prefix, switch on node: Any other node\n\t\t// 1. If its parent element is null, then return null.\n\t\tconst parentElement = this.parentElement;\n\t\tif (parentElement === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// 2. Return the result of running locate a namespace on its parent element using prefix.\n\t\treturn parentElement.lookupNamespaceURI(prefix);\n\t}\n\n\t// ChildNode\n\n\tpublic before(...nodes: (Node | string)[]): void {\n\t\tinsertNodesBefore(this, nodes);\n\t}\n\n\tpublic after(...nodes: (Node | string)[]): void {\n\t\tinsertNodesAfter(this, nodes);\n\t}\n\n\tpublic replaceWith(...nodes: (Node | string)[]): void {\n\t\treplaceWithNodes(this, nodes);\n\t}\n\n\tpublic remove(): void {\n\t\tremoveFromParent(this);\n\t}\n\n\t// NonDocumentTypeChildNode\n\n\tpublic get previousElementSibling(): Element | null {\n\t\treturn getPreviousElementSibling(this);\n\t}\n\n\tpublic get nextElementSibling(): Element | null {\n\t\treturn getNextElementSibling(this);\n\t}\n\n\t// CharacterData\n\n\t/**\n\t * Each node inheriting from the CharacterData interface has an associated mutable string called\n\t * data.\n\t */\n\tprotected _data: string;\n\n\tpublic get data(): string {\n\t\treturn this._data;\n\t}\n\n\tpublic set data(newValue: string) {\n\t\t// [LegacyNullToEmptyString]\n\t\tnewValue = legacyNullToEmptyString(newValue);\n\n\t\t// replace data with node this, offset 0, count this’s length, and data\n\t\t// new value.\n\t\treplaceData(this, 0, this.length, newValue);\n\t}\n\n\tpublic get length(): number {\n\t\treturn this.data.length;\n\t}\n\n\t/**\n\t * (non-standard) CharacterData should never be instantiated directly.\n\t *\n\t * @param data - The data to associate with the node\n\t */\n\tprotected constructor(data: string) {\n\t\tsuper();\n\t\tthis._data = String(data);\n\t}\n\n\t/**\n\t * Returns a substring of the node's data.\n\t *\n\t * @param offset - Offset at which to start the substring\n\t * @param count  - The number of code units to return\n\t *\n\t * @returns The specified substring\n\t */\n\tpublic substringData(offset: number, count: number): string {\n\t\texpectArity(arguments, 2);\n\t\treturn substringData(this, offset, count);\n\t}\n\n\t/**\n\t * Appends data to the node's data.\n\t *\n\t * @param data - Data to append\n\t */\n\tpublic appendData(data: string): void {\n\t\texpectArity(arguments, 1);\n\t\treplaceData(this, this.length, 0, data);\n\t}\n\n\t/**\n\t * Inserts data at the specified position in the node's data.\n\t *\n\t * @param offset - Offset at which to insert\n\t * @param data   - Data to insert\n\t */\n\tpublic insertData(offset: number, data: string): void {\n\t\texpectArity(arguments, 1);\n\t\treplaceData(this, offset, 0, data);\n\t}\n\n\t/**\n\t * Deletes data from the specified position.\n\t *\n\t * @param offset - Offset at which to delete\n\t * @param count  - Number of code units to delete\n\t */\n\tpublic deleteData(offset: number, count: number): void {\n\t\texpectArity(arguments, 2);\n\t\treplaceData(this, offset, count, '');\n\t}\n\n\t/**\n\t * Replaces data at the specified position.\n\t *\n\t * @param offset - Offset at which to replace\n\t * @param count  - Number of code units to remove\n\t * @param data   - Data to insert\n\t */\n\tpublic replaceData(offset: number, count: number, data: string): void {\n\t\texpectArity(arguments, 3);\n\t\treplaceData(this, offset, count, data);\n\t}\n}\n\n/**\n * To replace data of node node with offset offset, count count, and data data, run these steps:\n *\n * @param node   - The node to replace data on\n * @param offset - The offset at which to start replacing\n * @param count  - The number of code units to replace\n * @param data   - The data to insert in place of the removed data\n */\nexport function replaceData(\n\tnode: CharacterData,\n\toffset: number,\n\tcount: number,\n\tdata: string\n): void {\n\t// Match spec data types\n\toffset = asUnsignedLong(offset);\n\tcount = asUnsignedLong(count);\n\n\t// 1. Let length be node’s length.\n\tconst length = node.length;\n\n\t// 2. If offset is greater than length, then throw an IndexSizeError.\n\tif (offset > length) {\n\t\tthrowIndexSizeError(\"can not replace data past the node's length\");\n\t}\n\n\t// 3. If offset plus count is greater than length, then set count to length minus offset.\n\tif (offset + count > length) {\n\t\tcount = length - offset;\n\t}\n\n\t// 4. Queue a mutation record of \"characterData\" for node with null, null, node's data, « »,\n\t// « », null, and null.\n\tqueueMutationRecord('characterData', node, {\n\t\toldValue: node.data,\n\t});\n\n\t// 5. Insert data into node’s data after offset code units.\n\t// 6. Let delete offset be offset + data's length.\n\t// 7. Starting from delete offset code units, remove count code units from node’s data.\n\tconst nodeData = node.data;\n\tconst newData = nodeData.substring(0, offset) + data + nodeData.substring(offset + count);\n\t(node as any)._data = newData;\n\n\tconst context = getContext(node);\n\tcontext.forEachRange((range) => {\n\t\t// 8. For each live range whose start node is node and start offset is greater than offset\n\t\t// but less than or equal to offset plus count, set its start offset to offset.\n\t\tif (\n\t\t\trange.startContainer === node &&\n\t\t\trange.startOffset > offset &&\n\t\t\trange.startOffset <= offset + count\n\t\t) {\n\t\t\trange.startOffset = offset;\n\t\t}\n\n\t\t// 9. For each live range whose end node is node and end offset is greater than offset but\n\t\t// less than or equal to offset plus count, set its end offset to offset.\n\t\tif (\n\t\t\trange.endContainer === node &&\n\t\t\trange.endOffset > offset &&\n\t\t\trange.endOffset <= offset + count\n\t\t) {\n\t\t\trange.endOffset = offset;\n\t\t}\n\n\t\t// 10. For each live range whose start node is node and start offset is greater than offset\n\t\t// plus count, increase its start offset by data's length and decrease it by count.\n\t\tif (range.startContainer === node && range.startOffset > offset + count) {\n\t\t\trange.startOffset = range.startOffset + data.length - count;\n\t\t}\n\n\t\t// 11. For each live range whose end node is node and end offset is greater than offset plus\n\t\t// count, increase its end offset by data's length and decrease it by count.\n\t\tif (range.endContainer === node && range.endOffset > offset + count) {\n\t\t\trange.endOffset = range.endOffset + data.length - count;\n\t\t}\n\t});\n\n\t// 12. If node's parent is non-null, then run the children changed steps for node’s parent.\n\t// (children changed steps not implemented)\n}\n\n/**\n * To substring data with node node, offset offset, and count count, run these steps:\n *\n * @param node   - The node to get data from\n * @param offset - The offset at which to start the substring\n * @param count  - The number of code units to include in the substring\n *\n * @returns The requested substring\n */\nexport function substringData(node: CharacterData, offset: number, count: number): string {\n\t// Match spec data types\n\toffset = asUnsignedLong(offset);\n\tcount = asUnsignedLong(count);\n\n\t// 1. Let length be node’s length.\n\tconst length = node.length;\n\n\t// 2. If offset is greater than length, then throw an IndexSizeError.\n\tif (offset > length) {\n\t\tthrowIndexSizeError(\"can not substring data past the node's length\");\n\t}\n\n\t// 3. If offset plus count is greater than length, return a string whose value is the code units\n\t// from the offsetth code unit to the end of node’s data, and then return.\n\tif (offset + count > length) {\n\t\treturn node.data.substring(offset);\n\t}\n\n\t// 4. Return a string whose value is the code units from the offsetth code unit to the\n\t// offset+countth code unit in node’s data.\n\treturn node.data.substring(offset, offset + count);\n}\n","import { replaceData, substringData, default as CharacterData } from './CharacterData';\nimport Document from './Document';\nimport { getContext } from './context/Context';\nimport { expectArity, throwIndexSizeError } from './util/errorHelpers';\nimport { insertNode } from './util/mutationAlgorithms';\nimport { NodeType, isNodeOfType } from './util/NodeType';\nimport { getNodeIndex } from './util/treeHelpers';\nimport { asUnsignedLong } from './util/typeHelpers';\n\n/**\n * 3.11. Interface Text\n *\n * @public\n */\nexport default class Text extends CharacterData {\n\t// Node\n\n\tpublic get nodeType(): number {\n\t\treturn NodeType.TEXT_NODE;\n\t}\n\n\tpublic get nodeName(): string {\n\t\treturn '#text';\n\t}\n\n\t// Text\n\n\t/**\n\t * Returns a new Text node whose data is data and node document is current global object’s\n\t * associated Document.\n\t *\n\t * @param data - The data for the new text node\n\t */\n\tconstructor(data: string = '') {\n\t\tsuper(data);\n\n\t\tconst context = getContext(this);\n\t\tthis.ownerDocument = context.document;\n\t}\n\n\t/**\n\t * Splits data at the given offset and returns the remainder as Text node.\n\t *\n\t * @param offset - The offset at which to split\n\t *\n\t * @returns a text node containing the second half of the split node's data\n\t */\n\tpublic splitText(offset: number): Text {\n\t\texpectArity(arguments, 1);\n\t\toffset = asUnsignedLong(offset);\n\n\t\treturn splitText(this, offset);\n\t}\n\n\t/**\n\t * (non-standard) Creates a copy of this, not including its children.\n\t *\n\t * @param document - The node document to associate with the copy\n\t *\n\t * @returns A shallow copy of this\n\t */\n\tpublic _copy(document: Document): Text {\n\t\t// Set copy’s data, to that of node.\n\t\tconst context = getContext(document);\n\t\tconst copy = new context.Text(this.data);\n\t\tcopy.ownerDocument = document;\n\t\treturn copy;\n\t}\n\n\t/**\n\t * Returns the combined data of all direct Text node siblings.\n\t *\n\t * @returns the concatenation of the data of the contiguous Text nodes of this, in\n\t *          tree order.\n\t */\n\tpublic get wholeText(): string {\n\t\tconst allData: string[] = [this.data];\n\n\t\tlet previousSibling = this.previousSibling;\n\t\twhile (\n\t\t\tpreviousSibling !== null &&\n\t\t\tisNodeOfType(previousSibling, NodeType.TEXT_NODE, NodeType.CDATA_SECTION_NODE)\n\t\t) {\n\t\t\tconst data = (previousSibling as Text).data;\n\t\t\tallData.unshift(data);\n\t\t\tpreviousSibling = previousSibling.previousSibling;\n\t\t}\n\n\t\tlet nextSibling = this.nextSibling;\n\t\twhile (\n\t\t\tnextSibling !== null &&\n\t\t\tisNodeOfType(nextSibling, NodeType.TEXT_NODE, NodeType.CDATA_SECTION_NODE)\n\t\t) {\n\t\t\tconst data = (nextSibling as Text).data;\n\t\t\tallData.push(data);\n\t\t\tnextSibling = nextSibling.nextSibling;\n\t\t}\n\n\t\treturn allData.join('');\n\t}\n}\n\n/**\n * To split a Text node node with offset offset, run these steps:\n *\n * @param node   - The text node to split\n * @param offset - The offset to split at\n *\n * @returns a text node containing the second half of the split node's data\n */\nfunction splitText(node: Text, offset: number): Text {\n\t// 1. Let length be node’s length.\n\tconst length = node.length;\n\n\t// 2. If offset is greater than length, then throw an IndexSizeError.\n\tif (offset > length) {\n\t\tthrowIndexSizeError(\"can not split past the node's length\");\n\t}\n\n\t// 3. Let count be length minus offset.\n\tconst count = length - offset;\n\n\t// 4. Let new data be the result of substringing data with node node, offset offset, and count\n\t// count.\n\tconst newData = substringData(node, offset, count);\n\n\t// 5. Let new node be a new Text node, with the same node document as node. Set new node’s data\n\t// to new data.\n\tconst context = getContext(node);\n\tconst newNode = new context.Text(newData);\n\tnewNode.ownerDocument = node.ownerDocument;\n\n\t// 6. Let parent be node’s parent.\n\tconst parent = node.parentNode;\n\n\t// 7. If parent is non-null, then:\n\tif (parent !== null) {\n\t\t// 7.1. Insert new node into parent before node’s next sibling.\n\t\tinsertNode(newNode, parent, node.nextSibling);\n\n\t\tconst indexOfNodePlusOne = getNodeIndex(node) + 1;\n\t\tconst context = getContext(node);\n\t\tcontext.forEachRange((range) => {\n\t\t\t// 7.2. For each live range whose start node is node and start offset is greater than\n\t\t\t// offset, set its start node to new node and decrease its start offset by offset.\n\t\t\tif (range.startContainer === node && range.startOffset > offset) {\n\t\t\t\trange.startContainer = newNode;\n\t\t\t\trange.startOffset -= offset;\n\t\t\t}\n\n\t\t\t// 7.3. For each live range whose end node is node and end offset is greater than\n\t\t\t// offset, set its end node to new node and decrease its end offset by offset.\n\t\t\tif (range.endContainer === node && range.endOffset > offset) {\n\t\t\t\trange.endContainer = newNode;\n\t\t\t\trange.endOffset -= offset;\n\t\t\t}\n\n\t\t\t// 7.4. For each live range whose start node is parent and start offset is equal to the\n\t\t\t// index of node + 1, increase its start offset by one.\n\t\t\tif (range.startContainer === parent && range.startOffset === indexOfNodePlusOne) {\n\t\t\t\trange.startOffset += 1;\n\t\t\t}\n\n\t\t\t// 7.5. For each live range whose end node is parent and end offset is equal to the\n\t\t\t// index of node + 1, increase its end offset by one.\n\t\t\tif (range.endContainer === parent && range.endOffset === indexOfNodePlusOne) {\n\t\t\t\trange.endOffset += 1;\n\t\t\t}\n\t\t});\n\t}\n\n\t// 8. Replace data with node node, offset offset, count count, and data the empty string.\n\treplaceData(node, offset, count, '');\n\n\t// 9. Return new node.\n\treturn newNode;\n}\n","import Document from './Document';\nimport Text from './Text';\nimport { getContext } from './context/Context';\nimport { NodeType } from './util/NodeType';\n\n/**\n * @public\n */\nexport default class CDATASection extends Text {\n\t// Node\n\n\tpublic get nodeType(): number {\n\t\treturn NodeType.CDATA_SECTION_NODE;\n\t}\n\n\tpublic get nodeName(): string {\n\t\treturn '#cdata-section';\n\t}\n\n\t// CDATASection\n\n\t/**\n\t * (non-standard) use Document#createCDATASection to create a CDATA section.\n\t *\n\t * @param data - The data for the node\n\t */\n\tconstructor(data: string) {\n\t\tsuper(data);\n\t}\n\n\t/**\n\t * (non-standard) Creates a copy of this, not including its children.\n\t *\n\t * @param document - The node document to associate with the copy\n\t *\n\t * @returns A shallow copy of this\n\t */\n\tpublic _copy(document: Document): CDATASection {\n\t\t// Set copy’s data, to that of node.\n\t\tconst context = getContext(document);\n\t\tconst copy = new context.CDATASection(this.data);\n\t\tcopy.ownerDocument = document;\n\t\treturn copy;\n\t}\n}\n","import CharacterData from './CharacterData';\nimport Document from './Document';\nimport { getContext } from './context/Context';\nimport { NodeType } from './util/NodeType';\n\n/**\n * @public\n */\nexport default class Comment extends CharacterData {\n\t// Node\n\n\tpublic get nodeType(): number {\n\t\treturn NodeType.COMMENT_NODE;\n\t}\n\n\tpublic get nodeName(): string {\n\t\treturn '#comment';\n\t}\n\n\t// Comment\n\n\t/**\n\t * Returns a new Comment node whose data is data and node document is current global object’s\n\t * associated Document.\n\t *\n\t * @param data - The data for the new comment\n\t */\n\tconstructor(data: string = '') {\n\t\tsuper(data);\n\n\t\tconst context = getContext(this);\n\t\tthis.ownerDocument = context.document;\n\t}\n\n\t/**\n\t * (non-standard) Creates a copy of this, not including its children.\n\t *\n\t * @param document - The node document to associate with the copy\n\t *\n\t * @returns A shallow copy of this\n\t */\n\tpublic _copy(document: Document): Comment {\n\t\t// Set copy’s data, to that of node.\n\t\tconst context = getContext(document);\n\t\tconst copy = new context.Comment(this.data);\n\t\tcopy.ownerDocument = document;\n\t\treturn copy;\n\t}\n}\n","import { ChildNode } from './mixins';\nimport Document from './Document';\nimport Node from './Node';\nimport { getContext } from './context/Context';\nimport { expectArity } from './util/errorHelpers';\nimport { NodeType } from './util/NodeType';\nimport {\n\tinsertNodesBefore,\n\tinsertNodesAfter,\n\treplaceWithNodes,\n\tremoveFromParent,\n} from './util/mutationAlgorithms';\n\n/**\n * @public\n */\nexport default class DocumentType extends Node implements ChildNode {\n\t// Node\n\n\tpublic get nodeType(): number {\n\t\treturn NodeType.DOCUMENT_TYPE_NODE;\n\t}\n\n\tpublic get nodeName(): string {\n\t\treturn this.name;\n\t}\n\n\tpublic get nodeValue(): string | null {\n\t\treturn null;\n\t}\n\n\tpublic set nodeValue(_newValue: string | null) {\n\t\t// Do nothing.\n\t}\n\n\tpublic get textContent(): string | null {\n\t\treturn null;\n\t}\n\n\tpublic set textContent(_newValue: string | null) {\n\t\t// Do nothing.\n\t}\n\n\tpublic lookupPrefix(namespace: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\n\t\t// 1. If namespace is null or the empty string, then return null.\n\t\t// (not necessary due to return value)\n\n\t\t// 2. Switch on this:\n\t\t// DocumentType - Return null\n\t\treturn null;\n\t}\n\n\tpublic lookupNamespaceURI(prefix: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\n\t\t// 1. If prefix is the empty string, then set it to null.\n\t\t// (not necessary due to return value)\n\n\t\t// 2. Return the result of running locate a namespace for this using prefix.\n\n\t\t// To locate a namespace for a node using prefix, switch on node: DocumentType\n\t\t// Return null.\n\t\treturn null;\n\t}\n\n\t// ChildNode\n\n\tpublic before(...nodes: (Node | string)[]): void {\n\t\tinsertNodesBefore(this, nodes);\n\t}\n\n\tpublic after(...nodes: (Node | string)[]): void {\n\t\tinsertNodesAfter(this, nodes);\n\t}\n\n\tpublic replaceWith(...nodes: (Node | string)[]): void {\n\t\treplaceWithNodes(this, nodes);\n\t}\n\n\tpublic remove(): void {\n\t\tremoveFromParent(this);\n\t}\n\n\t// DocumentType\n\n\t/**\n\t * The name of the doctype.\n\t */\n\tpublic name: string;\n\n\t/**\n\t * The public ID of the doctype.\n\t */\n\tpublic publicId: string;\n\n\t/**\n\t * The system ID of the doctype.\n\t */\n\tpublic systemId: string;\n\n\t/**\n\t * (non-standard) Use DOMImplementation#createDocumentType instead.\n\t *\n\t * @param name     - The name of the doctype\n\t * @param publicId - The public ID of the doctype\n\t * @param systemId - The system ID of the doctype\n\t */\n\tconstructor(name: string, publicId: string = '', systemId: string = '') {\n\t\tsuper();\n\n\t\tthis.name = name;\n\t\tthis.publicId = publicId;\n\t\tthis.systemId = systemId;\n\t}\n\n\t/**\n\t * (non-standard) Creates a copy of this, not including its children.\n\t *\n\t * @param document - The node document to associate with the copy\n\t *\n\t * @returns A shallow copy of this\n\t */\n\tpublic _copy(document: Document): DocumentType {\n\t\t// Set copy’s name, public ID, and system ID, to those of node.\n\t\tconst context = getContext(document);\n\t\tconst copy = new context.DocumentType(this.name, this.publicId, this.systemId);\n\t\tcopy.ownerDocument = document;\n\t\treturn copy;\n\t}\n}\n","import Element from '../Element';\nimport Node from '../Node';\nimport { throwInvalidCharacterError, throwNamespaceError } from './errorHelpers';\n\n// 1.5. Namespaces\n\nexport const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\nexport const XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';\nexport const XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';\n\n/*\n// NAME_REGEX_XML_1_0_FIFTH_EDITION generated using regenerate:\nconst regenerate = require('regenerate');\n\nconst NameStartChar = regenerate()\n\t.add(':')\n\t.addRange('A', 'Z')\n\t.add('_')\n\t.addRange('a', 'z')\n\t.addRange(0xC0, 0xD6)\n\t.addRange(0xD8, 0xF6)\n\t.addRange(0xF8, 0x2FF)\n\t.addRange(0x370, 0x37D)\n\t.addRange(0x37F, 0x1FFF)\n\t.addRange(0x200C, 0x200D)\n\t.addRange(0x2070, 0x218F)\n\t.addRange(0x2C00, 0x2FEF)\n\t.addRange(0x3001, 0xD7FF)\n\t.addRange(0xF900, 0xFDCF)\n\t.addRange(0xFDF0, 0xFFFD)\n\t.addRange(0x10000, 0xEFFFF);\n\nconst NameChar = NameStartChar.clone()\n\t.add('-')\n\t.add('.')\n\t.addRange('0', '9')\n\t.add(0xB7)\n\t.addRange(0x0300, 0x036F)\n\t.addRange(0x203F, 0x2040);\n\nreturn `^(?:${NameStartChar.toString()})(?:${NameChar.toString()})*$`;\n*/\nconst NAME_REGEX_XML_1_0_FIFTH_EDITION =\n\t/^(?:[:A-Z_a-z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])(?:[\\-\\.0-:A-Z_a-z\\xB7\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u203F\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])*$/;\n\n/**\n * Returns true if name matches the Name production.\n *\n * @param name - The name to check\n *\n * @returns true if name matches Name, otherwise false\n */\nexport function matchesNameProduction(name: string): boolean {\n\treturn NAME_REGEX_XML_1_0_FIFTH_EDITION.test(name);\n}\n\n/**\n * @param name - The name to check\n *\n * @returns True if the name is a valid QName, provided it is also a valid Name, otherwise false\n */\nfunction isValidQName(name: string): boolean {\n\t// (QName is basically NCName | (NCName ':' NCName) where NCName is Name without ':', so here we\n\t// check that name contains at most a single colon, and that the other parts are valid Names)\n\tconst parts = name.split(':');\n\tif (parts.length > 2) {\n\t\t// Too many colons\n\t\treturn false;\n\t}\n\t// Each part should be a valid Name - we already know they don't contain ':', so a valid Name\n\t// here also means a valid NCName\n\treturn parts.every((part) => matchesNameProduction(part));\n}\n\n/**\n * To validate a qualifiedName,\n *\n * @param qualifiedName - Qualified name to validate\n */\nexport function validateQualifiedName(qualifiedName: string): void {\n\t// throw an InvalidCharacterError if qualifiedName does not match the QName production.\n\tif (!isValidQName(qualifiedName)) {\n\t\tthrowInvalidCharacterError('The qualified name is not a valid QName');\n\t}\n}\n\n/**\n * To validate and extract a namespace and qualifiedName, run these steps:\n *\n * @param namespace     - Namespace for the qualified name\n * @param qualifiedName - Qualified name to validate and extract the components of\n *\n * @returns Namespace, prefix and localName\n */\nexport function validateAndExtract(\n\tnamespace: string | null,\n\tqualifiedName: string\n): { namespace: string | null; prefix: string | null; localName: string } {\n\t// 1. If namespace is the empty string, set it to null.\n\tif (namespace === '') {\n\t\tnamespace = null;\n\t}\n\n\t// 2. Validate qualifiedName.\n\tvalidateQualifiedName(qualifiedName);\n\n\t// 3. Let prefix be null.\n\tlet prefix: string | null = null;\n\n\t// 4.  Let localName be qualifiedName.\n\tlet localName = qualifiedName;\n\n\t// 5. If qualifiedName contains a \":\" (U+003A), then split the string on it and set prefix to\n\t// the part before and localName to the part after.\n\tconst index = qualifiedName.indexOf(':');\n\tif (index >= 0) {\n\t\tprefix = qualifiedName.substring(0, index);\n\t\tlocalName = qualifiedName.substring(index + 1);\n\t}\n\n\t// 6. If prefix is non-null and namespace is null, then throw a NamespaceError.\n\tif (prefix !== null && namespace === null) {\n\t\tthrowNamespaceError('Qualified name with prefix can not have a null namespace');\n\t}\n\n\t// 7. If prefix is \"xml\" and namespace is not the XML namespace, then throw a NamespaceError.\n\tif (prefix === 'xml' && namespace !== XML_NAMESPACE) {\n\t\tthrowNamespaceError('xml prefix can only be used for the XML namespace');\n\t}\n\n\t// 8. If either qualifiedName or prefix is \"xmlns\" and namespace is not the XMLNS namespace,\n\t// then throw a NamespaceError.\n\tif ((qualifiedName === 'xmlns' || prefix === 'xmlns') && namespace !== XMLNS_NAMESPACE) {\n\t\tthrowNamespaceError('xmlns prefix or qualifiedName must use the XMLNS namespace');\n\t}\n\n\t// 9. If namespace is the XMLNS namespace and neither qualifiedName nor prefix is \"xmlns\", then\n\t// throw a NamespaceError.\n\tif (namespace === XMLNS_NAMESPACE && qualifiedName !== 'xmlns' && prefix !== 'xmlns') {\n\t\tthrowNamespaceError('xmlns prefix or qualifiedName must be used for the XMLNS namespace');\n\t}\n\n\t// 10. Return namespace, prefix, and localName.\n\treturn { namespace, prefix, localName };\n}\n\n/**\n * To locate a namespace prefix for an element using namespace, run these steps:\n *\n * @param element    - The element at which to start the lookup\n * @param namespace  - Namespace for which to look up the prefix\n *\n * @returns The prefix, or null if there isn't one\n */\nexport function locateNamespacePrefix(element: Element, namespace: string | null): string | null {\n\t// 1. If element’s namespace is namespace and its namespace prefix is non-null, then return its\n\t// namespace prefix.\n\tif (element.namespaceURI === namespace && element.prefix !== null) {\n\t\treturn element.prefix;\n\t}\n\n\t// 2. If element has an attribute whose namespace prefix is \"xmlns\" and value is namespace, then\n\t// return element’s first such attribute’s local name.\n\tconst attr = Array.from(element.attributes).find(\n\t\t(attr) => attr.prefix === 'xmlns' && attr.value === namespace\n\t);\n\tif (attr) {\n\t\treturn attr.localName;\n\t}\n\n\t// 3. If element’s parent element is non-null, then return the result of running locate a\n\t// namespace prefix on that element using namespace.\n\tif (element.parentElement !== null) {\n\t\treturn locateNamespacePrefix(element.parentElement, namespace);\n\t}\n\n\t// 4. Return null.\n\treturn null;\n}\n","import Element from '../Element';\nimport { XML_NAMESPACE, XMLNS_NAMESPACE } from '../util/namespaceHelpers';\n\n// 3.2.1.1.2 The Namespace Prefix Map\n\n/**\n * A namespace prefix map is a map that associates namespaceURI and namespace prefix lists, where\n * namespaceURI values are the map's unique keys (which can include the null value representing no\n * namespace), and ordered lists of associated prefix values are the map's key values. The namespace\n * prefix map will be populated by previously seen namespaceURIs and all their previously\n * encountered prefix associations for a given node and its ancestors.\n *\n * NOTE: the last seen prefix for a given namespaceURI is at the end of its respective list. The\n * list is searched to find potentially matching prefixes, and if no matches are found for the given\n * namespaceURI, then the last prefix in the list is used. See copy a namespace prefix map and\n * retrieve a preferred prefix string for additional details.\n */\nexport class NamespacePrefixMap {\n\tprivate _map: Map<string | null, string[]> = new Map();\n\n\t/**\n\t * To copy a namespace prefix map map means to copy the map's keys into a new empty namespace\n\t * prefix map, and to copy each of the values in the namespace prefix list associated with each\n\t * keys' value into a new list which should be associated with the respective key in the new\n\t * map.\n\t *\n\t * @returns A copy of the namespace prefix map\n\t */\n\tpublic copy(): NamespacePrefixMap {\n\t\tconst copy = new NamespacePrefixMap();\n\t\t// Array.from needed to allow compilation to ES5 targets\n\t\tfor (const [namespace, prefixes] of Array.from(this._map.entries())) {\n\t\t\tcopy._map.set(namespace, prefixes.concat());\n\t\t}\n\t\treturn copy;\n\t}\n\n\t/**\n\t * To retrieve a preferred prefix string preferred prefix from the namespace prefix map map\n\t * given a namespace ns, the user agent should:\n\t *\n\t * @param preferredPrefix - The prefix to look up\n\t * @param ns              - The namespace for the prefix\n\t *\n\t * @returns The matching candidate prefix, if found, or null otherwise\n\t */\n\tpublic retrievePreferredPrefixString(\n\t\tpreferredPrefix: string | null,\n\t\tns: string | null\n\t): string | null {\n\t\t// 1. Let candidates list be the result of retrieving a list from map where there exists a\n\t\t// key in map that matches the value of ns or if there is no such key, then stop running\n\t\t// these steps, and return the null value.\n\t\tconst candidatesList = this._map.get(ns);\n\t\tif (candidatesList === undefined) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// 2. Otherwise, for each prefix value prefix in candidates list, iterating from beginning\n\t\t// to end:\n\t\t// NOTE: There will always be at least one prefix value in the list.\n\t\tfor (const prefix of candidatesList) {\n\t\t\t// 2.1. If prefix matches preferred prefix, then stop running these steps and return\n\t\t\t// prefix.\n\t\t\tif (prefix === preferredPrefix) {\n\t\t\t\treturn prefix;\n\t\t\t}\n\n\t\t\t// 2.2. If prefix is the last item in the candidates list, then stop running these steps\n\t\t\t// and return prefix.\n\t\t}\n\t\treturn candidatesList[candidatesList.length - 1];\n\t}\n\n\t/**\n\t * To check if a prefix string prefix is found in a namespace prefix map map given a namespace\n\t * ns, the user agent should:\n\t *\n\t * @param prefix - The prefix to check\n\t * @param ns     - The namespace to check\n\t *\n\t * @returns Whether the combination of prefix and ns is found in the map\n\t */\n\tpublic checkIfFound(prefix: string, ns: string | null): boolean {\n\t\t// 1. Let candidates list be the result of retrieving a list from map where there exists a\n\t\t// key in map that matches the value of ns or if there is no such key, then stop running\n\t\t// these steps, and return false.\n\t\tconst candidatesList = this._map.get(ns);\n\t\tif (candidatesList === undefined) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// 2. If the value of prefix occurs at least once in candidates list, return true, otherwise\n\t\t// return false.\n\t\treturn candidatesList.indexOf(prefix) >= 0;\n\t}\n\n\t/**\n\t * To add a prefix string prefix to the namespace prefix map map given a namespace ns, the user\n\t * agent should:\n\t *\n\t * @param prefix - The prefix to add\n\t * @param ns     - The namespace to add for prefix\n\t */\n\tpublic add(prefix: string, ns: string | null): void {\n\t\t// 1. Let candidates list be the result of retrieving a list from map where there exists a\n\t\t// key in map that matches the value of ns or if there is no such key, then let candidates\n\t\t// list be null.\n\t\t// (undefined used instead of null for convenience)\n\t\tconst candidatesList = this._map.get(ns);\n\n\t\t// 2. If candidates list is null, then create a new list with prefix as the only item in the\n\t\t// list, and associate that list with a new key ns in map.\n\t\tif (candidatesList === undefined) {\n\t\t\tthis._map.set(ns, [prefix]);\n\t\t} else {\n\t\t\t// 3. Otherwise, append prefix to the end of candidates list.\n\t\t\tcandidatesList.push(prefix);\n\t\t}\n\n\t\t// NOTE: The steps in retrieve a preferred prefix string use the list to track the most\n\t\t// recently used (MRU) prefix associated with a given namespace, which will be the prefix at\n\t\t// the end of the list. This list may contain duplicates of the same prefix value seen\n\t\t// earlier (and that's OK).\n\t}\n}\n\nexport type LocalPrefixesMap = { [key: string]: string | null };\n\n// 3.2.1.1.1 Recording the namespace\n\n/**\n * This following algorithm will update the namespace prefix map with any found namespace prefix\n * definitions, add the found prefix definitions to the local prefixes map, and return a local\n * default namespace value defined by a default namespace attribute if one exists. Otherwise it\n * returns null.\n *\n * @param element          - Element for which to record namespace information\n * @param map              - The namespace prefix map to update\n * @param localPrefixesMap - The local prefixes map to update\n *\n * @returns The local default namespace value for element, or null if element does not define one\n */\nexport function recordNamespaceInformation(\n\telement: Element,\n\tmap: NamespacePrefixMap,\n\tlocalPrefixesMap: LocalPrefixesMap\n): string | null {\n\t// 1. Let default namespace attr value be null.\n\tlet defaultNamespaceAttrValue: string | null = null;\n\n\t// 2. Main: For each attribute attr in element's attributes, in the order they are specified in\n\t// the element's attribute list:\n\t// NOTE: The following conditional steps find namespace prefixes. Only attributes in the XMLNS\n\t// namespace are considered (e.g., attributes made to look like namespace declarations via\n\t// setAttribute(\"xmlns:pretend-prefix\", \"pretend-namespace\") are not included).\n\tfor (const attr of element.attributes) {\n\t\t// 2.1. Let attribute namespace be the value of attr's namespaceURI value.\n\t\tconst attributeNamespace = attr.namespaceURI;\n\n\t\t// 2.2. Let attribute prefix be the value of attr's prefix.\n\t\tconst attributePrefix = attr.prefix;\n\n\t\t// 2.3. If the attribute namespace is the XMLNS namespace, then:\n\t\tif (attributeNamespace === XMLNS_NAMESPACE) {\n\t\t\t// 2.3.1. If attribute prefix is null, then attr is a default namespace declaration. Set\n\t\t\t// the default namespace attr value to attr's value and stop running these steps,\n\t\t\t// returning to Main to visit the next attribute.\n\t\t\tif (attributePrefix === null) {\n\t\t\t\tdefaultNamespaceAttrValue = attr.value;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// 2.3.2. Otherwise, the attribute prefix is non-null and attr is a namespace prefix\n\t\t\t// definition. Run the following steps:\n\t\t\t// 2.3.2.1. Let prefix definition be the value of attr's localName.\n\t\t\tconst prefixDefinition = attr.localName;\n\n\t\t\t// 2.3.2.2. Let namespace definition be the value of attr's value.\n\t\t\tlet namespaceDefinition: string | null = attr.value;\n\n\t\t\t// 2.3.2.3. If namespace definition is the XML namespace, then stop running these steps,\n\t\t\t// and return to Main to visit the next attribute.\n\t\t\t// NOTE: XML namespace definitions in prefixes are completely ignored (in order to avoid\n\t\t\t// unnecessary work when there might be prefix conflicts). XML namespaced elements are\n\t\t\t// always handled uniformly by prefixing (and overriding if necessary) the element's\n\t\t\t// localname with the reserved \"xml\" prefix.\n\t\t\tif (namespaceDefinition === XML_NAMESPACE) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// 2.3.2.4. If namespace definition is the empty string (the declarative form of having\n\t\t\t// no namespace), then let namespace definition be null instead.\n\t\t\tif (namespaceDefinition === '') {\n\t\t\t\tnamespaceDefinition = null;\n\t\t\t}\n\n\t\t\t// 2.3.2.5. If prefix definition is found in map given the namespace namespace\n\t\t\t// definition, then stop running these steps, and return to Main to visit the next\n\t\t\t// attribute.\n\t\t\t// NOTE: This step avoids adding duplicate prefix definitions for the same namespace in\n\t\t\t// the map. This has the side-effect of avoiding later serialization of duplicate\n\t\t\t// namespace prefix declarations in any descendant nodes.\n\t\t\tif (map.checkIfFound(prefixDefinition, namespaceDefinition)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// 2.3.2.6. Add the prefix prefix definition to map given namespace namespace\n\t\t\t// definition.\n\t\t\tmap.add(prefixDefinition, namespaceDefinition);\n\n\t\t\t// 2.3.2.7. Add the value of prefix definition as a new key to the local prefixes map,\n\t\t\t// with the namespace definition as the key's value replacing the value of null with the\n\t\t\t// empty string if applicable.\n\t\t\tlocalPrefixesMap[prefixDefinition] =\n\t\t\t\tnamespaceDefinition === null ? '' : namespaceDefinition;\n\t\t}\n\t}\n\n\t// 3. Return the value of default namespace attr value.\n\t// NOTE: The empty string is a legitimate return value and is not converted to null.\n\treturn defaultNamespaceAttrValue;\n}\n","import CDATASection from '../CDATASection';\nimport Comment from '../Comment';\nimport Document from '../Document';\nimport DocumentType from '../DocumentType';\nimport Element from '../Element';\nimport Node from '../Node';\nimport ProcessingInstruction from '../ProcessingInstruction';\nimport Text from '../Text';\nimport { throwInvalidStateError } from '../util/errorHelpers';\nimport {\n\tmatchesNameProduction,\n\tHTML_NAMESPACE,\n\tXML_NAMESPACE,\n\tXMLNS_NAMESPACE,\n} from '../util/namespaceHelpers';\nimport { NodeType } from '../util/NodeType';\nimport {\n\trecordNamespaceInformation,\n\tLocalPrefixesMap,\n\tNamespacePrefixMap,\n} from './NamespacePrefixMap';\n\n/*\n// CHAR_REGEX_XML_1_0_FIFTH_EDITION generated using regenerate:\nconst regenerate = require('regenerate');\n\nconst Char = regenerate()\n\t.add(0x9)\n\t.add(0xA)\n\t.add(0xD)\n\t.addRange(0x20, 0xD7FF)\n\t.addRange(0xE000, 0xFFFD)\n\t.addRange(0x10000, 0xEFFFF);\n\nreturn `^(${Char.toString()})*$`;\n*/\nconst CHAR_REGEX_XML_1_0_FIFTH_EDITION =\n\t/^(?:[\\t\\n\\r -\\uD7FF\\uE000-\\uFFFD]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])*$/;\n\n/*\n// PUBIDCHAR_REGEX_XML_1_0_FIFTH_EDITION generated using regenerate:\nconst regenerate = require('regenerate');\n\n// #x20 | #xD | #xA | [a-zA-Z0-9] | [-'()+,./:=?;!*#@$_%]\nconst PubidChar = regenerate()\n\t.add(0x20)\n\t.add(0xD)\n\t.add(0xA)\n\t.addRange('a', 'z')\n\t.addRange('A', 'Z')\n\t.addRange('0', '9')\n\t.add(...\"-'()+,./:=?;!*#@$_%\");\n\n`^(${PubidChar.toString()})*$`;\n*/\nconst PUBIDCHAR_REGEX_XML_1_0_FIFTH_EDITION = /^(?:[\\n\\r !#-%'-;=\\?-Z_a-z])*$/;\n\nconst HTML_VOID_ELEMENTS = [\n\t'area',\n\t'base',\n\t'basefont',\n\t'bgsound',\n\t'br',\n\t'col',\n\t'embed',\n\t'frame',\n\t'hr',\n\t'img',\n\t'input',\n\t'keygen',\n\t'link',\n\t'menuitem',\n\t'meta',\n\t'param',\n\t'source',\n\t'track',\n\t'wbr',\n];\n\n// 3.2. Serializing\n\n/**\n * The following steps form the fragment serializing algorithm:\n *\n * @param node                - The node to serialize\n * @param requireWellFormed   - Determines whether the result needs to be well-formed\n * @param withFictionalParent - Whether to treat node as a fictional parent with node as its only\n *                              child\n *\n * @returns A string representing the serialization of node\n */\nexport function serializeFragment(\n\tnode: Node,\n\trequireWellFormed: boolean,\n\twithFictionalParent: boolean = false\n): string {\n\t// 1. Let context document be the value of node's node document.\n\t// 2. If context document is an HTML document, return an HTML serialization of node.\n\t// (HTML documents not implemented)\n\n\t// 3. Otherwise, context document is an XML document; return an XML serialization of node\n\t// passing the flag require well-formed.\n\t// Note: if implemented as stated in the spec, this would make innerHTML return the outerHTML\n\t// and make outerHTML trigger undefined behavior (the spec doesn't state the type of the\n\t// fictional node that acts as a parent). Instead, serialize the children only\n\tconst childNodes = withFictionalParent ? [node] : node.childNodes;\n\tconst result: string[] = [];\n\tfor (const child of childNodes) {\n\t\tproduceXmlSerialization(child, requireWellFormed, result);\n\t}\n\treturn result.join('');\n\n\t// NOTE: The XML serialization defined in this document conforms to the requirements of the XML\n\t// fragment serialization algorithm defined in [HTML5].\n}\n\n// 3.2.1. XML Serialization\n\ntype PrefixIndex = { value: number };\n\n/**\n * To produce an XML serialization of a Node node given a flag require well-formed, run the\n * following steps:\n *\n * @param node              - The node to serialize\n * @param requireWellFormed - Determines whether the result needs to be well-formed\n * @param result            - Array of strings in which to construct the result\n */\nexport function produceXmlSerialization(\n\tnode: Node,\n\trequireWellFormed: boolean,\n\tresult: string[]\n): void {\n\t// 1. Let namespace be a context namespace with value null. The context namespace tracks the XML\n\t// serialization algorithm's current default namespace. The context namespace is changed when\n\t// either an Element Node has a default namespace declaration, or the algorithm generates a\n\t// default namespace declaration for the Element Node to match its own namespace. The algorithm\n\t// assumes no namespace (null) to start.\n\tconst namespace: string | null = null;\n\n\t// 2. Let prefix map be a new namespace prefix map.\n\tconst prefixMap = new NamespacePrefixMap();\n\n\t// 3. Add the XML namespace with prefix value \"xml\" to prefix map.\n\tprefixMap.add('xml', XML_NAMESPACE);\n\n\t// 4. Let prefix index be a generated namespace prefix index with value 1. The generated\n\t// namespace prefix index is used to generate a new unique prefix value when no suitable\n\t// existing namespace prefix is available to serialize a node's namespaceURI (or the\n\t// namespaceURI of one of node's attributes). See the generate a prefix algorithm.\n\tconst prefixIndex: PrefixIndex = { value: 1 };\n\n\t// 5. Return the result of running the XML serialization algorithm on node passing the context\n\t// namespace namespace, namespace prefix map prefix map, generated namespace prefix index\n\t// reference to prefix index, and the flag require well-formed. If an exception occurs during\n\t// the execution of the algorithm, then catch that exception and throw an \"InvalidStateError\"\n\t// DOMException.\n\ttry {\n\t\trunXmlSerializationAlgorithm(\n\t\t\tnode,\n\t\t\tnamespace,\n\t\t\tprefixMap,\n\t\t\tprefixIndex,\n\t\t\trequireWellFormed,\n\t\t\tresult\n\t\t);\n\t} catch (error) {\n\t\tconst message =\n\t\t\terror instanceof Error ? error.message : 'An error occurred during serialization.';\n\t\treturn throwInvalidStateError(message);\n\t}\n}\n\n/**\n * The XML serialization algorithm produces an XML serialization of an arbitrary DOM node node based\n * on the node's interface type. Each referenced algorithm is to be passed the arguments as they\n * were recieved by the caller and return their result to the caller. Re-throw any exceptions.\n *\n * @param node              - The node to serialize\n * @param namespace         - The context namespace\n * @param prefixMap         - The namespace prefix map\n * @param prefixIndex       - A reference to the generated namespace prefix index\n * @param requireWellFormed - Determines whether the result needs to be well-formed\n * @param result            - Array of strings in which to construct the result\n *\n * @returns The serialization of node\n */\nfunction runXmlSerializationAlgorithm(\n\tnode: Node,\n\tnamespace: null | string,\n\tprefixMap: NamespacePrefixMap,\n\tprefixIndex: PrefixIndex,\n\trequireWellFormed: boolean,\n\tresult: string[]\n): void {\n\t// If node's interface is:\n\tswitch (node.nodeType) {\n\t\t// Element: Run the algorithm for XML serializing an Element node node.\n\t\tcase NodeType.ELEMENT_NODE:\n\t\t\tserializeElementNode(\n\t\t\t\tnode,\n\t\t\t\tnamespace,\n\t\t\t\tprefixMap,\n\t\t\t\tprefixIndex,\n\t\t\t\trequireWellFormed,\n\t\t\t\tresult\n\t\t\t);\n\t\t\treturn;\n\n\t\t// Document: Run the algorithm for XML serializing a Document node node.\n\t\tcase NodeType.DOCUMENT_NODE:\n\t\t\tserializeDocumentNode(\n\t\t\t\tnode,\n\t\t\t\tnamespace,\n\t\t\t\tprefixMap,\n\t\t\t\tprefixIndex,\n\t\t\t\trequireWellFormed,\n\t\t\t\tresult\n\t\t\t);\n\t\t\treturn;\n\n\t\t// Comment: Run the algorithm for XML serializing a Comment node node.\n\t\tcase NodeType.COMMENT_NODE:\n\t\t\tserializeCommentNode(\n\t\t\t\tnode,\n\t\t\t\tnamespace,\n\t\t\t\tprefixMap,\n\t\t\t\tprefixIndex,\n\t\t\t\trequireWellFormed,\n\t\t\t\tresult\n\t\t\t);\n\t\t\treturn;\n\n\t\t// CDATASection: Run the algorithm for XML serializing a CDATASection node node.\n\t\t// Note: this is currently commented out in the DOM parsing spec, as it is based on the DOM4\n\t\t// spec which removed the CDATASection interface. It seems the interface has been restored\n\t\t// in the DOM living standard, so we'll implement its serialization as specced previously.\n\t\tcase NodeType.CDATA_SECTION_NODE:\n\t\t\tserializeCDATASectionNode(\n\t\t\t\tnode,\n\t\t\t\tnamespace,\n\t\t\t\tprefixMap,\n\t\t\t\tprefixIndex,\n\t\t\t\trequireWellFormed,\n\t\t\t\tresult\n\t\t\t);\n\t\t\treturn;\n\n\t\t// Text: Run the algorithm for XML serializing a Text node node.\n\t\tcase NodeType.TEXT_NODE:\n\t\t\tserializeTextNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result);\n\t\t\treturn;\n\n\t\t// DocumentFragment: Run the algorithm for XML serializing a DocumentFragment node node.\n\t\tcase NodeType.DOCUMENT_FRAGMENT_NODE:\n\t\t\tserializeDocumentFragmentNode(\n\t\t\t\tnode,\n\t\t\t\tnamespace,\n\t\t\t\tprefixMap,\n\t\t\t\tprefixIndex,\n\t\t\t\trequireWellFormed,\n\t\t\t\tresult\n\t\t\t);\n\t\t\treturn;\n\n\t\t// DocumentType: Run the algorithm for XML serializing a DocumentType node node.\n\t\tcase NodeType.DOCUMENT_TYPE_NODE:\n\t\t\tserializeDocumentTypeNode(\n\t\t\t\tnode,\n\t\t\t\tnamespace,\n\t\t\t\tprefixMap,\n\t\t\t\tprefixIndex,\n\t\t\t\trequireWellFormed,\n\t\t\t\tresult\n\t\t\t);\n\t\t\treturn;\n\n\t\t// ProcessingInstruction: Run the algorithm for XML serializing a ProcessingInstruction node\n\t\t// node.\n\t\tcase NodeType.PROCESSING_INSTRUCTION_NODE:\n\t\t\tserializeProcessingInstructionNode(\n\t\t\t\tnode,\n\t\t\t\tnamespace,\n\t\t\t\tprefixMap,\n\t\t\t\tprefixIndex,\n\t\t\t\trequireWellFormed,\n\t\t\t\tresult\n\t\t\t);\n\t\t\treturn;\n\n\t\t// An Attr object: Return an empty string.\n\t\tcase NodeType.ATTRIBUTE_NODE:\n\t\t\treturn;\n\n\t\t// Anything else: Throw a TypeError. Only Nodes and Attr objects can be serialized by this\n\t\t// algorithm.\n\t\t// (not reachable from public API)\n\t\t/* istanbul ignore next */\n\t\tdefault:\n\t\t\tthrow new TypeError('Only Nodes and Attr objects can be serialized by this algorithm.');\n\t}\n}\n\n/**\n * 3.2.1.1 XML serializing an Element node\n *\n * @param node              - The node to serialize\n * @param namespace         - The context namespace\n * @param prefixMap         - The namespace prefix map\n * @param prefixIndex       - A reference to the generated namespace prefix index\n * @param requireWellFormed - Determines whether the result needs to be well-formed\n * @param result            - Array of strings in which to construct the result\n */\nfunction serializeElementNode(\n\tnode: Node,\n\tnamespace: string | null,\n\tprefixMap: NamespacePrefixMap,\n\tprefixIndex: PrefixIndex,\n\trequireWellFormed: boolean,\n\tresult: string[]\n): void {\n\tconst element = node as Element;\n\t// If the require well-formed flag is set (its value is true), and this node's localName\n\t// attribute contains the character \":\" (U+003A COLON) or does not match the XML Name\n\t// production, then throw an exception; the serialization of this node would not be a\n\t// well-formed element.\n\tif (\n\t\trequireWellFormed &&\n\t\t(element.localName.indexOf(':') >= 0 || !matchesNameProduction(element.localName))\n\t) {\n\t\tthrow new Error(\n\t\t\t`Can not serialize an element because the localName \"${element.localName}\" is not allowed.`\n\t\t);\n\t}\n\n\t// 2. Let markup be the string \"<\" (U+003C LESS-THAN SIGN).\n\tresult.push('<');\n\n\t// 3. Let qualified name be an empty string.\n\tlet qualifiedName = '';\n\n\t// 4. Let skip end tag be a boolean flag with value false.\n\tlet skipEndTag = false;\n\n\t// 5. Let ignore namespace definition attribute be a boolean flag with value false.\n\tlet ignoreNamespaceDefinitionAttribute = false;\n\n\t// 6. Given prefix map, copy a namespace prefix map and let map be the result.\n\tconst map = prefixMap.copy();\n\n\t// 7. Let local prefixes map be an empty map. The map has unique Node prefix strings as its\n\t// keys, with corresponding namespaceURI Node values as the map's key values (in this map, the\n\t// null namespace is represented by the empty string).\n\t// NOTE: This map is local to each element. It is used to ensure there are no conflicting\n\t// prefixes should a new namespace prefix attribute need to be generated. It is also used to\n\t// enable skipping of duplicate prefix definitions when writing an element's attributes: the map\n\t// allows the algorithm to distinguish between a prefix in the namespace prefix map that might\n\t// be locally-defined (to the current Element) and one that is not.\n\tconst localPrefixesMap: LocalPrefixesMap = {};\n\n\t// 8. Let local default namespace be the result of recording the namespace information for node\n\t// given map and local prefixes map.\n\t// NOTE: The above step will update map with any found namespace prefix definitions, add the\n\t// found prefix definitions to the local prefixes map and return a local default namespace value\n\t// defined by a default namespace attribute if one exists. Otherwise it returns null.\n\tconst localDefaultNamespace = recordNamespaceInformation(element, map, localPrefixesMap);\n\n\t// 9. Let inherited ns be a copy of namespace.\n\tlet inheritedNs = namespace;\n\n\t// 10. Let ns be the value of node's namespaceURI attribute.\n\tconst ns = element.namespaceURI;\n\n\t// 11. If inherited ns is equal to ns, then:\n\tif (inheritedNs === ns) {\n\t\t// 11.1. If local default namespace is non-null, then set ignore namespace definition\n\t\t// attribute to true.\n\t\tif (localDefaultNamespace !== null) {\n\t\t\tignoreNamespaceDefinitionAttribute = true;\n\t\t}\n\n\t\t// 11.2. If ns is the XML namespace, then append to qualified name the concatenation of the\n\t\t// string \"xml:\" and the value of node's localName.\n\t\tif (ns === XML_NAMESPACE) {\n\t\t\tqualifiedName += 'xml:' + element.localName;\n\t\t} else {\n\t\t\t// 11.3. Otherwise, append to qualified name the value of node's localName. The node's\n\t\t\t// prefix if it exists, is dropped.\n\t\t\tqualifiedName += element.localName;\n\t\t}\n\t\t// 11.4. Append the value of qualified name to markup.\n\t\tresult.push(qualifiedName);\n\t} else {\n\t\t// 12. Otherwise, inherited ns is not equal to ns (the node's own namespace is different\n\t\t// from the context namespace of its parent). Run these sub-steps:\n\t\t// 12.1. Let prefix be the value of node's prefix attribute.\n\t\tlet prefix = element.prefix;\n\n\t\t// 12.2. Let candidate prefix be the result of retrieving a preferred prefix string prefix\n\t\t// from map given namespace ns.\n\t\t// NOTE: The above may return null if no namespace key ns exists in map.\n\t\tlet candidatePrefix = map.retrievePreferredPrefixString(prefix, ns);\n\n\t\t// 12.3. If the value of prefix matches \"xmlns\", then run the following steps:\n\t\tif (prefix === 'xmlns') {\n\t\t\t// 12.3.1. If the require well-formed flag is set, then throw an error. An Element with\n\t\t\t// prefix \"xmlns\" will not legally round-trip in a conforming XML parser.\n\t\t\tif (requireWellFormed) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Can not serialize an element with prefix \"xmlns\" because it will ' +\n\t\t\t\t\t\t'not legally round-trip in a conforming XML parser.'\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// 12.3.2. Let candidate prefix be the value of prefix.\n\t\t\tcandidatePrefix = prefix;\n\t\t}\n\n\t\t// 12.4. Found a suitable namespace prefix: if candidate prefix is non-null (a namespace\n\t\t// prefix is defined which maps to ns), then:\n\t\tif (candidatePrefix !== null) {\n\t\t\t// NOTE: The following may serialize a different prefix than the Element's existing\n\t\t\t// prefix if it already had one. However, the retrieving a preferred prefix string\n\t\t\t// algorithm already tried to match the existing prefix if possible.\n\n\t\t\t// 12.4.1. Append to qualified name the concatenation of candidate prefix, \":\" (U+003A\n\t\t\t// COLON), and node's localName. There exists on this node or the node's ancestry a\n\t\t\t// namespace prefix definition that defines the node's namespace.\n\t\t\tqualifiedName += candidatePrefix + ':' + element.localName;\n\n\t\t\t// 12.4.2. If the local default namespace is non-null (there exists a locally-defined\n\t\t\t// default namespace declaration attribute) and its value is not the XML namespace, then\n\t\t\t// let inherited ns get the value of local default namespace unless the local default\n\t\t\t// namespace is the empty string in which case let it get null (the context namespace is\n\t\t\t// changed to the declared default, rather than this node's own namespace).\n\t\t\t// NOTE: Any default namespace definitions or namespace prefixes that define the XML\n\t\t\t// namespace are omitted when serializing this node's attributes.\n\t\t\tif (localDefaultNamespace !== null && localDefaultNamespace !== XML_NAMESPACE) {\n\t\t\t\tinheritedNs = localDefaultNamespace === '' ? null : localDefaultNamespace;\n\t\t\t}\n\n\t\t\t// 12.4.3. Append the value of qualified name to markup.\n\t\t\tresult.push(qualifiedName);\n\t\t} else if (prefix !== null) {\n\t\t\t// 12.5. Otherwise, if prefix is non-null, then:\n\t\t\t// NOTE: By this step, there is no namespace or prefix mapping declaration in this node\n\t\t\t// (or any parent node visited by this algorithm) that defines prefix otherwise the step\n\t\t\t// labelled Found a suitable namespace prefix would have been followed. The sub-steps\n\t\t\t// that follow will create a new namespace prefix declaration for prefix and ensure that\n\t\t\t// prefix does not conflict with an existing namespace prefix declaration of the same\n\t\t\t// localName in node's attribute list.\n\n\t\t\t// 12.5.1. If the local prefixes map contains a key matching prefix, then let prefix be\n\t\t\t// the result of generating a prefix providing as input map, ns, and prefix index.\n\t\t\tif (prefix in localPrefixesMap) {\n\t\t\t\tprefix = generatePrefix(map, ns, prefixIndex);\n\t\t\t}\n\n\t\t\t// 12.5.2. Add prefix to map given namespace ns.\n\t\t\tmap.add(prefix, ns);\n\n\t\t\t// 12.5.3. Append to qualified name the concatenation of prefix, \":\" (U+003A COLON), and\n\t\t\t// node's localName.\n\t\t\tqualifiedName += prefix + ':' + element.localName;\n\n\t\t\t// 12.5.4. Append the value of qualified name to markup.\n\t\t\tresult.push(qualifiedName);\n\n\t\t\t// 12.5.5. Append the following to markup, in the order listed:\n\t\t\t// NOTE: The following serializes a namespace prefix declaration for prefix which was\n\t\t\t// just added to the map.\n\t\t\t// 12.5.5.1. \" \" (U+0020 SPACE);\n\t\t\t// 12.5.5.2. The string \"xmlns:\";\n\t\t\t// 12.5.5.3. The value of prefix;\n\t\t\t// 12.5.5.4. \"=\"\" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);\n\t\t\t// 12.5.5.5. The result of serializing an attribute value given ns and the require\n\t\t\t// well-formed flag as input;\n\t\t\t// 12.5.5.6. \"\"\" (U+0022 QUOTATION MARK).\n\t\t\tresult.push(\n\t\t\t\t' xmlns:',\n\t\t\t\tprefix,\n\t\t\t\t'=\"',\n\t\t\t\tserializeAttributeValue(ns, requireWellFormed),\n\t\t\t\t'\"'\n\t\t\t);\n\n\t\t\t// 12.5.5.7. If local default namespace is non-null (there exists a locally-defined\n\t\t\t// default namespace declaration attribute), then let inherited ns get the value of\n\t\t\t// local default namespace unless the local default namespace is the empty string in\n\t\t\t// which case let it get null.\n\t\t\tif (localDefaultNamespace !== null) {\n\t\t\t\tinheritedNs = localDefaultNamespace === '' ? null : localDefaultNamespace;\n\t\t\t}\n\t\t} else if (\n\t\t\tlocalDefaultNamespace === null ||\n\t\t\t(localDefaultNamespace !== null && localDefaultNamespace !== ns)\n\t\t) {\n\t\t\t// 12.6. Otherwise, if local default namespace is null, or local default namespace is\n\t\t\t// non-null and its value is not equal to ns, then:\n\t\t\t// NOTE: At this point, the namespace for this node still needs to be serialized, but\n\t\t\t// there's no prefix (or candidate prefix) availble; the following uses the default\n\t\t\t// namespace declaration to define the namespace --optionally replacing an existing\n\t\t\t// default declaration if present.\n\n\t\t\t// 12.6.1. Set the ignore namespace definition attribute flag to true.\n\t\t\tignoreNamespaceDefinitionAttribute = true;\n\n\t\t\t// 12.6.2. Append to qualified name the value of node's localName.\n\t\t\tqualifiedName += element.localName;\n\n\t\t\t// 12.6.3. Let the value of inherited ns be ns.\n\t\t\t// NOTE: The new default namespace will be used in the serialization to define this\n\t\t\t// node's namespace and act as the context namespace for its children.\n\t\t\tinheritedNs = ns;\n\n\t\t\t// 12.6.4. Append the value of qualified name to markup.\n\t\t\tresult.push(qualifiedName);\n\n\t\t\t// 12.6.5. Append the following to markup, in the order listed:\n\t\t\t// NOTE: The following serializes the new (or replacement) default namespace definition.\n\t\t\t// 12.6.5.1. \" \" (U+0020 SPACE);\n\t\t\t// 12.6.5.2. The string \"xmlns\";\n\t\t\t// 12.6.5.3. \"=\"\" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);\n\t\t\t// 12.6.5.4. The result of serializing an attribute value given ns and the require\n\t\t\t// well-formed flag as input;\n\t\t\t// 12.6.5.5. \"\"\" (U+0022 QUOTATION MARK).\n\t\t\tresult.push(' xmlns=\"', serializeAttributeValue(ns, requireWellFormed), '\"');\n\t\t} else {\n\t\t\t// 12.7. Otherwise, the node has a local default namespace that matches ns. Append to\n\t\t\t// qualified name the value of node's localName, let the value of inherited ns be ns,\n\t\t\t// and append the value of qualified name to markup.\n\t\t\tqualifiedName += element.localName;\n\t\t\tinheritedNs = ns;\n\t\t\tresult.push(qualifiedName);\n\t\t}\n\n\t\t// NOTE: All of the combinations where ns is not equal to inherited ns are handled above\n\t\t// such that node will be serialized preserving its original namespaceURI.\n\t}\n\n\t// 13. Append to markup the result of the XML serialization of node's attributes given map,\n\t// prefix index, local prefixes map, ignore namespace definition attribute flag, and require\n\t// well-formed flag.\n\tserializeAttributes(\n\t\telement,\n\t\tmap,\n\t\tprefixIndex,\n\t\tlocalPrefixesMap,\n\t\tignoreNamespaceDefinitionAttribute,\n\t\trequireWellFormed,\n\t\tresult\n\t);\n\n\t// 14. If ns is the HTML namespace, and the node's list of children is empty, and the node's\n\t// localName matches any one of the following void elements: \"area\", \"base\", \"basefont\",\n\t// \"bgsound\", \"br\", \"col\", \"embed\", \"frame\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"menuitem\",\n\t// \"meta\", \"param\", \"source\", \"track\", \"wbr\"; then append the following to markup, in the order\n\t// listed:\n\tif (\n\t\tns === HTML_NAMESPACE &&\n\t\t!element.hasChildNodes() &&\n\t\tHTML_VOID_ELEMENTS.indexOf(element.localName) >= 0\n\t) {\n\t\t// 14.1. \" \" (U+0020 SPACE);\n\t\t// 14.2. \"/\" (U+002F SOLIDUS).\n\t\tresult.push(' /');\n\n\t\t// and set the skip end tag flag to true.\n\t\tskipEndTag = true;\n\t}\n\n\t// 15. If ns is not the HTML namespace, and the node's list of children is empty, then append\n\t// \"/\" (U+002F SOLIDUS) to markup and set the skip end tag flag to true.\n\tif (ns !== HTML_NAMESPACE && !element.hasChildNodes()) {\n\t\tresult.push('/');\n\t\tskipEndTag = true;\n\t}\n\n\t// 16. Append \">\" (U+003E GREATER-THAN SIGN) to markup.\n\tresult.push('>');\n\n\t// 17. If the value of skip end tag is true, then return the value of markup and skip the\n\t// remaining steps. The node is a leaf-node.\n\tif (skipEndTag) {\n\t\treturn;\n\t}\n\n\t// 18. If ns is the HTML namespace, and the node's localName matches the string \"template\", then\n\t// this is a template element. Append to markup the result of XML serializing a DocumentFragment\n\t// node given the template element's template contents (a DocumentFragment), providing inherited\n\t// ns, map, prefix index, and the require well-formed flag.\n\t// NOTE: This allows template content to round-trip , given the rules for parsing XHTML\n\t// documents.\n\t// (HTML documents not implemented)\n\n\t// 19. Otherwise, append to markup the result of running the XML serialization algorithm on each\n\t// of node's children, in tree order, providing inherited ns, map, prefix index, and the require\n\t// well-formed flag.\n\tfor (const child of node.childNodes) {\n\t\trunXmlSerializationAlgorithm(\n\t\t\tchild,\n\t\t\tinheritedNs,\n\t\t\tmap,\n\t\t\tprefixIndex,\n\t\t\trequireWellFormed,\n\t\t\tresult\n\t\t);\n\t}\n\n\t// 20. Append the following to markup, in the order listed:\n\t// 20.1. \"</\" (U+003C LESS-THAN SIGN, U+002F SOLIDUS);\n\t// 20.2. The value of qualified name;\n\t// 20.3. \">\" (U+003E GREATER-THAN SIGN).\n\tresult.push('</', qualifiedName, '>');\n\n\t// 21. Return the value of markup.\n}\n\n// 3.2.1.1.3 Serializing an Element's attributes\n\n/**\n * The XML serialization of the attributes of an Element element together with a namespace prefix\n * map map, a generated namespace prefix index prefix index reference, a local prefixes map, a\n * ignore namespace definition attribute flag, and a require well-formed flag, is the result of the\n * following algorithm:\n *\n * @param element                            - The element for which to serialize attributes\n * @param prefixMap                          - The namespace prefix map\n * @param prefixIndex                        - The generated namespace prefix index, by reference\n * @param localPrefixesMap                   - The local prefixes map\n * @param ignoreNamespaceDefinitionAttribute - The ignore namespace definition attribute flag\n * @param requireWellFormed                  - The require well-formed flag\n * @param result                             - Array of strings in which to construct the result\n */\nfunction serializeAttributes(\n\telement: Element,\n\tmap: NamespacePrefixMap,\n\tprefixIndex: PrefixIndex,\n\tlocalPrefixesMap: LocalPrefixesMap,\n\tignoreNamespaceDefinitionAttribute: boolean,\n\trequireWellFormed: boolean,\n\tresult: string[]\n): void {\n\t// 1. Let result be the empty string.\n\t// (result constructed in-place in argument)\n\n\t// 2. Let localname set be a new empty namespace localname set. This localname set will contain\n\t// tuples of unique attribute namespaceURI and localName pairs, and is populated as each attr is\n\t// processed. This set is used to [optionally] enforce the well-formed constraint that an\n\t// element cannot have two attributes with the same namespaceURI and localName. This can occur\n\t// when two otherwise identical attributes on the same element differ only by their prefix\n\t// values.\n\tconst localNameSet: { namespaceURI: string | null; localName: string }[] = [];\n\n\t// 3. Loop: For each attribute attr in element's attributes, in the order they are specified in\n\t// the element's attribute list:\n\tfor (const attr of element.attributes) {\n\t\t// 3.1. If the require well-formed flag is set (its value is true), and the localname set\n\t\t// contains a tuple whose values match those of a new tuple consisting of attr's\n\t\t// namespaceURI attribute and localName attribute, then throw an exception; the\n\t\t// serialization of this attr would fail to produce a well-formed element serialization.\n\t\tif (\n\t\t\trequireWellFormed &&\n\t\t\tlocalNameSet.find(\n\t\t\t\t(tuple) =>\n\t\t\t\t\ttuple.localName === attr.localName && tuple.namespaceURI === attr.namespaceURI\n\t\t\t)\n\t\t) {\n\t\t\tthrow new Error(\n\t\t\t\t`Can not serialize a duplicate attribute for namespaceURI \"${attr.namespaceURI}\", localName \"${attr.localName}\".`\n\t\t\t);\n\t\t}\n\n\t\t// 3.2. Create a new tuple consisting of attr's namespaceURI attribute and localName\n\t\t// attribute, and add it to the localname set.\n\t\tlocalNameSet.push({ namespaceURI: attr.namespaceURI, localName: attr.localName });\n\n\t\t// 3.3. Let attribute namespace be the value of attr's namespaceURI value.\n\t\tconst attributeNamespace = attr.namespaceURI;\n\n\t\t// 3.4. Let candidate prefix be null.\n\t\tlet candidatePrefix: string | null = null;\n\n\t\t// 3.5. If attribute namespace is non-null, then run these sub-steps:\n\t\tif (attributeNamespace !== null) {\n\t\t\t// 3.5.1. Let candidate prefix be the result of retrieving a preferred prefix string\n\t\t\t// from map given namespace attribute namespace with preferred prefix being attr's\n\t\t\t// prefix value.\n\t\t\tcandidatePrefix = map.retrievePreferredPrefixString(attr.prefix, attributeNamespace);\n\n\t\t\t// 3.5.2. If the value of attribute namespace is the XMLNS namespace, then run these\n\t\t\t// steps:\n\t\t\tif (attributeNamespace === XMLNS_NAMESPACE) {\n\t\t\t\t// 3.5.2.1. If any of the following are true, then stop running these steps and goto\n\t\t\t\t// Loop to visit the next attribute:\n\t\t\t\t// - the attr's value is the XML namespace;\n\t\t\t\t// NOTE: The XML namespace cannot be redeclared and survive round-tripping (unless\n\t\t\t\t// it defines the prefix \"xml\"). To avoid this problem, this algorithm always\n\t\t\t\t// prefixes elements in the XML namespace with \"xml\" and drops any related\n\t\t\t\t// definitions as seen in the above condition.\n\t\t\t\tif (attr.value === XML_NAMESPACE) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// - the attr's prefix is null and the ignore namespace definition attribute flag is\n\t\t\t\t// true (the Element's default namespace attribute should be skipped);\n\t\t\t\tif (attr.prefix === null && ignoreNamespaceDefinitionAttribute) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// - the attr's prefix is non-null and either\n\t\t\t\t//   - the attr's localName is not a key contained in the local prefixes map, or\n\t\t\t\t//   - the attr's localName is present in the local prefixes map but the value of\n\t\t\t\t//     the key does not match attr's value\n\t\t\t\tif (\n\t\t\t\t\tattr.prefix !== null &&\n\t\t\t\t\t(!(attr.localName in localPrefixesMap) ||\n\t\t\t\t\t\tlocalPrefixesMap[attr.localName] !== attr.value)\n\t\t\t\t) {\n\t\t\t\t\t// and furthermore that the attr's localName (as the prefix to find) is found in\n\t\t\t\t\t// the namespace prefix map given the namespace consisting of the attr's value\n\t\t\t\t\t// (the current namespace prefix definition was exactly defined previously--on\n\t\t\t\t\t// an ancestor element not the current element whose attributes are being\n\t\t\t\t\t// processed).\n\t\t\t\t\t// (the only ways that this xmlns:* attribute can be omitted from the\n\t\t\t\t\t// localPrefixesMap is if it is either the XML namespace (control flow would not\n\t\t\t\t\t// reach this point), or if it was defined on an ancestor (and is therefore\n\t\t\t\t\t// certainly in the map). This last condition seems to be a duplicate attempt to\n\t\t\t\t\t// prevent repeated declarations in the spec, which is already prevented by the\n\t\t\t\t\t// check in recordNamespaceInformation.)\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// 3.5.2.2. If the require well-formed flag is set (its value is true), and the\n\t\t\t\t// value of attr's value attribute matches the XMLNS namespace, then throw an\n\t\t\t\t// exception; the serialization of this attribute would produce invalid XML because\n\t\t\t\t// the XMLNS namespace is reserved and cannot be applied as an element's namespace\n\t\t\t\t// via XML parsing.\n\t\t\t\t// NOTE: DOM APIs do allow creation of elements in the XMLNS namespace but with\n\t\t\t\t// strict qualifications.\n\t\t\t\tif (requireWellFormed && attr.value === XMLNS_NAMESPACE) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t'The serialization of this attribute would produce invalid XML because ' +\n\t\t\t\t\t\t\t'the XMLNS namespace is reserved and cannot be applied as an ' +\n\t\t\t\t\t\t\t\"element's namespace via XML parsing.\"\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// 3.5.2.3. If the require well-formed flag is set (its value is true), and the\n\t\t\t\t// value of attr's value attribute is the empty string, then throw an exception;\n\t\t\t\t// namespace prefix declarations cannot be used to undeclare a namespace (use a\n\t\t\t\t// default namespace declaration instead).\n\t\t\t\t// (we deviate from the spec here by only throwing for prefix declarations, the\n\t\t\t\t// implementations of this in browsers and the spec text suggest that default\n\t\t\t\t// namespace declarations should be allowed to reset the default namespace to null)\n\t\t\t\tif (requireWellFormed && attr.prefix !== null && attr.value === '') {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t'Namespace prefix declarations cannot be used to undeclare a namespace. ' +\n\t\t\t\t\t\t\t'Use a default namespace declaration instead.'\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// 3.5.2.4. the attr's prefix matches the string \"xmlns\", then let candidate prefix\n\t\t\t\t// be the string \"xmlns\".\n\t\t\t\tif (attr.prefix === 'xmlns') {\n\t\t\t\t\tcandidatePrefix = 'xmlns';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// 3.5.3. Otherwise, the attribute namespace in not the XMLNS namespace. Run these\n\t\t\t\t// steps:\n\t\t\t\t// (interpreting this as a typo in the spec: \"in\" should probably have been \"is\")\n\n\t\t\t\t// (We need to deviate from the spec here, as implementing as specified would always\n\t\t\t\t// generate prefixes for all namespaced attributes. Instead, first check if no valid\n\t\t\t\t// candidate prefix was found in the steps above.)\n\t\t\t\tif (candidatePrefix === null) {\n\t\t\t\t\t// (Again, we need to deviate from the spec to make sure we prefer the attr's\n\t\t\t\t\t// own prefix over a generated prefix where that would not conflict with\n\t\t\t\t\t// existing definitions.)\n\t\t\t\t\tif (attr.prefix === null || attr.prefix in localPrefixesMap) {\n\t\t\t\t\t\t// 3.5.3.1. Let candidate prefix be the result of generating a prefix\n\t\t\t\t\t\t// providing map, attribute namespace, and prefix index as input.\n\t\t\t\t\t\tcandidatePrefix = generatePrefix(map, attributeNamespace, prefixIndex);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcandidatePrefix = attr.prefix;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Update the local and aggregate prefixes to account for the new declaration.\n\t\t\t\t\tmap.add(candidatePrefix, attr.namespaceURI);\n\t\t\t\t\tlocalPrefixesMap[candidatePrefix] = attr.namespaceURI;\n\n\t\t\t\t\t// 3.5.3.2. Append the following to result, in the order listed:\n\t\t\t\t\t// 3.5.3.2.1. \" \" (U+0020 SPACE);\n\t\t\t\t\t// 3.5.3.2.2. The string \"xmlns:\";\n\t\t\t\t\t// 3.5.3.2.3. The value of candidate prefix;\n\t\t\t\t\t// 3.5.3.2.4. \"=\"\" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);\n\t\t\t\t\t// 3.5.3.2.5. The result of serializing an attribute value given attribute\n\t\t\t\t\t// namespace and the require well-formed flag as input;\n\t\t\t\t\t// 3.5.3.2.7. \"\"\" (U+0022 QUOTATION MARK).\n\t\t\t\t\tresult.push(\n\t\t\t\t\t\t' xmlns:',\n\t\t\t\t\t\tcandidatePrefix,\n\t\t\t\t\t\t'=\"',\n\t\t\t\t\t\tserializeAttributeValue(attributeNamespace, requireWellFormed),\n\t\t\t\t\t\t'\"'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// 3.6. Append a \" \" (U+0020 SPACE) to result.\n\t\tresult.push(' ');\n\n\t\t// 3.7. If candidate prefix is non-null, then append to result the concatenation of\n\t\t// candidate prefix with \":\" (U+003A COLON).\n\t\tif (candidatePrefix !== null) {\n\t\t\tresult.push(candidatePrefix, ':');\n\t\t}\n\n\t\t// 3.8. If the require well-formed flag is set (its value is true), and this attr's\n\t\t// localName attribute contains the character \":\" (U+003A COLON) or does not match the XML\n\t\t// Name production or equals \"xmlns\" and attribute namespace is null, then throw an\n\t\t// exception; the serialization of this attr would not be a well-formed attribute.\n\t\tif (\n\t\t\trequireWellFormed &&\n\t\t\t(attr.localName.indexOf(':') >= 0 ||\n\t\t\t\t!matchesNameProduction(attr.localName) ||\n\t\t\t\t(attr.localName === 'xmlns' && attributeNamespace === null))\n\t\t) {\n\t\t\tthrow new Error(\n\t\t\t\t`Can not serialize an attribute because the localName \"${attr.localName}\" is not allowed.`\n\t\t\t);\n\t\t}\n\n\t\t// 3.9. Append the following strings to result, in the order listed:\n\t\t// 3.9.1. The value of attr's localName;\n\t\t// 3.9.2. \"=\"\" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);\n\t\t// 3.9.3. The result of serializing an attribute value given attr's value attribute and the\n\t\t// require well-formed flag as input;\n\t\t// 3.9.4. \"\"\" (U+0022 QUOTATION MARK).\n\t\tresult.push(\n\t\t\tattr.localName,\n\t\t\t'=\"',\n\t\t\tserializeAttributeValue(attr.value, requireWellFormed),\n\t\t\t'\"'\n\t\t);\n\t}\n\n\t// 4. Return the value of result.\n}\n\n/**\n * When serializing an attribute value given an attribute value and require well-formed flag, the\n * user agent must run the following steps:\n *\n * @param attributeValue    - The attribute value to serialize\n * @param requireWellFormed - Determines whether the result needs to be well-formed\n *\n * @returns The serialized attribute value\n */\nfunction serializeAttributeValue(\n\tattributeValue: string | null,\n\trequireWellFormed: boolean\n): string {\n\t// 1. If the require well-formed flag is set (its value is true), and attribute value contains\n\t// characters that are not matched by the XML Char production, then throw an exception; the\n\t// serialization of this attribute value would fail to produce a well-formed element\n\t// serialization.\n\tif (\n\t\trequireWellFormed &&\n\t\tattributeValue !== null &&\n\t\t!CHAR_REGEX_XML_1_0_FIFTH_EDITION.test(attributeValue)\n\t) {\n\t\tthrow new Error(\n\t\t\t'Can not serialize an attribute value because it contains invalid characters.'\n\t\t);\n\t}\n\n\t// 2. If attribute value is null, then return the empty string.\n\tif (attributeValue === null) {\n\t\treturn '';\n\t}\n\n\t// 3. Otherwise, attribute value is a string. Return the value of attribute value, first\n\t// replacing any occurrences of the following:\n\treturn (\n\t\tattributeValue\n\t\t\t// 3.1. \"&\" with \"&amp;\"\n\t\t\t.replace(/&/g, '&amp;')\n\t\t\t// 3.2. \"\"\" with \"&quot;\"\n\t\t\t.replace(/\"/g, '&quot;')\n\t\t\t// 3.3. \"<\" with \"&lt;\"\n\t\t\t.replace(/</g, '&lt;')\n\t\t\t// 3.4. \">\" with \"&gt;\"\n\t\t\t.replace(/>/g, '&gt;')\n\t\t\t// (we deviate from the spec here to also escape whitespace characters, this matches\n\t\t\t// the behavior of Chrome, Firefox and Edge, although the specific encoding varies\n\t\t\t// between those browsers)\n\t\t\t.replace(/\\t/g, '&#9;')\n\t\t\t.replace(/\\n/g, '&#10;')\n\t\t\t.replace(/\\r/g, '&#13;')\n\t);\n\n\t// NOTE: This matches behavior present in browsers, and goes above and beyond the grammar\n\t// requirement in the XML specification's AttValue production by also replacing \">\" characters.\n}\n\n// 3.2.1.1.4 Generating namespace prefixes\n\n/**\n * To generate a prefix given a namespace prefix map map, a string new namespace, and a reference to\n * a generated namespace prefix index prefix index, the user agent must run the following steps:\n *\n * @param map          - The namespace prefix map\n * @param newNamespace - The new namespace to generate a prefix for\n * @param prefixIndex  - The reference to the generated namespace prefix index\n *\n * @returns The generated prefix for the new namespace\n */\nfunction generatePrefix(\n\tmap: NamespacePrefixMap,\n\tnewNamespace: string | null,\n\tprefixIndex: PrefixIndex\n): string {\n\t// 1. Let generated prefix be the concatenation of the string \"ns\" and the current numerical\n\t// value of prefix index.\n\tconst generatedPrefix = 'ns' + prefixIndex.value;\n\n\t// 2. Let the value of prefix index be incremented by one.\n\tprefixIndex.value += 1;\n\n\t// 3. Add to map the generated prefix given the new namespace namespace.\n\tmap.add(generatedPrefix, newNamespace);\n\n\t// 4. Return the value of generated prefix.\n\treturn generatedPrefix;\n}\n\n/**\n * 3.2.1.2 XML serializing a Document node\n *\n * @param node              - The node to serialize\n * @param namespace         - The context namespace\n * @param prefixMap         - The namespace prefix map\n * @param prefixIndex       - A reference to the generated namespace prefix index\n * @param requireWellFormed - Determines whether the result needs to be well-formed\n * @param result            - Array of strings in which to construct the result\n */\nfunction serializeDocumentNode(\n\tnode: Node,\n\tnamespace: string | null,\n\tprefixMap: NamespacePrefixMap,\n\tprefixIndex: PrefixIndex,\n\trequireWellFormed: boolean,\n\tresult: string[]\n): void {\n\tconst document = node as Document;\n\t// 1. If the require well-formed flag is set (its value is true), and this node has no\n\t// documentElement (the documentElement attribute's value is null), then throw an exception; the\n\t// serialization of this node would not be a well-formed document.\n\tif (requireWellFormed && document.documentElement === null) {\n\t\tthrow new Error('Can not serialize a document with no documentElement.');\n\t}\n\n\t// 2. Otherwise, run the following steps:\n\n\t// 2.1. Let serialized document be an empty string.\n\t// (constructed in-place in result argument)\n\n\t// 2.2. For each child child of node, in tree order, run the XML serialization algorithm on the\n\t// child passing along the provided arguments, and append the result to serialized document.\n\t// NOTE: This will serialize any number of ProcessingInstruction and Comment nodes both before\n\t// and after the Document's documentElement node, including at most one DocumentType node. (Text\n\t// nodes are not allowed as children of the Document.)\n\tfor (const child of document.childNodes) {\n\t\trunXmlSerializationAlgorithm(\n\t\t\tchild,\n\t\t\tnamespace,\n\t\t\tprefixMap,\n\t\t\tprefixIndex,\n\t\t\trequireWellFormed,\n\t\t\tresult\n\t\t);\n\t}\n\n\t// 2.3. Return the value of serialized document.\n}\n\n/**\n * 3.2.1.3 XML serializing a Comment node\n *\n * @param node              - The node to serialize\n * @param namespace         - The context namespace\n * @param prefixMap         - The namespace prefix map\n * @param prefixIndex       - A reference to the generated namespace prefix index\n * @param requireWellFormed - Determines whether the result needs to be well-formed\n * @param result            - Array of strings in which to construct the result\n */\nfunction serializeCommentNode(\n\tnode: Node,\n\tnamespace: string | null,\n\tprefixMap: NamespacePrefixMap,\n\tprefixIndex: PrefixIndex,\n\trequireWellFormed: boolean,\n\tresult: string[]\n): void {\n\tconst comment = node as Comment;\n\t// 1. If the require well-formed flag is set (its value is true), and node's data contains\n\t// characters that are not matched by the XML Char production or contains \"--\" (two adjacent\n\t// U+002D HYPHEN-MINUS characters) or that ends with a \"-\" (U+002D HYPHEN-MINUS) character, then\n\t// throw an exception; the serialization of this node's data would not be well-formed.\n\tif (\n\t\trequireWellFormed &&\n\t\t(!CHAR_REGEX_XML_1_0_FIFTH_EDITION.test(comment.data) ||\n\t\t\tcomment.data.indexOf('--') >= 0 ||\n\t\t\tcomment.data.endsWith('-'))\n\t) {\n\t\tthrow new Error('Can not serialize a comment because it contains invalid characters.');\n\t}\n\n\t// 2. Otherwise, return the concatenation of \"<!--\", node's data, and \"-->\".\n\tresult.push('<!--', comment.data, '-->');\n}\n\n/**\n * (not currently in spec) XML serializing a CDATASection node\n *\n * @param node              - The node to serialize\n * @param namespace         - The context namespace\n * @param prefixMap         - The namespace prefix map\n * @param prefixIndex       - A reference to the generated namespace prefix index\n * @param requireWellFormed - Determines whether the result needs to be well-formed\n * @param result            - Array of strings in which to construct the result\n */\nfunction serializeCDATASectionNode(\n\tnode: Node,\n\tnamespace: string | null,\n\tprefixMap: NamespacePrefixMap,\n\tprefixIndex: PrefixIndex,\n\trequireWellFormed: boolean,\n\tresult: string[]\n): void {\n\tconst cs = node as CDATASection;\n\n\t// 1. Let markup be the concatenation of \"<![CDATA[\", node's data, and \"]]>\".\n\tresult.push('<![CDATA[', cs.data, ']]>');\n\n\t// 2. Return the value of markup.\n}\n\n/**\n * 3.2.1.4 XML serializing a Text node\n *\n * @param node              - The node to serialize\n * @param namespace         - The context namespace\n * @param prefixMap         - The namespace prefix map\n * @param prefixIndex       - A reference to the generated namespace prefix index\n * @param requireWellFormed - Determines whether the result needs to be well-formed\n * @param result            - Array of strings in which to construct the result\n */\nfunction serializeTextNode(\n\tnode: Node,\n\tnamespace: string | null,\n\tprefixMap: NamespacePrefixMap,\n\tprefixIndex: PrefixIndex,\n\trequireWellFormed: boolean,\n\tresult: string[]\n): void {\n\tconst text = node as Text;\n\t// 1. If the require well-formed flag is set (its value is true), and node's data contains\n\t// characters that are not matched by the XML Char production, then throw an exception; the\n\t// serialization of this node's data would not be well-formed.\n\tif (requireWellFormed && !CHAR_REGEX_XML_1_0_FIFTH_EDITION.test(text.data)) {\n\t\tthrow new Error('Can not serialize a text node because it contains invalid characters.');\n\t}\n\n\t// 2. Let markup be the value of node's data.\n\tlet markup = text.data;\n\n\t// 3. Replace any occurrences of \"&\" in markup by \"&amp;\".\n\tmarkup = markup.replace(/&/g, '&amp;');\n\n\t// 4. Replace any occurrences of \"<\" in markup by \"&lt;\".\n\tmarkup = markup.replace(/</g, '&lt;');\n\n\t// 5. Replace any occurrences of \">\" in markup by \"&gt;\".\n\tmarkup = markup.replace(/>/g, '&gt;');\n\n\t// 6. Return the value of markup.\n\tresult.push(markup);\n}\n\n/**\n * 3.2.1.5 XML serializing a DocumentFragment node\n *\n * @param node              - The node to serialize\n * @param namespace         - The context namespace\n * @param prefixMap         - The namespace prefix map\n * @param prefixIndex       - A reference to the generated namespace prefix index\n * @param requireWellFormed - Determines whether the result needs to be well-formed\n * @param result            - Array of strings in which to construct the result\n */\nfunction serializeDocumentFragmentNode(\n\tnode: Node,\n\tnamespace: string | null,\n\tprefixMap: NamespacePrefixMap,\n\tprefixIndex: PrefixIndex,\n\trequireWellFormed: boolean,\n\tresult: string[]\n): void {\n\t// 1. Let markup the empty string.\n\t// (constructed in-place in result argument)\n\n\t// 2. For each child child of node, in tree order, run the XML serialization algorithm on the\n\t// child given namespace, prefix map, a reference to prefix index, and flag require well-formed.\n\t// Concatenate the result to markup.\n\tfor (const child of node.childNodes) {\n\t\trunXmlSerializationAlgorithm(\n\t\t\tchild,\n\t\t\tnamespace,\n\t\t\tprefixMap,\n\t\t\tprefixIndex,\n\t\t\trequireWellFormed,\n\t\t\tresult\n\t\t);\n\t}\n\n\t// 3. Return the value of markup.\n}\n\n/**\n * 3.2.1.6 XML serializing a DocumentType node\n *\n * @param node              - The node to serialize\n * @param namespace         - The context namespace\n * @param prefixMap         - The namespace prefix map\n * @param prefixIndex       - A reference to the generated namespace prefix index\n * @param requireWellFormed - Determines whether the result needs to be well-formed\n * @param result            - Array of strings in which to construct the result\n */\nfunction serializeDocumentTypeNode(\n\tnode: Node,\n\tnamespace: string | null,\n\tprefixMap: NamespacePrefixMap,\n\tprefixIndex: PrefixIndex,\n\trequireWellFormed: boolean,\n\tresult: string[]\n): void {\n\tconst dt = node as DocumentType;\n\t// 1. If the require well-formed flag is true and the node's publicId attribute contains\n\t// characters that are not matched by the XML PubidChar production, then throw an exception; the\n\t// serialization of this node would not be a well-formed document type declaration.\n\tif (requireWellFormed && !PUBIDCHAR_REGEX_XML_1_0_FIFTH_EDITION.test(dt.publicId)) {\n\t\tthrow new Error(\n\t\t\t'Can not serialize a document type because the publicId contains invalid characters.'\n\t\t);\n\t}\n\n\t// 2. If the require well-formed flag is true and the node's systemId attribute contains\n\t// characters that are not matched by the XML Char production or that contains both a \"\"\"\n\t// (U+0022 QUOTATION MARK) and a \"'\" (U+0027 APOSTROPHE), then throw an exception; the\n\t// serialization of this node would not be a well-formed document type declaration.\n\tif (\n\t\trequireWellFormed &&\n\t\t(!CHAR_REGEX_XML_1_0_FIFTH_EDITION.test(dt.systemId) ||\n\t\t\t(dt.systemId.indexOf('\"') >= 0 && dt.systemId.indexOf(\"'\") >= 0))\n\t) {\n\t\tthrow new Error(\n\t\t\t'Can not serialize a document type because the systemId contains invalid characters.'\n\t\t);\n\t}\n\n\t// 3. Let markup be an empty string.\n\t// (constructed in-place in result argument)\n\n\t// 4. Append the string \"<!DOCTYPE\" to markup.\n\tresult.push('<!DOCTYPE');\n\n\t// 5. Append \" \" (U+0020 SPACE) to markup.\n\tresult.push(' ');\n\n\t// 6. Append the value of the node's name attribute to markup. For a node belonging to an HTML\n\t// document, the value will be all lowercase.\n\t// (HTML documents not implemented)\n\tresult.push(dt.name);\n\n\t// 7. If the node's publicId is not the empty string then append the following, in the order\n\t// listed, to markup:\n\tif (dt.publicId !== '') {\n\t\t// 7.1. \" \" (U+0020 SPACE);\n\t\t// 7.2. The string \"PUBLIC\";\n\t\t// 7.3. \" \" (U+0020 SPACE);\n\t\t// 7.4. \"\"\" (U+0022 QUOTATION MARK);\n\t\t// 7.5. The value of the node's publicId attribute;\n\t\t// 7.6. \"\"\" (U+0022 QUOTATION MARK).\n\t\tresult.push(' PUBLIC \"', dt.publicId, '\"');\n\t}\n\n\t// 8. If the node's systemId is not the empty string and the node's publicId is set to the empty\n\t// string, then append the following, in the order listed, to markup:\n\tif (dt.systemId !== '' && dt.publicId === '') {\n\t\t// 8.1. \" \" (U+0020 SPACE);\n\t\t// 8.2. The string \"SYSTEM\".\n\t\tresult.push(' SYSTEM');\n\t}\n\n\t// 9. If the node's systemId is not the empty string then append the following, in the order\n\t// listed, to markup:\n\tif (dt.systemId !== '') {\n\t\t// 9.1. \" \" (U+0020 SPACE);\n\t\t// 9.2. \"\"\" (U+0022 QUOTATION MARK);\n\t\t// 9.3. The value of the node's systemId attribute;\n\t\t// 9.4. \"\"\" (U+0022 QUOTATION MARK).\n\t\tresult.push(' \"', dt.systemId, '\"');\n\t}\n\n\t// 10. Append \">\" (U+003E GREATER-THAN SIGN) to markup.\n\tresult.push('>');\n\n\t// 11. Return the value of markup.\n}\n\n/**\n * 3.2.1.7 XML serializing a ProcessingInstruction node\n *\n * @param node              - The node to serialize\n * @param namespace         - The context namespace\n * @param prefixMap         - The namespace prefix map\n * @param prefixIndex       - A reference to the generated namespace prefix index\n * @param requireWellFormed - Determines whether the result needs to be well-formed\n * @param result            - Array of strings in which to construct the result\n */\nfunction serializeProcessingInstructionNode(\n\tnode: Node,\n\tnamespace: string | null,\n\tprefixMap: NamespacePrefixMap,\n\tprefixIndex: PrefixIndex,\n\trequireWellFormed: boolean,\n\tresult: string[]\n): void {\n\tconst pi = node as ProcessingInstruction;\n\t// 1. If the require well-formed flag is set (its value is true), and node's target contains a\n\t// \":\" (U+003A COLON) character or is an ASCII case-insensitive match for the string \"xml\", then\n\t// throw an exception; the serialization of this node's target would not be well-formed.\n\tif (requireWellFormed) {\n\t\tif (pi.target.indexOf(':') >= 0) {\n\t\t\tthrow new Error(\n\t\t\t\t`Can not serialize a processing instruction because the target \"${pi.target}\" may not contain \":\".`\n\t\t\t);\n\t\t}\n\t\tif (pi.target.toLowerCase() === 'xml') {\n\t\t\tthrow new Error(\n\t\t\t\t'Can not serialize a processing instruction because \"xml\" may not be used as target.'\n\t\t\t);\n\t\t}\n\t}\n\n\t// 2. If the require well-formed flag is set (its value is true), and node's data contains\n\t// characters that are not matched by the XML Char production or contains the string \"?>\"\n\t// (U+003F QUESTION MARK, U+003E GREATER-THAN SIGN), then throw an exception; the serialization\n\t// of this node's data would not be well-formed.\n\tif (\n\t\trequireWellFormed &&\n\t\t(!CHAR_REGEX_XML_1_0_FIFTH_EDITION.test(pi.data) || pi.data.indexOf('?>') >= 0)\n\t) {\n\t\tthrow new Error(\n\t\t\t'Can not serialize a processing instruction because the data contains invalid characters.'\n\t\t);\n\t}\n\n\t// 3. Let markup be the concatenation of the following, in the order listed:\n\t// 3.1. \"<?\" (U+003C LESS-THAN SIGN, U+003F QUESTION MARK);\n\t// 3.2. The value of node's target;\n\t// 3.3. \" \" (U+0020 SPACE);\n\t// 3.4. The value of node's data;\n\t// 3.5. \"?>\" (U+003F QUESTION MARK, U+003E GREATER-THAN SIGN).\n\tresult.push('<?', pi.target, ' ', pi.data, '?>');\n\n\t// 4. Return the value of markup.\n}\n","import { ParentNode, NonDocumentTypeChildNode, ChildNode } from './mixins';\nimport { getChildren, getPreviousElementSibling, getNextElementSibling } from './mixins';\nimport Attr from './Attr';\nimport Document from './Document';\nimport Node from './Node';\nimport { getContext } from './context/Context';\nimport { serializeFragment } from './dom-parsing/serializationAlgorithms';\nimport {\n\tappendNodes,\n\tgetDescendantTextContent,\n\tinsertNodesAfter,\n\tinsertNodesBefore,\n\tprependNodes,\n\tremoveFromParent,\n\treplaceChildren,\n\treplaceWithNodes,\n\tstringReplaceAll,\n} from './util/mutationAlgorithms';\nimport {\n\tappendAttribute,\n\tchangeAttribute,\n\tremoveAttribute,\n\treplaceAttribute,\n} from './util/attrMutations';\nimport {\n\texpectArity,\n\tthrowInUseAttributeError,\n\tthrowInvalidCharacterError,\n\tthrowNotFoundError,\n} from './util/errorHelpers';\nimport {\n\tmatchesNameProduction,\n\tvalidateAndExtract,\n\tlocateNamespacePrefix,\n\tXMLNS_NAMESPACE,\n} from './util/namespaceHelpers';\nimport { NodeType } from './util/NodeType';\nimport { asNullableString, asObject, ifNullActAsIfEmptyString } from './util/typeHelpers';\nimport {\n\tgetListOfElementsWithNamespaceAndLocalName,\n\tgetListOfElementsWithQualifiedName,\n} from './util/treeHelpers';\n\n/**\n * 3.9. Interface Element\n *\n * @public\n */\nexport default class Element\n\textends Node\n\timplements ParentNode, NonDocumentTypeChildNode, ChildNode\n{\n\t// Node\n\n\tpublic get nodeType(): number {\n\t\treturn NodeType.ELEMENT_NODE;\n\t}\n\n\tpublic get nodeName(): string {\n\t\treturn this.tagName;\n\t}\n\n\tpublic get nodeValue(): string | null {\n\t\treturn null;\n\t}\n\n\tpublic set nodeValue(newValue: string | null) {\n\t\t// Do nothing.\n\t}\n\n\tpublic get textContent(): string | null {\n\t\t// Return the descendant text content of this\n\t\treturn getDescendantTextContent(this);\n\t}\n\n\tpublic set textContent(newValue: string | null) {\n\t\tnewValue = ifNullActAsIfEmptyString(newValue);\n\t\tstringReplaceAll(this, newValue);\n\t}\n\n\tpublic lookupPrefix(namespace: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\t\tnamespace = asNullableString(namespace);\n\n\t\t// 1. If namespace is null or the empty string, then return null.\n\t\tif (namespace === null || namespace === '') {\n\t\t\treturn null;\n\t\t}\n\n\t\t// 2. Switch on this:\n\t\t// Element - Return the result of locating a namespace prefix for it using namespace.\n\t\treturn locateNamespacePrefix(this, namespace);\n\t}\n\n\tpublic lookupNamespaceURI(prefix: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\t\tprefix = asNullableString(prefix);\n\n\t\t// 1. If prefix is the empty string, then set it to null.\n\t\tif (prefix === '') {\n\t\t\tprefix = null;\n\t\t}\n\n\t\t// 2. Return the result of running locate a namespace for this using prefix.\n\n\t\t// To locate a namespace for a node using prefix, switch on node: Element\n\t\t// 1. If its namespace is non-null and its namespace prefix is prefix, then return\n\t\t// namespace.\n\t\tif (this.namespaceURI !== null && this.prefix === prefix) {\n\t\t\treturn this.namespaceURI;\n\t\t}\n\n\t\t// 2. If it has an attribute whose namespace is the XMLNS namespace, namespace prefix is\n\t\t// \"xmlns\", and local name is prefix, or if prefix is null and it has an attribute whose\n\t\t// namespace is the XMLNS namespace, namespace prefix is null, and local name is \"xmlns\",\n\t\t// then return its value if it is not the empty string, and null otherwise.\n\t\tlet ns = null;\n\t\tif (prefix !== null) {\n\t\t\tconst attr = this.getAttributeNodeNS(XMLNS_NAMESPACE, prefix);\n\t\t\tif (attr && attr.prefix === 'xmlns') {\n\t\t\t\tns = attr.value;\n\t\t\t}\n\t\t} else {\n\t\t\tconst attr = this.getAttributeNodeNS(XMLNS_NAMESPACE, 'xmlns');\n\t\t\tif (attr && attr.prefix === null) {\n\t\t\t\tns = attr.value;\n\t\t\t}\n\t\t}\n\t\tif (ns !== null) {\n\t\t\treturn ns !== '' ? ns : null;\n\t\t}\n\n\t\t// 3. If its parent element is null, then return null.\n\t\tconst parentElement = this.parentElement;\n\t\tif (parentElement === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// 4. Return the result of running locate a namespace on its parent element using prefix.\n\t\treturn parentElement.lookupNamespaceURI(prefix);\n\t}\n\n\t// ChildNode\n\n\tpublic before(...nodes: (Node | string)[]): void {\n\t\tinsertNodesBefore(this, nodes);\n\t}\n\n\tpublic after(...nodes: (Node | string)[]): void {\n\t\tinsertNodesAfter(this, nodes);\n\t}\n\n\tpublic replaceWith(...nodes: (Node | string)[]): void {\n\t\treplaceWithNodes(this, nodes);\n\t}\n\n\tpublic remove(): void {\n\t\tremoveFromParent(this);\n\t}\n\n\t// ParentNode\n\n\tpublic get children(): Element[] {\n\t\treturn getChildren(this);\n\t}\n\n\tpublic firstElementChild: Element | null = null;\n\tpublic lastElementChild: Element | null = null;\n\tpublic childElementCount: number = 0;\n\n\tpublic prepend(...nodes: (Node | string)[]): void {\n\t\tprependNodes(this, nodes);\n\t}\n\n\tpublic append(...nodes: (Node | string)[]): void {\n\t\tappendNodes(this, nodes);\n\t}\n\n\tpublic replaceChildren(...nodes: (Node | string)[]): void {\n\t\treplaceChildren(this, nodes);\n\t}\n\n\t// NonDocumentTypeChildNode\n\n\tpublic get previousElementSibling(): Element | null {\n\t\treturn getPreviousElementSibling(this);\n\t}\n\n\tpublic get nextElementSibling(): Element | null {\n\t\treturn getNextElementSibling(this);\n\t}\n\n\t// Element\n\n\tpublic readonly namespaceURI: string | null;\n\tpublic readonly prefix: string | null;\n\tpublic readonly localName: string;\n\tpublic readonly tagName: string;\n\n\t/**\n\t * (non-standard) Use Document#createElement or Document#createElementNS to create an Element.\n\t *\n\t * @param namespace - Namespace for the element\n\t * @param prefix    - Prefix for the element\n\t * @param localName - Local name for the element\n\t */\n\tconstructor(namespace: string | null, prefix: string | null, localName: string) {\n\t\tsuper();\n\n\t\tthis.namespaceURI = namespace;\n\t\tthis.prefix = prefix;\n\t\tthis.localName = localName;\n\t\tthis.tagName = prefix === null ? localName : `${prefix}:${localName}`;\n\t}\n\n\t/**\n\t * Returns whether the element has any attributes.\n\t *\n\t * @returns True if the element has attributes, otherwise false\n\t */\n\tpublic hasAttributes(): boolean {\n\t\treturn this.attributes.length > 0;\n\t}\n\n\t/**\n\t * The attributes for the element.\n\t *\n\t * Non-standard: the spec defines this as a NamedNodeMap, while this implementation uses an\n\t * array.\n\t */\n\tpublic readonly attributes: Attr[] = [];\n\n\t/**\n\t * Get the value of the specified attribute.\n\t *\n\t * @param qualifiedName - The qualified name of the attribute\n\t *\n\t * @returns The value of the attribute, or null if no such attribute exists\n\t */\n\tpublic getAttribute(qualifiedName: string): string | null {\n\t\texpectArity(arguments, 1);\n\t\tqualifiedName = String(qualifiedName);\n\n\t\t// 1. Let attr be the result of getting an attribute given qualifiedName and the context\n\t\t// object.\n\t\tconst attr = getAttributeByName(qualifiedName, this);\n\n\t\t// 2. If attr is null, return null.\n\t\tif (attr === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// 3. Return attr’s value.\n\t\treturn attr.value;\n\t}\n\n\t/**\n\t * Get the value of the specified attribute.\n\t *\n\t * @param namespace - The namespace of the attribute\n\t * @param localName - The local name of the attribute\n\t *\n\t * @returns The value of the attribute, or null if no such attribute exists\n\t */\n\tpublic getAttributeNS(namespace: string | null, localName: string): string | null {\n\t\texpectArity(arguments, 2);\n\t\tnamespace = asNullableString(namespace);\n\t\tlocalName = String(localName);\n\n\t\t// 1. Let attr be the result of getting an attribute given namespace, localName, and the\n\t\t// this.\n\t\tconst attr = getAttributeByNamespaceAndLocalName(namespace, localName, this);\n\n\t\t// 2. If attr is null, return null.\n\t\tif (attr === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// 3. Return attr’s value.\n\t\treturn attr.value;\n\t}\n\n\t/**\n\t * Sets the value of the specified attribute.\n\t *\n\t * @param qualifiedName - The qualified name of the attribute\n\t * @param value         - The new value for the attribute\n\t */\n\tpublic setAttribute(qualifiedName: string, value: string): void {\n\t\texpectArity(arguments, 2);\n\t\tqualifiedName = String(qualifiedName);\n\t\tvalue = String(value);\n\n\t\t// 1. If qualifiedName does not match the Name production in XML, then throw an\n\t\t// InvalidCharacterError.\n\t\tif (!matchesNameProduction(qualifiedName)) {\n\t\t\tthrowInvalidCharacterError('The qualified name does not match the Name production');\n\t\t}\n\n\t\t// 2. If this is in the HTML namespace and its node document is an HTML\n\t\t// document, then set qualifiedName to qualifiedName in ASCII lowercase.\n\t\t// (html documents not implemented)\n\n\t\t// 3. Let attribute be the first attribute in this’s attribute list whose\n\t\t// qualified name is qualifiedName, and null otherwise.\n\t\tconst attribute = getAttributeByName(qualifiedName, this);\n\n\t\t// 4. If attribute is null, create an attribute whose local name is qualifiedName, value is\n\t\t// value, and node document is this’s node document, then append this attribute to\n\t\t// this, and then return.\n\t\tif (attribute === null) {\n\t\t\tconst context = getContext(this);\n\t\t\tconst attribute = new context.Attr(null, null, qualifiedName, value, this);\n\t\t\tattribute.ownerDocument = this.ownerDocument;\n\t\t\tappendAttribute(attribute, this);\n\t\t\treturn;\n\t\t}\n\n\t\t// 5. Change attribute to value.\n\t\tchangeAttribute(attribute, value);\n\t}\n\n\t/**\n\t * Sets the value of the specified attribute.\n\t *\n\t * @param namespace     - The namespace of the attribute\n\t * @param qualifiedName - The qualified name of the attribute\n\t * @param value         - The value for the attribute\n\t */\n\tpublic setAttributeNS(namespace: string | null, qualifiedName: string, value: string): void {\n\t\texpectArity(arguments, 3);\n\t\tnamespace = asNullableString(namespace);\n\t\tqualifiedName = String(qualifiedName);\n\t\tvalue = String(value);\n\n\t\t// 1. Let namespace, prefix, and localName be the result of passing namespace and\n\t\t// qualifiedName to validate and extract.\n\t\tconst {\n\t\t\tnamespace: validatedNamespace,\n\t\t\tprefix,\n\t\t\tlocalName,\n\t\t} = validateAndExtract(namespace, qualifiedName);\n\n\t\t// 2. Set an attribute value for this using localName, value, and also prefix\n\t\t// and namespace.\n\t\tsetAttributeValue(this, localName, value, prefix, validatedNamespace);\n\t}\n\n\t/**\n\t * Removes the specified attribute.\n\t *\n\t * @param qualifiedName - The qualified name of the attribute\n\t */\n\tpublic removeAttribute(qualifiedName: string): void {\n\t\texpectArity(arguments, 1);\n\t\tqualifiedName = String(qualifiedName);\n\n\t\tremoveAttributeByName(qualifiedName, this);\n\t}\n\n\t/**\n\t * Removes the specified attribute.\n\t *\n\t * @param namespace - The namespace of the attribute\n\t * @param localName - The local name of the attribute\n\t */\n\tpublic removeAttributeNS(namespace: string | null, localName: string): void {\n\t\texpectArity(arguments, 2);\n\t\tnamespace = asNullableString(namespace);\n\t\tlocalName = String(localName);\n\n\t\tremoveAttributeByNamespaceAndLocalName(namespace, localName, this);\n\t}\n\n\t/**\n\t * If force is not given, \"toggles\" qualifiedName, removing it if it is present and adding it if\n\t * it is not present. If force is true, adds qualifiedName. If force is false, removes\n\t * qualifiedName.\n\t *\n\t * Returns true if qualifiedName is now present, and false otherwise.\n\t *\n\t * @param qualifiedName - The qualified name of the attribute to toggle\n\t * @param force         - If true, adds the attribute, if false removes it\n\t */\n\tpublic toggleAttribute(qualifiedName: string, force?: boolean): boolean {\n\t\t// 1. If qualifiedName does not match the Name production in XML, then throw an\n\t\t// \"InvalidCharacterError\" DOMException.\n\t\tif (!matchesNameProduction(qualifiedName)) {\n\t\t\tthrowInvalidCharacterError('The qualified name does not match the Name production');\n\t\t}\n\n\t\t// 2. If this is in the HTML namespace and its node document is an HTML\n\t\t// document, then set qualifiedName to qualifiedName in ASCII lowercase.\n\t\t// (html documents not implemented)\n\n\t\t// 3. Let attribute be the first attribute in this’s attribute list whose\n\t\t// qualified name is qualifiedName, and null otherwise.\n\t\tconst attribute = getAttributeByName(qualifiedName, this);\n\n\t\t// 4. If attribute is null, then:\n\t\tif (attribute === null) {\n\t\t\t// 4.1. If force is not given or is true,\n\t\t\tif (force === undefined || force === true) {\n\t\t\t\t// ...create an attribute whose local name is qualifiedName, value is the empty\n\t\t\t\t// string, and node document is this’s node document,\n\t\t\t\tconst context = getContext(this);\n\t\t\t\tconst attribute = new context.Attr(null, null, qualifiedName, '', this);\n\t\t\t\tattribute.ownerDocument = this.ownerDocument;\n\t\t\t\t// ...then append this attribute to this,\n\t\t\t\tappendAttribute(attribute, this);\n\t\t\t\t// ...and then return true.\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// 4.2. Return false.\n\t\t\treturn false;\n\t\t}\n\n\t\t// 5. Otherwise, if force is not given or is false,\n\t\tif (force === undefined || force === false) {\n\t\t\t// ...remove an attribute given qualifiedName and this,\n\t\t\tremoveAttributeByName(qualifiedName, this);\n\t\t\t// ...and then return false.\n\t\t\treturn false;\n\t\t}\n\n\t\t// 6. Return true.\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns true if the specified attribute exists and false otherwise.\n\t *\n\t * @param qualifiedName - The qualified name of the attribute\n\t */\n\tpublic hasAttribute(qualifiedName: string): boolean {\n\t\texpectArity(arguments, 1);\n\t\tqualifiedName = String(qualifiedName);\n\n\t\t// 1. If this is in the HTML namespace and its node document is an HTML\n\t\t// document, then set qualifiedName to qualifiedName in ASCII lowercase.\n\t\t// (html documents not implemented)\n\n\t\t// 2. Return true if this has an attribute whose qualified name is\n\t\t// qualifiedName, and false otherwise.\n\t\treturn getAttributeByName(qualifiedName, this) !== null;\n\t}\n\n\t/**\n\t * Returns true if the specified attribute exists and false otherwise.\n\t *\n\t * @param namespace - The namespace of the attribute\n\t * @param localName - The local name of the attribute\n\t */\n\tpublic hasAttributeNS(namespace: string | null, localName: string): boolean {\n\t\texpectArity(arguments, 2);\n\t\tnamespace = asNullableString(namespace);\n\t\tlocalName = String(localName);\n\n\t\t// 1. If namespace is the empty string, set it to null.\n\t\t// (handled by getAttributeByNamespaceAndLocalName, called below)\n\t\t// 2. Return true if this has an attribute whose namespace is namespace and\n\t\t// local name is localName, and false otherwise.\n\t\treturn getAttributeByNamespaceAndLocalName(namespace, localName, this) !== null;\n\t}\n\n\t/**\n\t * Returns the specified attribute node, or null if no such attribute exists.\n\t *\n\t * @param qualifiedName - The qualified name of the attribute\n\t *\n\t * @returns The attribute, or null if no such attribute exists\n\t */\n\tpublic getAttributeNode(qualifiedName: string): Attr | null {\n\t\texpectArity(arguments, 1);\n\t\tqualifiedName = String(qualifiedName);\n\n\t\treturn getAttributeByName(qualifiedName, this);\n\t}\n\n\t/**\n\t * Returns the specified attribute node, or null if no such attribute exists.\n\t *\n\t * @param namespace - The namespace of the attribute\n\t * @param localName - The local name of the attribute\n\t *\n\t * @returns The attribute, or null if no such attribute exists\n\t */\n\tpublic getAttributeNodeNS(namespace: string | null, localName: string): Attr | null {\n\t\texpectArity(arguments, 2);\n\t\tnamespace = asNullableString(namespace);\n\t\tlocalName = String(localName);\n\n\t\treturn getAttributeByNamespaceAndLocalName(namespace, localName, this);\n\t}\n\n\t/**\n\t * Sets an attribute given its node\n\t *\n\t * @param attr - The attribute node to set\n\t *\n\t * @returns The previous attribute node for the attribute\n\t */\n\tpublic setAttributeNode(attr: Attr): Attr | null {\n\t\texpectArity(arguments, 1);\n\t\tattr = asObject(attr, Attr);\n\n\t\treturn setAttribute(attr, this);\n\t}\n\n\t/**\n\t * Sets an attribute given its node\n\t *\n\t * @param attr - The attribute node to set\n\t *\n\t * @returns The previous attribute node for the attribute\n\t */\n\tpublic setAttributeNodeNS(attr: Attr): Attr | null {\n\t\texpectArity(arguments, 1);\n\t\tattr = asObject(attr, Attr);\n\n\t\treturn setAttribute(attr, this);\n\t}\n\n\t/**\n\t * Removes an attribute given its node\n\t *\n\t * @param attr - The attribute node to remove\n\t *\n\t * @returns The removed attribute node\n\t */\n\tpublic removeAttributeNode(attr: Attr): Attr {\n\t\texpectArity(arguments, 1);\n\t\tattr = asObject(attr, Attr);\n\n\t\t// 1. If this’s attribute list does not contain attr, then throw a NotFoundError.\n\t\tif (this.attributes.indexOf(attr) < 0) {\n\t\t\tthrowNotFoundError('the specified attribute does not exist');\n\t\t}\n\n\t\t// 2. Remove attr.\n\t\tremoveAttribute(attr);\n\n\t\t// 3. Return attr.\n\t\treturn attr;\n\t}\n\n\t/**\n\t * Returns the list of elements with the given qualified name.\n\t *\n\t * @param qualifiedName - Qualified name of the elements to collect.\n\t *\n\t * @returns  The list of elements with matching qualified name.\n\t */\n\tpublic getElementsByTagName(qualifiedName: string): Element[] {\n\t\texpectArity(arguments, 1);\n\t\tqualifiedName = String(qualifiedName);\n\n\t\treturn getListOfElementsWithQualifiedName(qualifiedName, this);\n\t}\n\n\t/**\n\t * Returns the list of elements with the given namespace and local name.\n\t *\n\t * @param namespace - Namespace URI of the elements to collect.\n\t * @param localName - Local name of the elements to collect\n\t *\n\t * @returns  The list of elements with matching namespace and local name.\n\t */\n\tpublic getElementsByTagNameNS(namespace: string | null, localName: string): Element[] {\n\t\texpectArity(arguments, 2);\n\t\tnamespace = asNullableString(namespace);\n\t\tlocalName = String(localName);\n\n\t\treturn getListOfElementsWithNamespaceAndLocalName(namespace, localName, this);\n\t}\n\n\t/**\n\t * (non-standard) Creates a copy of the given node\n\t *\n\t * @param document - The node document to associate with the copy\n\t * @param other    - The node to copy\n\t *\n\t * @returns A shallow copy of the node\n\t */\n\tpublic _copy(document: Document): Element {\n\t\t// 2.1. Let copy be the result of creating an element, given document, node’s local name,\n\t\t// node’s namespace, node’s namespace prefix, and the value of node’s is attribute if\n\t\t// present (or null if not). The synchronous custom elements flag should be unset.\n\t\tconst copyElement = createElement(document, this.localName, this.namespaceURI, this.prefix);\n\n\t\t// 2.2. For each attribute in node’s attribute list:\n\t\tfor (const attr of this.attributes) {\n\t\t\t// 2.2.1. Let copyAttribute be a clone of attribute.\n\t\t\tconst copyAttribute = attr._copy(document);\n\n\t\t\t// 2.2.2. Append copyAttribute to copy.\n\t\t\tcopyElement.setAttributeNode(copyAttribute);\n\t\t}\n\n\t\treturn copyElement;\n\t}\n\n\t// From the DOM Parsing and Serialization spec\n\n\t/**\n\t * Returns a fragment of HTML or XML that represents the element's contents.\n\t */\n\tpublic get innerHTML() {\n\t\t// Return the result of invoking the fragment serializing algorithm on this\n\t\t// providing true for the require well-formed flag (this might throw an exception instead of\n\t\t// returning a string).\n\t\treturn serializeFragment(this, true);\n\t}\n\n\t/**\n\t * Returns a fragment of HTML or XML that represents the element and its contents.\n\t */\n\tpublic get outerHTML() {\n\t\t// Return the result of invoking the fragment serializing algorithm on a fictional node\n\t\t// whose only child is this providing true for the require well-formed flag\n\t\t// (this might throw an exception instead of returning a string).\n\t\treturn serializeFragment(this, true, true);\n\t}\n}\n\n/**\n * To create an element, given a document, localName, namespace, and optional prefix, is, and\n * synchronous custom elements flag, run these steps:\n *\n * @param document  - The node document for the new element\n * @param localName - The local name for the new element\n * @param namespace - The namespace URI for the new element, or null for the null namespace\n * @param prefix    - The prefix for the new element, or null for no prefix\n *\n * @returns The new element\n */\nexport function createElement(\n\tdocument: Document,\n\tlocalName: string,\n\tnamespace: string | null,\n\tprefix: string | null = null\n): Element {\n\t// 1. If prefix was not given, let prefix be null.\n\t// (handled by default)\n\n\t// 2. If is was not given, let is be null.\n\t// (custom elements not implemented)\n\n\t// 3. Let result be null.\n\tlet result = null;\n\n\t// 4. Let definition be the result of looking up a custom element definition given document,\n\t// namespace, localName, and is.\n\t// (custom elements not implemented)\n\n\t// 5. If definition is non-null, and definition’s name is not equal to its local name (i.e.,\n\t// definition represents a customized built-in element), then:\n\t// 5.1. Let interface be the element interface for localName and the HTML namespace.\n\t// 5.2. Set result to a new element that implements interface, with no attributes, namespace set\n\t// to the HTML namespace, namespace prefix set to prefix, local name set to localName, custom\n\t// element state set to \"undefined\", custom element definition set to null, is value set to is,\n\t// and node document set to document.\n\t// 5.3. If the synchronous custom elements flag is set, then run this step while catching any\n\t// exceptions:\n\t// 5.3.1. Upgrade element using definition.\n\t// 5.3.catch. If this step threw an exception, then:\n\t// 5.3.catch.1. Report the exception.\n\t// 5.3.catch.2. Set result's custom element state to \"failed\".\n\t// 5.4. Otherwise, enqueue a custom element upgrade reaction given result and definition.\n\t// (custom elements not implemented)\n\n\t// 6. Otherwise, if definition is non-null, then:\n\t// 6.1. If the synchronous custom elements flag is set, then run these steps while catching any\n\t// exceptions:\n\t// 6.1.1. Let C be definition’s constructor.\n\t// 6.1.2. Set result to the result of constructing C, with no arguments.\n\t// 6.1.3. Assert: result’s custom element state and custom element definition are initialized.\n\t// 6.1.4. Assert: result’s namespace is the HTML namespace.\n\t// IDL enforces that result is an HTMLElement object, which all use the HTML namespace.\n\t// 6.1.5. If result’s attribute list is not empty, then throw a NotSupportedError.\n\t// 6.1.6. If result has children, then throw a NotSupportedError.\n\t// 6.1.7. If result’s parent is non-null, then throw a NotSupportedError.\n\t// 6.1.8. If result’s node document is not document, then throw a NotSupportedError.\n\t// 6.1.9. If result’s local name is not equal to localName, then throw a NotSupportedError.\n\t// 6.1.10. Set result’s namespace prefix to prefix.\n\t// 6.1.11. Set result’s is value to null.\n\t// If any of these steps threw an exception, then:\n\t// 6.1.catch.1. Report the exception.\n\t// 6.1.catch.2. Set result to a new element that implements the HTMLUnknownElement interface,\n\t// with no attributes, namespace set to the HTML namespace, namespace prefix set to prefix,\n\t// local name set to localName, custom element state set to \"failed\", custom element definition\n\t// set to null, is value set to null, and node document set to document.\n\t// 6.2. Otherwise:\n\t// 6.2.1. Set result to a new element that implements the HTMLElement interface, with no\n\t// attributes, namespace set to the HTML namespace, namespace prefix set to prefix, local name\n\t// set to localName, custom element state set to \"undefined\", custom element definition set to\n\t// null, is value set to null, and node document set to document.\n\t// 6.2.2. Enqueue a custom element upgrade reaction given result and definition.\n\t// (custom elements not implemented)\n\n\t// 7. Otherwise:\n\t// 7.1. Let interface be the element interface for localName and namespace.\n\t// (interfaces other than Element not implemented)\n\n\t// 7.2. Set result to a new element that implements interface, with no attributes, namespace set\n\t// to namespace, namespace prefix set to prefix, local name set to localName, custom element\n\t// state set to \"uncustomized\", custom element definition set to null, is value set to is, and\n\t// node document set to document.\n\tconst context = getContext(document);\n\tresult = new context.Element(namespace, prefix, localName);\n\tresult.ownerDocument = document;\n\n\t// If namespace is the HTML namespace, and either localName is a valid custom element name or is\n\t// is non-null, then set result’s custom element state to \"undefined\".\n\t// (custom elements not implemented)\n\n\t// Return result.\n\treturn result;\n}\n\n/**\n * To get an attribute by name given a qualifiedName and element element, run these steps:\n *\n * @param qualifiedName - The qualified name of the attribute to get\n * @param element       - The element to get the attribute on\n *\n * @returns The first matching attribute, or null otherwise\n */\nfunction getAttributeByName(qualifiedName: string, element: Element): Attr | null {\n\t// 1. If element is in the HTML namespace and its node document is an HTML document, then set\n\t// qualifiedName to qualifiedName in ASCII lowercase.\n\t// (html documents not implemented)\n\n\t// 2. Return the first attribute in element’s attribute list whose qualified name is\n\t// qualifiedName, and null otherwise.\n\treturn element.attributes.find((attr) => attr.name === qualifiedName) || null;\n}\n\n/**\n * To get an attribute by namespace and local name given a namespace, localName, and element\n * element, run these steps:\n *\n * @param namespace - Namespace for the attribute\n * @param localName - Local name for the attribute\n * @param element   - The element to get the attribute on\n *\n * @returns The first matching attribute, or null otherwise\n */\nfunction getAttributeByNamespaceAndLocalName(\n\tnamespace: string | null,\n\tlocalName: string,\n\telement: Element\n): Attr | null {\n\t// 1. If namespace is the empty string, set it to null.\n\tif (namespace === '') {\n\t\tnamespace = null;\n\t}\n\n\t// 2. Return the attribute in element’s attribute list whose namespace is namespace and local\n\t// name is localName, if any, and null otherwise.\n\treturn (\n\t\telement.attributes.find(\n\t\t\t(attr) => attr.namespaceURI === namespace && attr.localName === localName\n\t\t) || null\n\t);\n}\n\n/**\n * To set an attribute given an attr and element, run these steps:\n *\n * @param attr    - The new attribute to set\n * @param element - The element to set attr on\n *\n * @returns The previous attribute with attr's namespace and local name, or null if there was no such\n *         attribute\n */\nfunction setAttribute(attr: Attr, element: Element): Attr | null {\n\t// 1. If attr’s element is neither null nor element, throw an InUseAttributeError.\n\tif (attr.ownerElement !== null && attr.ownerElement !== element) {\n\t\tthrowInUseAttributeError('attribute is in use by another element');\n\t}\n\n\t// 2. Let oldAttr be the result of getting an attribute given attr’s namespace, attr’s local\n\t// name, and element.\n\tconst oldAttr = getAttributeByNamespaceAndLocalName(attr.namespaceURI, attr.localName, element);\n\n\t// 3. If oldAttr is attr, return attr.\n\tif (oldAttr === attr) {\n\t\treturn attr;\n\t}\n\n\t// 4. If oldAttr is non-null, then replace oldAttr with attr.\n\tif (oldAttr !== null) {\n\t\treplaceAttribute(oldAttr, attr);\n\t} else {\n\t\t// 5. Otherwise, append attr to element.\n\t\tappendAttribute(attr, element);\n\t}\n\n\t// 6. Return oldAttr.\n\treturn oldAttr;\n}\n\n/**\n * To set an attribute value for an element element using a localName and value, and an optional\n * prefix, and namespace, run these steps:\n *\n * @param element   - Element to set the attribute value on\n * @param localName - Local name of the attribute\n * @param value     - New value of the attribute\n * @param prefix    - Prefix of the attribute\n * @param namespace - Namespace of the attribute\n */\nfunction setAttributeValue(\n\telement: Element,\n\tlocalName: string,\n\tvalue: string,\n\tprefix: string | null,\n\tnamespace: string | null\n): void {\n\t// 1. If prefix is not given, set it to null.\n\t// 2. If namespace is not given, set it to null.\n\t// (handled by default values)\n\n\t// 3. Let attribute be the result of getting an attribute given namespace, localName, and\n\t// element.\n\tconst attribute = getAttributeByNamespaceAndLocalName(namespace, localName, element);\n\n\t// 4. If attribute is null, create an attribute whose namespace is namespace, namespace prefix\n\t// is prefix, local name is localName, value is value, and node document is element’s node\n\t// document, then append this attribute to element, and then return.\n\tif (attribute === null) {\n\t\tconst context = getContext(element);\n\t\tconst attribute = new context.Attr(namespace, prefix, localName, value, element);\n\t\tattribute.ownerDocument = element.ownerDocument;\n\t\tappendAttribute(attribute, element);\n\t\treturn;\n\t}\n\n\t// 5. Change attribute to value.\n\tchangeAttribute(attribute, value);\n}\n\n/**\n * To remove an attribute by name given a qualifiedName and element element, run these steps:\n *\n * @param qualifiedName - Qualified name of the attribute\n * @param element       - The element to remove the attribute from\n *\n * @returns The removed attribute, or null if no matching attribute exists\n */\nfunction removeAttributeByName(qualifiedName: string, element: Element): Attr | null {\n\t// 1. Let attr be the result of getting an attribute given qualifiedName and element.\n\tconst attr = getAttributeByName(qualifiedName, element);\n\n\t// 2. If attr is non-null, then remove attr.\n\tif (attr !== null) {\n\t\tremoveAttribute(attr);\n\t}\n\n\t// 3. Return attr.\n\treturn attr;\n}\n\n/**\n * To remove an attribute by namespace and local name given a namespace, localName, and element\n * element, run these steps:\n *\n * @param namespace - The namespace of the attribute\n * @param localName - The local name of the attribute\n * @param element   - The element to remove the attribute from\n *\n * @returns The removed attribute, or null if no matching attribute exists\n */\nfunction removeAttributeByNamespaceAndLocalName(\n\tnamespace: string | null,\n\tlocalName: string,\n\telement: Element\n): Attr | null {\n\t// 1. Let attr be the result of getting an attribute given namespace, localName, and element.\n\tconst attr = getAttributeByNamespaceAndLocalName(namespace, localName, element);\n\n\t// 2. If attr is non-null, then remove attr.\n\tif (attr !== null) {\n\t\tremoveAttribute(attr);\n\t}\n\n\t// 3. Return attr.\n\treturn attr;\n}\n","import Document from '../Document';\nimport { createElement, default as Element } from '../Element';\nimport { validateAndExtract } from './namespaceHelpers';\n\n// 3.5. Interface Document\n\n/**\n * The internal createElementNS steps, given document, namespace, qualifiedName, and options, are as\n * follows:\n *\n * @param document      - The node document for the new element\n * @param namespace     - The namespace for the new element\n * @param qualifiedName - The qualified name for the new element\n *\n * @returns The new element\n */\nexport default function createElementNS(\n\tdocument: Document,\n\tnamespace: string | null,\n\tqualifiedName: string\n): Element {\n\t// 1. Let namespace, prefix, and localName be the result of passing namespace and qualifiedName\n\t// to validate and extract.\n\tconst {\n\t\tnamespace: validatedNamespace,\n\t\tprefix,\n\t\tlocalName,\n\t} = validateAndExtract(namespace, qualifiedName);\n\n\t// 2. Let is be the value of is member of options, or null if no such member exists.\n\t// (custom elements not implemented)\n\n\t// 3. Let element be the result of creating an element given document, localName, namespace,\n\t// prefix, is, and with the synchronous custom elements flag set.\n\tconst element = createElement(document, localName, validatedNamespace, prefix);\n\n\t// 4. If is is non-null, then set an attribute value for element using \"is\" and is.\n\t// (custom elements not implemented)\n\n\t// 5. Return element.\n\treturn element;\n}\n","import Document from './Document';\nimport DocumentType from './DocumentType';\nimport { createElement } from './Element';\nimport XMLDocument from './XMLDocument';\nimport { getContext } from './context/Context';\nimport createElementNS from './util/createElementNS';\nimport { expectArity } from './util/errorHelpers';\nimport { HTML_NAMESPACE, validateQualifiedName } from './util/namespaceHelpers';\nimport { asNullableObject, asNullableString, legacyNullToEmptyString } from './util/typeHelpers';\n\n/**\n * @public\n */\nexport default class DOMImplementation {\n\tprivate _document: Document;\n\n\t/**\n\t * (non-standard) Use Document#implementation to access instances of this class\n\t *\n\t * @param document - The document to associate with this instance\n\t */\n\tconstructor(document: Document) {\n\t\tthis._document = document;\n\t}\n\n\t/**\n\t * Returns a doctype, with the given qualifiedName, publicId, and systemId.\n\t *\n\t * @param qualifiedName - Qualified name for the doctype\n\t * @param publicId      - Public ID for the doctype\n\t * @param systemId      - System ID for the doctype\n\t *\n\t * @returns The new doctype node\n\t */\n\tcreateDocumentType(qualifiedName: string, publicId: string, systemId: string): DocumentType {\n\t\texpectArity(arguments, 3);\n\t\tqualifiedName = String(qualifiedName);\n\t\tpublicId = String(publicId);\n\t\tsystemId = String(systemId);\n\n\t\t// 1. Validate qualifiedName.\n\t\tvalidateQualifiedName(qualifiedName);\n\n\t\t// 2. Return a new doctype, with qualifiedName as its name, publicId as its public ID, and\n\t\t// systemId as its system ID, and with its node document set to the associated document of\n\t\t// this.\n\t\tconst context = getContext(this._document);\n\t\tconst doctype = new context.DocumentType(qualifiedName, publicId, systemId);\n\t\tdoctype.ownerDocument = this._document;\n\t\treturn doctype;\n\t}\n\n\t/**\n\t * Returns an XMLDocument, with a document element whose local name is qualifiedName and whose\n\t * namespace is namespace (unless qualifiedName is the empty string), and with doctype, if it is\n\t * given, as its doctype.\n\t *\n\t * @param namespace     - The namespace for the root element\n\t * @param qualifiedName - The qualified name for the root element, or empty string to not create\n\t *                        a root element\n\t * @param doctype       - The doctype for the new document, or null to not add a doctype\n\t *\n\t * @returns The new XMLDocument\n\t */\n\tcreateDocument(\n\t\tnamespace: string | null,\n\t\tqualifiedName: string | null,\n\t\tdoctype: DocumentType | null = null\n\t): XMLDocument {\n\t\texpectArity(arguments, 2);\n\t\tnamespace = asNullableString(namespace);\n\t\t// [LegacyNullToEmptyString] for qualifiedName\n\t\tqualifiedName = legacyNullToEmptyString(qualifiedName);\n\t\tdoctype = asNullableObject(doctype, DocumentType);\n\n\t\t// 1. Let document be a new XMLDocument.\n\t\tconst context = getContext(this._document);\n\t\tconst document = new context.XMLDocument();\n\n\t\t// 2. Let element be null.\n\t\tlet element = null;\n\n\t\t// 3. If qualifiedName is not the empty string, then set element to the result of running\n\t\t// the internal createElementNS steps, given document, namespace, qualifiedName, and an\n\t\t// empty dictionary.\n\t\tif (qualifiedName !== '') {\n\t\t\telement = createElementNS(document, namespace, qualifiedName);\n\t\t}\n\n\t\t// 4. If doctype is non-null, append doctype to document.\n\t\tif (doctype) {\n\t\t\tdocument.appendChild(doctype);\n\t\t}\n\n\t\t// 5. If element is non-null, append element to document.\n\t\tif (element) {\n\t\t\tdocument.appendChild(element);\n\t\t}\n\n\t\t// 6. document’s origin is this’s associated document’s origin.\n\t\t// (origin not implemented)\n\n\t\t// 7. document’s content type is determined by namespace:\n\t\t// HTML namespace: application/xhtml+xml\n\t\t// SVG namespace: image/svg+xml\n\t\t// Any other namespace: application/xml\n\t\t// (content type not implemented)\n\n\t\t// 8. Return document.\n\t\treturn document;\n\t}\n\n\t/**\n\t * Returns a HTML document with a basic tree already constructed.\n\t *\n\t * @param title - Optional title for the new HTML document\n\t *\n\t * @returns The new document\n\t */\n\tcreateHTMLDocument(title?: string | null): Document {\n\t\ttitle = asNullableString(title);\n\n\t\t// 1. Let doc be a new document that is an HTML document.\n\t\tconst context = getContext(this._document);\n\t\tconst doc = new context.Document();\n\n\t\t// 2. Set doc’s content type to \"text/html\".\n\t\t// (content type not implemented)\n\n\t\t// 3. Append a new doctype, with \"html\" as its name and with its node document set to doc,\n\t\t// to doc.\n\t\tconst doctype = new context.DocumentType('html');\n\t\tdoctype.ownerDocument = doc;\n\t\tdoc.appendChild(doctype);\n\n\t\t// 4. Append the result of creating an element given doc, html, and the HTML namespace, to\n\t\t// doc.\n\t\tconst htmlElement = createElement(doc, 'html', HTML_NAMESPACE);\n\t\tdoc.appendChild(htmlElement);\n\n\t\t// 5. Append the result of creating an element given doc, head, and the HTML namespace, to\n\t\t// the html element created earlier.\n\t\tconst headElement = createElement(doc, 'head', HTML_NAMESPACE);\n\t\thtmlElement.appendChild(headElement);\n\n\t\t// 6. If title is given:\n\t\tif (title !== null) {\n\t\t\t// 6.1. Append the result of creating an element given doc, title, and the HTML\n\t\t\t// namespace, to the head element created earlier.\n\t\t\tconst titleElement = createElement(doc, 'title', HTML_NAMESPACE);\n\t\t\theadElement.appendChild(titleElement);\n\n\t\t\t// 6.2. Append a new Text node, with its data set to title (which could be the empty\n\t\t\t// string) and its node document set to doc, to the title element created earlier.\n\t\t\ttitleElement.appendChild(doc.createTextNode(title));\n\t\t}\n\n\t\t// 7. Append the result of creating an element given doc, body, and the HTML namespace, to\n\t\t// the html element created earlier.\n\t\thtmlElement.appendChild(createElement(doc, 'body', HTML_NAMESPACE));\n\n\t\t// 8. doc’s origin is this’s associated document’s origin.\n\t\t// (origin not implemented)\n\n\t\t// 9. Return doc.\n\t\treturn doc;\n\t}\n}\n","import { NonElementParentNode, ParentNode, getChildren } from './mixins';\nimport Attr from './Attr';\nimport CDATASection from './CDATASection';\nimport Comment from './Comment';\nimport DocumentFragment from './DocumentFragment';\nimport DocumentType from './DocumentType';\nimport DOMImplementation from './DOMImplementation';\nimport { createElement, default as Element } from './Element';\nimport Node from './Node';\nimport ProcessingInstruction from './ProcessingInstruction';\nimport Text from './Text';\nimport Range from './Range';\nimport { getContext } from './context/Context';\nimport cloneNode from './util/cloneNode';\nimport createElementNS from './util/createElementNS';\nimport {\n\texpectArity,\n\tthrowInvalidCharacterError,\n\tthrowNotSupportedError,\n} from './util/errorHelpers';\nimport { adoptNode, appendNodes, prependNodes, replaceChildren } from './util/mutationAlgorithms';\nimport { NodeType, isNodeOfType } from './util/NodeType';\nimport { matchesNameProduction, validateAndExtract } from './util/namespaceHelpers';\nimport { asNullableString, asObject } from './util/typeHelpers';\nimport {\n\tgetListOfElementsWithNamespaceAndLocalName,\n\tgetListOfElementsWithQualifiedName,\n} from './util/treeHelpers';\n\n/**\n * 3.5. Interface Document\n *\n * @public\n */\nexport default class Document extends Node implements NonElementParentNode, ParentNode {\n\t// Node\n\n\tpublic get nodeType(): number {\n\t\treturn NodeType.DOCUMENT_NODE;\n\t}\n\n\tpublic get nodeName(): string {\n\t\treturn '#document';\n\t}\n\n\tpublic get nodeValue(): string | null {\n\t\treturn null;\n\t}\n\n\tpublic set nodeValue(_newValue: string | null) {\n\t\t// Do nothing.\n\t}\n\n\tpublic get textContent(): string | null {\n\t\treturn null;\n\t}\n\n\tpublic set textContent(_newValue: string | null) {\n\t\t// Do nothing.\n\t}\n\n\tpublic lookupPrefix(namespace: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\n\t\t// 1. If namespace is null or the empty string, then return null.\n\t\t// (not necessary due to recursion)\n\n\t\t// 2. Switch on this:\n\t\t// Document - Return the result of locating a namespace prefix for its document element, if\n\t\t// its document element is non-null, and null otherwise.\n\t\tif (this.documentElement !== null) {\n\t\t\treturn this.documentElement.lookupPrefix(namespace);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic lookupNamespaceURI(prefix: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\n\t\t// 1. If prefix is the empty string, then set it to null.\n\t\t// (not necessary due to recursion)\n\n\t\t// 2. Return the result of running locate a namespace for this using prefix.\n\n\t\t// To locate a namespace for a node using prefix, switch on node: Document\n\t\t// 1. If its document element is null, then return null.\n\t\tif (this.documentElement === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// 2. Return the result of running locate a namespace on its document element using prefix.\n\t\treturn this.documentElement.lookupNamespaceURI(prefix);\n\t}\n\n\t// ParentNode\n\n\tpublic get children(): Element[] {\n\t\treturn getChildren(this);\n\t}\n\n\tpublic firstElementChild: Element | null = null;\n\tpublic lastElementChild: Element | null = null;\n\tpublic childElementCount: number = 0;\n\n\tpublic prepend(...nodes: (Node | string)[]): void {\n\t\tprependNodes(this, nodes);\n\t}\n\n\tpublic append(...nodes: (Node | string)[]): void {\n\t\tappendNodes(this, nodes);\n\t}\n\n\tpublic replaceChildren(...nodes: (Node | string)[]): void {\n\t\treplaceChildren(this, nodes);\n\t}\n\n\t// Document\n\n\t/**\n\t * Returns a reference to the DOMImplementation object associated with the document.\n\t */\n\tpublic readonly implementation: DOMImplementation = new DOMImplementation(this);\n\n\t/**\n\t * The doctype, or null if there is none.\n\t */\n\tpublic doctype: DocumentType | null = null;\n\n\t/**\n\t * The document element, or null if there is none.\n\t */\n\tpublic documentElement: Element | null = null;\n\n\t/**\n\t * Creates a new Document.\n\t *\n\t * Note: Unlike DOMImplementation#createDocument(), this constructor does not return an\n\t * XMLDocument object, but a document (Document object).\n\t */\n\tconstructor() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * Returns the list of elements with the given qualified name.\n\t *\n\t * @param qualifiedName - Qualified name of the elements to collect.\n\t *\n\t * @returns  The list of elements with matching qualified name.\n\t */\n\tpublic getElementsByTagName(qualifiedName: string): Element[] {\n\t\texpectArity(arguments, 1);\n\t\tqualifiedName = String(qualifiedName);\n\n\t\treturn getListOfElementsWithQualifiedName(qualifiedName, this);\n\t}\n\n\t/**\n\t * Returns the list of elements with the given namespace and local name.\n\t *\n\t * @param namespace - Namespace URI of the elements to collect.\n\t * @param localName - Local name of the elements to collect\n\t *\n\t * @returns  The list of elements with matching namespace and local name.\n\t */\n\tpublic getElementsByTagNameNS(namespace: string | null, localName: string): Element[] {\n\t\texpectArity(arguments, 2);\n\t\tnamespace = asNullableString(namespace);\n\t\tlocalName = String(localName);\n\n\t\treturn getListOfElementsWithNamespaceAndLocalName(namespace, localName, this);\n\t}\n\n\t/**\n\t * Creates a new element in the null namespace.\n\t *\n\t * @param localName - Local name of the element\n\t *\n\t * @returns The new element\n\t */\n\tpublic createElement(localName: string): Element {\n\t\texpectArity(arguments, 1);\n\t\tlocalName = String(localName);\n\n\t\t// 1. If localName does not match the Name production, then throw an InvalidCharacterError.\n\t\tif (!matchesNameProduction(localName)) {\n\t\t\tthrowInvalidCharacterError('The local name is not a valid Name');\n\t\t}\n\n\t\t// 2. If this is an HTML document, then set localName to localName in ASCII\n\t\t// lowercase.\n\t\t// (html documents not implemented)\n\n\t\t// 3. Let is be the value of is member of options, or null if no such member exists.\n\t\t// (custom elements not implemented)\n\n\t\t// 4. Let namespace be the HTML namespace, if this is an HTML document or\n\t\t// this’s content type is \"application/xhtml+xml\", and null otherwise.\n\t\t// (html documents not implemented)\n\t\tconst namespace: string | null = null;\n\n\t\t// 5. Let element be the result of creating an element given this, localName,\n\t\t// namespace, null, is, and with the synchronous custom elements flag set.\n\t\tconst element = createElement(this, localName, namespace, null);\n\n\t\t// 6. If is is non-null, then set an attribute value for element using \"is\" and is.\n\t\t// (custom elements not implemented)\n\n\t\t// 7. Return element.\n\t\treturn element;\n\t}\n\n\t/**\n\t * Creates a new element in the given namespace.\n\t *\n\t * @param namespace     - Namespace URI for the new element\n\t * @param qualifiedName - Qualified name for the new element\n\t *\n\t * @returns The new element\n\t */\n\tpublic createElementNS(namespace: string | null, qualifiedName: string): Element {\n\t\texpectArity(arguments, 2);\n\t\tnamespace = asNullableString(namespace);\n\t\tqualifiedName = String(qualifiedName);\n\n\t\t// return the result of running the internal createElementNS steps, given this,\n\t\t// namespace, qualifiedName, and options.\n\t\treturn createElementNS(this, namespace, qualifiedName);\n\t}\n\n\t/**\n\t * Returns a new DocumentFragment node with its node document set to this.\n\t *\n\t * @returns The new document fragment\n\t */\n\tpublic createDocumentFragment(): DocumentFragment {\n\t\tconst context = getContext(this);\n\t\tconst documentFragment = new context.DocumentFragment();\n\t\tdocumentFragment.ownerDocument = this;\n\t\treturn documentFragment;\n\t}\n\n\t/**\n\t * Returns a new Text node with its data set to data and node document set to this.\n\t *\n\t * @param data - Data for the new text node\n\t *\n\t * @returns The new text node\n\t */\n\tpublic createTextNode(data: string): Text {\n\t\texpectArity(arguments, 1);\n\t\tdata = String(data);\n\n\t\tconst context = getContext(this);\n\t\tconst text = new context.Text(data);\n\t\ttext.ownerDocument = this;\n\t\treturn text;\n\t}\n\n\t/**\n\t * Returns a new CDATA section with the given data and node document set to this.\n\t *\n\t * @param data - Data for the new CDATA section\n\t *\n\t * @returns The new CDATA section\n\t */\n\tpublic createCDATASection(data: string): CDATASection {\n\t\texpectArity(arguments, 1);\n\t\tdata = String(data);\n\n\t\t// 1. If this is an HTML document, then throw a NotSupportedError.\n\t\t// (html documents not implemented)\n\n\t\t// 2. If data contains the string \"]]>\", then throw an InvalidCharacterError.\n\t\tif (data.indexOf(']]>') >= 0) {\n\t\t\tthrowInvalidCharacterError('Data must not contain the string \"]]>\"');\n\t\t}\n\n\t\t// 3. Return a new CDATASection node with its data set to data and node document set to the\n\t\t// this.\n\t\tconst context = getContext(this);\n\t\tconst cdataSection = new context.CDATASection(data);\n\t\tcdataSection.ownerDocument = this;\n\t\treturn cdataSection;\n\t}\n\n\t/**\n\t * Returns a new Comment node with its data set to data and node document set to this.\n\t *\n\t * @param data - Data for the new comment\n\t *\n\t * @returns The new comment node\n\t */\n\tpublic createComment(data: string): Comment {\n\t\texpectArity(arguments, 1);\n\t\tdata = String(data);\n\n\t\tconst context = getContext(this);\n\t\tconst comment = new context.Comment(data);\n\t\tcomment.ownerDocument = this;\n\t\treturn comment;\n\t}\n\n\t/**\n\t * Creates a new processing instruction node, with target set to target, data set to data, and\n\t * node document set to this.\n\t *\n\t * @param target - Target for the new processing instruction\n\t * @param data   - Data for the new processing instruction\n\t *\n\t * @returns The new processing instruction\n\t */\n\tpublic createProcessingInstruction(target: string, data: string): ProcessingInstruction {\n\t\texpectArity(arguments, 2);\n\t\ttarget = String(target);\n\t\tdata = String(data);\n\n\t\t// 1. If target does not match the Name production, then throw an InvalidCharacterError.\n\t\tif (!matchesNameProduction(target)) {\n\t\t\tthrowInvalidCharacterError('The target is not a valid Name');\n\t\t}\n\n\t\t// 2. If data contains the string \"?>\", then throw an InvalidCharacterError.\n\t\tif (data.indexOf('?>') >= 0) {\n\t\t\tthrowInvalidCharacterError('Data must not contain the string \"?>\"');\n\t\t}\n\n\t\t// 3. Return a new ProcessingInstruction node, with target set to target, data set to data,\n\t\t// and node document set to this.\n\t\tconst context = getContext(this);\n\t\tconst pi = new context.ProcessingInstruction(target, data);\n\t\tpi.ownerDocument = this;\n\t\treturn pi;\n\n\t\t// Note: No check is performed that target contains \"xml\" or \":\", or that data contains\n\t\t// characters that match the Char production.\n\t}\n\n\t/**\n\t * Creates a copy of a node from an external document that can be inserted into the current\n\t * document.\n\t *\n\t * @param node - The node to import\n\t * @param deep - Whether to also import node's children\n\t */\n\tpublic importNode<TNode extends Node>(node: TNode, deep: boolean = false): TNode {\n\t\texpectArity(arguments, 1);\n\t\tnode = asObject(node, Node);\n\n\t\t// 1. If node is a document or shadow root, then throw a NotSupportedError.\n\t\tif (isNodeOfType(node, NodeType.DOCUMENT_NODE)) {\n\t\t\tthrowNotSupportedError('importing a Document node is not supported');\n\t\t}\n\n\t\t// 2. Return a clone of node, with this and the clone children flag set if deep is\n\t\t// true.\n\t\treturn cloneNode(node, deep, this);\n\t}\n\n\t/**\n\t * Adopts a node. The node and its subtree is removed from the document it's in (if any), and\n\t * its ownerDocument is changed to the current document. The node can then be inserted into the\n\t * current document.\n\t *\n\t * @param node - The node to adopt\n\t */\n\tpublic adoptNode<TNode extends Node>(node: TNode): TNode {\n\t\texpectArity(arguments, 1);\n\t\tnode = asObject(node, Node);\n\n\t\t// 1. If node is a document, then throw a NotSupportedError.\n\t\tif (isNodeOfType(node, NodeType.DOCUMENT_NODE)) {\n\t\t\tthrowNotSupportedError('adopting a Document node is not supported');\n\t\t}\n\n\t\t// 2. If node is a shadow root, then throw a HierarchyRequestError.\n\t\t// 3. If node is a DocumentFragment node and its host is non-null, then return node.\n\t\t// Note: unfortunately this does not throw for web compatibility.\n\t\t// (shadow dom and HTML templates not implemented)\n\n\t\t// 4. Adopt node into this.\n\t\tadoptNode(node, this);\n\n\t\t// 5. Return node.\n\t\treturn node;\n\t}\n\n\t/**\n\t * Creates a new attribute node with the null namespace and given local name.\n\t *\n\t * @param localName - The local name of the attribute\n\t *\n\t * @returns The new attribute node\n\t */\n\tpublic createAttribute(localName: string): Attr {\n\t\texpectArity(arguments, 1);\n\t\tlocalName = String(localName);\n\n\t\t// 1. If localName does not match the Name production in XML, then throw an\n\t\t// InvalidCharacterError.\n\t\tif (!matchesNameProduction(localName)) {\n\t\t\tthrowInvalidCharacterError('The local name is not a valid Name');\n\t\t}\n\n\t\t// 2. If this is an HTML document, then set localName to localName in ASCII\n\t\t// lowercase.\n\t\t// (html documents not implemented)\n\n\t\t// 3. Return a new attribute whose local name is localName and node document is context\n\t\t// object.\n\t\tconst context = getContext(this);\n\t\tconst attr = new context.Attr(null, null, localName, '', null);\n\t\tattr.ownerDocument = this;\n\t\treturn attr;\n\t}\n\n\t/**\n\t * Creates a new attribute node with the given namespace and qualified name.\n\t *\n\t * @param namespace     - Namespace URI for the new attribute, or null for the null namespace\n\t * @param qualifiedName - Qualified name for the new attribute\n\t *\n\t * @returns The new attribute node\n\t */\n\tpublic createAttributeNS(namespace: string | null, qualifiedName: string): Attr {\n\t\texpectArity(arguments, 2);\n\t\tnamespace = asNullableString(namespace);\n\t\tqualifiedName = String(qualifiedName);\n\n\t\t// 1. Let namespace, prefix, and localName be the result of passing namespace and\n\t\t// qualifiedName to validate and extract.\n\t\tconst {\n\t\t\tnamespace: validatedNamespace,\n\t\t\tprefix,\n\t\t\tlocalName,\n\t\t} = validateAndExtract(namespace, qualifiedName);\n\n\t\t// 2. Return a new attribute whose namespace is namespace, namespace prefix is prefix, local\n\t\t// name is localName, and node document is this.\n\t\tconst context = getContext(this);\n\t\tconst attr = new context.Attr(validatedNamespace, prefix, localName, '', null);\n\t\tattr.ownerDocument = this;\n\t\treturn attr;\n\t}\n\n\t/**\n\t * Creates a new live Range, initially positioned at the root of this document.\n\t *\n\t * @returns The new Range\n\t */\n\tpublic createRange(): Range {\n\t\tconst context = getContext(this);\n\t\tconst range = new context.Range();\n\t\trange.startContainer = this;\n\t\trange.startOffset = 0;\n\t\trange.endContainer = this;\n\t\trange.endOffset = 0;\n\t\treturn range;\n\t}\n\n\t/**\n\t * (non-standard) Creates a copy of this, not including its children.\n\t *\n\t * @param document - The node document to associate with the copy\n\t *\n\t * @returns A shallow copy of this\n\t */\n\tpublic _copy(document: Document): Document {\n\t\t// Set copy’s encoding, content type, URL, origin, type, and mode, to those of node.\n\t\t// (properties not implemented)\n\n\t\tconst context = getContext(document);\n\t\treturn new context.Document();\n\t}\n}\n","import { NonElementParentNode, ParentNode, getChildren } from './mixins';\nimport Document from './Document';\nimport Element from './Element';\nimport Node from './Node';\nimport { getContext } from './context/Context';\nimport { expectArity } from './util/errorHelpers';\nimport {\n\tappendNodes,\n\tprependNodes,\n\tgetDescendantTextContent,\n\tstringReplaceAll,\n\treplaceChildren,\n} from './util/mutationAlgorithms';\nimport { NodeType } from './util/NodeType';\nimport { ifNullActAsIfEmptyString } from './util/typeHelpers';\n\n/**\n * @public\n */\nexport default class DocumentFragment extends Node implements NonElementParentNode, ParentNode {\n\t// Node\n\n\tpublic get nodeType(): number {\n\t\treturn NodeType.DOCUMENT_FRAGMENT_NODE;\n\t}\n\n\tpublic get nodeName(): string {\n\t\treturn '#document-fragment';\n\t}\n\n\tpublic get nodeValue(): string | null {\n\t\treturn null;\n\t}\n\n\tpublic set nodeValue(newValue: string | null) {\n\t\t// Do nothing.\n\t}\n\n\tpublic get textContent(): string | null {\n\t\t// Return the descendant text content of this\n\t\treturn getDescendantTextContent(this);\n\t}\n\n\tpublic set textContent(newValue: string | null) {\n\t\tnewValue = ifNullActAsIfEmptyString(newValue);\n\t\tstringReplaceAll(this, newValue);\n\t}\n\n\tpublic lookupPrefix(namespace: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\n\t\t// 1. If namespace is null or the empty string, then return null.\n\t\t// (not necessary due to return value)\n\n\t\t// 2. Switch on this:\n\t\t// DocumentFragment - Return null\n\t\treturn null;\n\t}\n\n\tpublic lookupNamespaceURI(prefix: string | null): string | null {\n\t\texpectArity(arguments, 1);\n\n\t\t// 1. If prefix is the empty string, then set it to null.\n\t\t// (not necessary due to return value)\n\n\t\t// 2. Return the result of running locate a namespace for this using prefix.\n\n\t\t// To locate a namespace for a node using prefix, switch on node: DocumentFragment\n\t\t// Return null.\n\t\treturn null;\n\t}\n\n\t// ParentNode\n\n\tpublic get children(): Element[] {\n\t\treturn getChildren(this);\n\t}\n\n\tpublic firstElementChild: Element | null = null;\n\tpublic lastElementChild: Element | null = null;\n\tpublic childElementCount: number = 0;\n\n\tpublic prepend(...nodes: (Node | string)[]): void {\n\t\tprependNodes(this, nodes);\n\t}\n\n\tpublic append(...nodes: (Node | string)[]): void {\n\t\tappendNodes(this, nodes);\n\t}\n\n\tpublic replaceChildren(...nodes: (Node | string)[]): void {\n\t\treplaceChildren(this, nodes);\n\t}\n\n\t/**\n\t * Return a new DocumentFragment node whose node document is current global object’s associated\n\t * Document.\n\t */\n\tconstructor() {\n\t\tsuper();\n\n\t\tconst context = getContext(this);\n\t\tthis.ownerDocument = context.document;\n\t}\n\n\t/**\n\t * (non-standard) Creates a copy of this, not including its children.\n\t *\n\t * @param document - The node document to associate with the copy\n\t *\n\t * @returns A shallow copy of this\n\t */\n\tpublic _copy(document: Document): DocumentFragment {\n\t\tconst context = getContext(document);\n\t\tconst copy = new context.DocumentFragment();\n\t\tcopy.ownerDocument = document;\n\t\treturn copy;\n\t}\n}\n","import CharacterData from './CharacterData';\nimport Document from './Document';\nimport { getContext } from './context/Context';\nimport { NodeType } from './util/NodeType';\n\n/**\n * 3.13. Interface ProcessingInstruction\n *\n * @public\n */\nexport default class ProcessingInstruction extends CharacterData {\n\t// Node\n\n\tpublic get nodeType(): number {\n\t\treturn NodeType.PROCESSING_INSTRUCTION_NODE;\n\t}\n\n\tpublic get nodeName(): string {\n\t\treturn this.target;\n\t}\n\n\t// ProcessingInstruction\n\n\tpublic target: string;\n\n\t/**\n\t * (non-standard) Use Document#createProcessingInstruction to create a processing instruction.\n\t *\n\t * @param target - The target of the processing instruction\n\t * @param data   - The data of the processing instruction\n\t */\n\tconstructor(target: string, data: string) {\n\t\tsuper(data);\n\n\t\tthis.target = target;\n\t}\n\n\t/**\n\t * (non-standard) Creates a copy of this, not including its children.\n\t *\n\t * @param document - The node document to associate with the copy\n\t *\n\t * @returns A shallow copy of this\n\t */\n\tpublic _copy(document: Document): ProcessingInstruction {\n\t\t// Set copy’s target and data to those of node.\n\t\tconst context = getContext(document);\n\t\tconst copy = new context.ProcessingInstruction(this.target, this.data);\n\t\tcopy.ownerDocument = document;\n\t\treturn copy;\n\t}\n}\n","import Node from './Node';\nimport { getContext } from './context/Context';\nimport {\n\texpectArity,\n\tthrowIndexSizeError,\n\tthrowInvalidNodeTypeError,\n\tthrowNotSupportedError,\n\tthrowWrongDocumentError,\n} from './util/errorHelpers';\nimport { NodeType, isNodeOfType } from './util/NodeType';\nimport {\n\tdetermineLengthOfNode,\n\tgetInclusiveAncestors,\n\tgetNodeIndex,\n\tgetRootOfNode,\n} from './util/treeHelpers';\nimport { asObject, asUnsignedLong } from './util/typeHelpers';\n\n/**\n * Interface AbstractRange\n *\n * Objects implementing the AbstractRange interface are known as ranges.\n *\n * @public\n */\nexport interface AbstractRange {\n\treadonly startContainer: Node;\n\treadonly startOffset: number;\n\treadonly endContainer: Node;\n\treadonly endOffset: number;\n\treadonly collapsed: boolean;\n}\n\ninterface StaticRangeInit {\n\tstartContainer: Node;\n\tstartOffset: number;\n\tendContainer: Node;\n\tendOffset: number;\n}\n\n/**\n * Interface StaticRange\n *\n * Updating live ranges in response to node tree mutations can be expensive. For every node tree\n * change, all affected Range objects need to be updated. Even if the application is uninterested in\n * some live ranges, it still has to pay the cost of keeping them up-to-date when a mutation occurs.\n *\n * A StaticRange object is a lightweight range that does not update when the node tree mutates. It\n * is therefore not subject to the same maintenance cost as live ranges.\n *\n * @public\n */\nexport class StaticRange implements AbstractRange {\n\tpublic readonly startContainer: Node;\n\tpublic readonly startOffset: number;\n\tpublic readonly endContainer: Node;\n\tpublic readonly endOffset: number;\n\tpublic readonly collapsed: boolean;\n\n\t/**\n\t * The StaticRange(init) constructor, when invoked, must run these steps:\n\t *\n\t * @param init - Dictionary representing the properties to set on the StaticRange\n\t */\n\tconstructor(init: StaticRangeInit) {\n\t\t// 1. If init’s startContainer or endContainer is a DocumentType or Attr node, then throw an\n\t\t// \"InvalidNodeTypeError\" DOMException.\n\t\tif (\n\t\t\tisNodeOfType(init.startContainer, NodeType.DOCUMENT_TYPE_NODE, NodeType.ATTRIBUTE_NODE)\n\t\t) {\n\t\t\tthrowInvalidNodeTypeError(\n\t\t\t\t'StaticRange startContainer must not be a doctype or attribute node'\n\t\t\t);\n\t\t}\n\t\tif (isNodeOfType(init.endContainer, NodeType.DOCUMENT_TYPE_NODE, NodeType.ATTRIBUTE_NODE)) {\n\t\t\tthrowInvalidNodeTypeError(\n\t\t\t\t'StaticRange endContainer must not be a doctype or attribute node'\n\t\t\t);\n\t\t}\n\n\t\t// 2. Let staticRange be a new StaticRange object.\n\t\t// 3. Set staticRange’s start to (init’s startContainer, init’s startOffset) and end to\n\t\t// (init’s endContainer, init’s endOffset).\n\t\tthis.startContainer = init.startContainer;\n\t\tthis.startOffset = init.startOffset;\n\t\tthis.endContainer = init.endContainer;\n\t\tthis.endOffset = init.endOffset;\n\t\tthis.collapsed =\n\t\t\tthis.startContainer === this.endContainer && this.startOffset === this.endOffset;\n\n\t\t// 4. Return staticRange.\n\t}\n}\n\n/**\n * A range is collapsed if its start node is its end node and its start offset is its end offset.\n *\n * @param range - The range to check\n */\nfunction isCollapsed(range: AbstractRange): boolean {\n\treturn range.startContainer === range.endContainer && range.startOffset === range.endOffset;\n}\n\n/**\n * Interface Range\n *\n * Objects implementing the Range interface are known as live ranges.\n *\n * @public\n */\nexport default class Range implements AbstractRange {\n\tpublic startContainer: Node;\n\tpublic startOffset: number;\n\tpublic endContainer: Node;\n\tpublic endOffset: number;\n\n\tpublic get collapsed(): boolean {\n\t\treturn isCollapsed(this);\n\t}\n\n\t/**\n\t * Get the common ancestor of the range's boundary position nodes.\n\t *\n\t * Note: for efficiency reasons, this implementation deviates from the algorithm given in 4.2.\n\t */\n\tpublic get commonAncestorContainer(): Node {\n\t\tconst ancestors1 = getInclusiveAncestors(this.startContainer);\n\t\tconst ancestors2 = getInclusiveAncestors(this.endContainer);\n\t\tlet commonAncestorContainer = ancestors1[0];\n\t\tlet i = 0;\n\t\twhile (i < ancestors1.length && i < ancestors2.length) {\n\t\t\tif (ancestors1[i] !== ancestors2[i]) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcommonAncestorContainer = ancestors1[i];\n\t\t\t++i;\n\t\t}\n\n\t\treturn commonAncestorContainer;\n\t}\n\n\t/**\n\t * The Range() constructor, when invoked, must return a new live range with (current global\n\t * object’s associated Document, 0) as its start and end.\n\t */\n\tconstructor() {\n\t\tconst context = getContext(this);\n\t\tthis.startContainer = context.document;\n\t\tthis.startOffset = 0;\n\t\tthis.endContainer = context.document;\n\t\tthis.endOffset = 0;\n\t\tcontext.addRange(this);\n\t}\n\n\t/**\n\t * Sets the start boundary point of the range.\n\t *\n\t * @param node   - The new start container\n\t * @param offset - The new start offset\n\t */\n\tsetStart(node: Node, offset: number): void {\n\t\texpectArity(arguments, 2);\n\t\tnode = asObject(node, Node);\n\t\toffset = asUnsignedLong(offset);\n\n\t\t// 1. If node is a doctype, then throw an InvalidNodeTypeError.\n\t\tif (isNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE)) {\n\t\t\tthrowInvalidNodeTypeError('Can not set a range under a doctype node');\n\t\t}\n\n\t\t// 2. If offset is greater than node’s length, then throw an IndexSizeError.\n\t\tif (offset > determineLengthOfNode(node)) {\n\t\t\tthrowIndexSizeError('Can not set a range past the end of the node');\n\t\t}\n\n\t\t// 3. Let bp be the boundary point (node, offset).\n\t\t// 4.a. If these steps were invoked as \"set the start\"\n\t\t// 4.a.1. If range’s root is not equal to node’s root, or if bp is after the range’s end,\n\t\t// set range’s end to bp.\n\t\tconst rootOfRange = getRootOfRange(this);\n\t\tconst rootOfNode = getRootOfNode(node);\n\t\tif (\n\t\t\trootOfRange !== rootOfNode ||\n\t\t\tcompareBoundaryPointPositions(node, offset, this.endContainer, this.endOffset) ===\n\t\t\t\tPOSITION_AFTER\n\t\t) {\n\t\t\tthis.endContainer = node;\n\t\t\tthis.endOffset = offset;\n\t\t}\n\t\t// 4.a.2. Set range’s start to bp.\n\t\tthis.startContainer = node;\n\t\tthis.startOffset = offset;\n\n\t\t// 4.b. If these steps were invoked as \"set the end\"\n\t\t// 4.b.1. If range’s root is not equal to node’s root, or if bp is before the range’s start,\n\t\t// set range’s start to bp.\n\t\t// 4.b.2. Set range’s end to bp.\n\t\t// (see Range#setEnd for this branch)\n\t}\n\n\t/**\n\t * Sets the end boundary point of the range.\n\t *\n\t * @param node   - The new end container\n\t * @param offset - The new end offset\n\t */\n\tsetEnd(node: Node, offset: number): void {\n\t\texpectArity(arguments, 2);\n\t\tnode = asObject(node, Node);\n\t\toffset = asUnsignedLong(offset);\n\n\t\t// 1. If node is a doctype, then throw an InvalidNodeTypeError.\n\t\tif (isNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE)) {\n\t\t\tthrowInvalidNodeTypeError('Can not set a range under a doctype node');\n\t\t}\n\n\t\t// 2. If offset is greater than node’s length, then throw an IndexSizeError.\n\t\tif (offset > determineLengthOfNode(node)) {\n\t\t\tthrowIndexSizeError('Can not set a range past the end of the node');\n\t\t}\n\n\t\t// 3. Let bp be the boundary point (node, offset).\n\t\t// 4.a. If these steps were invoked as \"set the start\"\n\t\t// 4.a.1. If range’s root is not equal to node’s root, or if bp is after the range’s end,\n\t\t// set range’s end to bp.\n\t\t// 4.a.2. Set range’s start to bp.\n\t\t// (see Range#setStart for this branch)\n\n\t\t// 4.b. If these steps were invoked as \"set the end\"\n\t\t// 4.b.1. If range’s root is not equal to node’s root, or if bp is before the range’s start,\n\t\t// set range’s start to bp.\n\t\tconst rootOfRange = getRootOfRange(this);\n\t\tconst rootOfNode = getRootOfNode(node);\n\t\tif (\n\t\t\trootOfRange !== rootOfNode ||\n\t\t\tcompareBoundaryPointPositions(node, offset, this.startContainer, this.startOffset) ===\n\t\t\t\tPOSITION_BEFORE\n\t\t) {\n\t\t\tthis.startContainer = node;\n\t\t\tthis.startOffset = offset;\n\t\t}\n\t\t// 4.b.2. Set range’s end to bp.\n\t\tthis.endContainer = node;\n\t\tthis.endOffset = offset;\n\t}\n\n\t/**\n\t * Sets the start boundary point of the range to the position just before the given node.\n\t *\n\t * @param node - The node to set the range's start before\n\t */\n\tsetStartBefore(node: Node): void {\n\t\texpectArity(arguments, 1);\n\t\tnode = asObject(node, Node);\n\n\t\t// 1. Let parent be node’s parent.\n\t\tconst parent = node.parentNode;\n\n\t\t// 2. If parent is null, then throw an InvalidNodeTypeError.\n\t\tif (parent === null) {\n\t\t\treturn throwInvalidNodeTypeError('Can not set range before node without a parent');\n\t\t}\n\n\t\t// 3. Set the start of this to boundary point (parent, node’s index).\n\t\tthis.setStart(parent, getNodeIndex(node));\n\t}\n\n\t/**\n\t * Sets the start boundary point of the range to the position just after the given node.\n\t *\n\t * @param node - The node to set the range's start before\n\t */\n\tsetStartAfter(node: Node): void {\n\t\texpectArity(arguments, 1);\n\t\tnode = asObject(node, Node);\n\n\t\t// 1. Let parent be node’s parent.\n\t\tconst parent = node.parentNode;\n\n\t\t// 2. If parent is null, then throw an InvalidNodeTypeError.\n\t\tif (parent === null) {\n\t\t\treturn throwInvalidNodeTypeError('Can not set range before node without a parent');\n\t\t}\n\n\t\t// 3. Set the start of this to boundary point (parent, node’s index plus one).\n\t\tthis.setStart(parent, getNodeIndex(node) + 1);\n\t}\n\n\t/**\n\t * Sets the end boundary point of the range to the position just before the given node.\n\t *\n\t * @param node - The node to set the range's end before\n\t */\n\tsetEndBefore(node: Node): void {\n\t\texpectArity(arguments, 1);\n\t\tnode = asObject(node, Node);\n\n\t\t// 1. Let parent be node’s parent.\n\t\tconst parent = node.parentNode;\n\n\t\t// 2. If parent is null, then throw an InvalidNodeTypeError.\n\t\tif (parent === null) {\n\t\t\treturn throwInvalidNodeTypeError('Can not set range before node without a parent');\n\t\t}\n\n\t\t// 3. Set the end of this to boundary point (parent, node’s index).\n\t\tthis.setEnd(parent, getNodeIndex(node));\n\t}\n\n\t/**\n\t * Sets the end boundary point of the range to the position just after the given node.\n\t *\n\t * @param node - The node to set the range's end before\n\t */\n\tsetEndAfter(node: Node): void {\n\t\texpectArity(arguments, 1);\n\t\tnode = asObject(node, Node);\n\n\t\t// 1. Let parent be node’s parent.\n\t\tconst parent = node.parentNode;\n\n\t\t// 2. If parent is null, then throw an InvalidNodeTypeError.\n\t\tif (parent === null) {\n\t\t\treturn throwInvalidNodeTypeError('Can not set range before node without a parent');\n\t\t}\n\n\t\t// 3. Set the end of this to boundary point (parent, node’s index plus one).\n\t\tthis.setEnd(parent, getNodeIndex(node) + 1);\n\t}\n\n\t/**\n\t * Sets the range's boundary points to the same position.\n\t *\n\t * @param toStart - If true, set both points to the start of the range, otherwise set them to\n\t *                  the end\n\t */\n\tcollapse(toStart: boolean = false): void {\n\t\tif (toStart) {\n\t\t\tthis.endContainer = this.startContainer;\n\t\t\tthis.endOffset = this.startOffset;\n\t\t} else {\n\t\t\tthis.startContainer = this.endContainer;\n\t\t\tthis.startOffset = this.endOffset;\n\t\t}\n\t}\n\n\tselectNode(node: Node): void {\n\t\texpectArity(arguments, 1);\n\t\tnode = asObject(node, Node);\n\n\t\t// 1. Let parent be node’s parent.\n\t\tlet parent = node.parentNode;\n\n\t\t// 2. If parent is null, then throw an InvalidNodeTypeError.\n\t\tif (parent === null) {\n\t\t\treturn throwInvalidNodeTypeError('Can not select node with null parent');\n\t\t}\n\n\t\t// 3. Let index be node’s index.\n\t\tconst index = getNodeIndex(node);\n\n\t\t// 4. Set range’s start to boundary point (parent, index).\n\t\tthis.startContainer = parent;\n\t\tthis.startOffset = index;\n\n\t\t// 5. Set range’s end to boundary point (parent, index plus one).\n\t\tthis.endContainer = parent;\n\t\tthis.endOffset = index + 1;\n\t}\n\n\tselectNodeContents(node: Node): void {\n\t\texpectArity(arguments, 1);\n\t\tnode = asObject(node, Node);\n\n\t\t// 1. If node is a doctype, then throw an InvalidNodeTypeError.\n\t\tif (isNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE)) {\n\t\t\tthrowInvalidNodeTypeError('Can not place range inside a doctype node');\n\t\t}\n\n\t\t// 2. Let length be the length of node.\n\t\tconst length = determineLengthOfNode(node);\n\n\t\t// 3. Set start to the boundary point (node, 0).\n\t\tthis.startContainer = node;\n\t\tthis.startOffset = 0;\n\n\t\t// 4. Set end to the boundary point (node, length).\n\t\tthis.endContainer = node;\n\t\tthis.endOffset = length;\n\t}\n\n\tstatic START_TO_START = 0;\n\tstatic START_TO_END = 1;\n\tstatic END_TO_END = 2;\n\tstatic END_TO_START = 3;\n\n\tcompareBoundaryPoints(how: number, sourceRange: Range): number {\n\t\texpectArity(arguments, 2);\n\t\tsourceRange = asObject(sourceRange, Range);\n\n\t\t// 1. If how is not one of START_TO_START, START_TO_END, END_TO_END, and END_TO_START, then\n\t\t// throw a NotSupportedError.\n\t\tif (\n\t\t\thow !== Range.START_TO_START &&\n\t\t\thow !== Range.START_TO_END &&\n\t\t\thow !== Range.END_TO_END &&\n\t\t\thow !== Range.END_TO_START\n\t\t) {\n\t\t\tthrowNotSupportedError('Unsupported comparison type');\n\t\t}\n\n\t\t// 2. If this’s root is not the same as sourceRange’s root, then throw a\n\t\t// WrongDocumentError.\n\t\tif (getRootOfRange(this) !== getRootOfRange(sourceRange)) {\n\t\t\tthrowWrongDocumentError('Can not compare positions of ranges in different trees');\n\t\t}\n\n\t\t// 3. If how is:\n\t\tswitch (how) {\n\t\t\t// START_TO_START:\n\t\t\tcase Range.START_TO_START:\n\t\t\t\t// Let this point be this’s start. Let other point be sourceRange’s\n\t\t\t\t// start.\n\t\t\t\treturn compareBoundaryPointPositions(\n\t\t\t\t\t// this point\n\t\t\t\t\tthis.startContainer,\n\t\t\t\t\tthis.startOffset,\n\t\t\t\t\t// other point\n\t\t\t\t\tsourceRange.startContainer,\n\t\t\t\t\tsourceRange.startOffset\n\t\t\t\t);\n\n\t\t\t// START_TO_END:\n\t\t\tcase Range.START_TO_END:\n\t\t\t\t// Let this point be this’s end. Let other point be sourceRange’s\n\t\t\t\t// start.\n\t\t\t\treturn compareBoundaryPointPositions(\n\t\t\t\t\t// this point\n\t\t\t\t\tthis.endContainer,\n\t\t\t\t\tthis.endOffset,\n\t\t\t\t\t// other point\n\t\t\t\t\tsourceRange.startContainer,\n\t\t\t\t\tsourceRange.startOffset\n\t\t\t\t);\n\n\t\t\t// END_TO_END:\n\t\t\tcase Range.END_TO_END:\n\t\t\t\t// Let this point be this’s end. Let other point be sourceRange’s end.\n\t\t\t\treturn compareBoundaryPointPositions(\n\t\t\t\t\t// this point\n\t\t\t\t\tthis.endContainer,\n\t\t\t\t\tthis.endOffset,\n\t\t\t\t\t// other point\n\t\t\t\t\tsourceRange.endContainer,\n\t\t\t\t\tsourceRange.endOffset\n\t\t\t\t);\n\n\t\t\t// END_TO_START:\n\t\t\tdefault:\n\t\t\t\t// Let this point be this’s start. Let other point be sourceRange’s\n\t\t\t\t// end.\n\t\t\t\treturn compareBoundaryPointPositions(\n\t\t\t\t\t// this point\n\t\t\t\t\tthis.startContainer,\n\t\t\t\t\tthis.startOffset,\n\t\t\t\t\t// other point,\n\t\t\t\t\tsourceRange.endContainer,\n\t\t\t\t\tsourceRange.endOffset\n\t\t\t\t);\n\t\t}\n\n\t\t// 4. If the position of this point relative to other point is\n\t\t// before: Return −1.\n\t\t// equal: Return 0.\n\t\t// after: Return 1.\n\t\t// (handled in switch above)\n\t}\n\n\t/**\n\t * Returns a range with the same start and end as this.\n\t *\n\t * @returns A copy of this\n\t */\n\tcloneRange(): Range {\n\t\tconst context = getContext(this);\n\t\tconst range = new context.Range();\n\t\trange.startContainer = this.startContainer;\n\t\trange.startOffset = this.startOffset;\n\t\trange.endContainer = this.endContainer;\n\t\trange.endOffset = this.endOffset;\n\t\treturn range;\n\t}\n\n\t/**\n\t * Stops tracking the range.\n\t *\n\t * (non-standard) According to the spec, this method must do nothing. However, it is not yet\n\t * possible in all browsers to allow garbage collection while keeping track of active ranges to\n\t * be updated by mutations. Therefore, unless your code will only run in environments that\n\t * implement the WeakRef proposal (https://github.com/tc39/proposal-weakrefs), make sure to call\n\t * this method to stop updating the range and free up its resources.\n\t */\n\tdetach(): void {\n\t\tconst context = getContext(this);\n\t\tcontext.removeRange(this);\n\t}\n\n\t/**\n\t * Returns true if the given point is after or equal to the start point and before or equal to\n\t * the end point of this.\n\t *\n\t * @param node   - Node of point to check\n\t * @param offset - Offset of point to check\n\t *\n\t * @returns Whether the point is in the range\n\t */\n\tisPointInRange(node: Node, offset: number): boolean {\n\t\texpectArity(arguments, 2);\n\t\tnode = asObject(node, Node);\n\t\toffset = asUnsignedLong(offset);\n\n\t\t// 1. If node’s root is different from this’s root, return false.\n\t\tif (getRootOfNode(node) !== getRootOfRange(this)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// 2. If node is a doctype, then throw an InvalidNodeTypeError.\n\t\tif (isNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE)) {\n\t\t\tthrowInvalidNodeTypeError('Point can not be under a doctype');\n\t\t}\n\n\t\t// 3. If offset is greater than node’s length, then throw an IndexSizeError.\n\t\tif (offset > determineLengthOfNode(node)) {\n\t\t\tthrowIndexSizeError('Offset should not be past the end of node');\n\t\t}\n\n\t\t// 4. If (node, offset) is before start or after end, return false.\n\t\tif (\n\t\t\tcompareBoundaryPointPositions(node, offset, this.startContainer, this.startOffset) ===\n\t\t\t\tPOSITION_BEFORE ||\n\t\t\tcompareBoundaryPointPositions(node, offset, this.endContainer, this.endOffset) ===\n\t\t\t\tPOSITION_AFTER\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// 5. Return true.\n\t\treturn true;\n\t}\n\n\t/**\n\t * Compares the given point to the range's boundary points.\n\t *\n\t * @param node   - Node of point to check\n\t * @param offset - Offset of point to check\n\t *\n\t * @returns -1, 0 or 1 depending on whether the point is before, inside or after the range,\n\t *         respectively\n\t */\n\tcomparePoint(node: Node, offset: number): number {\n\t\texpectArity(arguments, 2);\n\t\tnode = asObject(node, Node);\n\t\toffset = asUnsignedLong(offset);\n\n\t\t// 1. If node’s root is different from this’s root, then throw a\n\t\t// WrongDocumentError.\n\t\tif (getRootOfNode(node) !== getRootOfRange(this)) {\n\t\t\tthrowWrongDocumentError('Can not compare point to range in different trees');\n\t\t}\n\n\t\t// 2. If node is a doctype, then throw an InvalidNodeTypeError.\n\t\tif (isNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE)) {\n\t\t\tthrowInvalidNodeTypeError('Point can not be under a doctype');\n\t\t}\n\n\t\t// 3. If offset is greater than node’s length, then throw an IndexSizeError.\n\t\tif (offset > determineLengthOfNode(node)) {\n\t\t\tthrowIndexSizeError('Offset should not be past the end of node');\n\t\t}\n\n\t\t// 4. If (node, offset) is before start, return −1.\n\t\tif (\n\t\t\tcompareBoundaryPointPositions(node, offset, this.startContainer, this.startOffset) ===\n\t\t\tPOSITION_BEFORE\n\t\t) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t// 5. If (node, offset) is after end, return 1.\n\t\tif (\n\t\t\tcompareBoundaryPointPositions(node, offset, this.endContainer, this.endOffset) ===\n\t\t\tPOSITION_AFTER\n\t\t) {\n\t\t\treturn 1;\n\t\t}\n\n\t\t// 6. Return 0.\n\t\treturn 0;\n\t}\n\n\t/**\n\t * Returns true if range overlaps the range from before node to after node.\n\t *\n\t * @param node - The node to check\n\t *\n\t * @returns Whether the range intersects node\n\t */\n\tintersectsNode(node: Node): boolean {\n\t\texpectArity(arguments, 1);\n\t\tnode = asObject(node, Node);\n\n\t\t// 1. If node’s root is different from this’s root, return false.\n\t\tif (getRootOfNode(node) !== getRootOfRange(this)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// 2. Let parent be node’s parent.\n\t\tconst parent = node.parentNode;\n\n\t\t// 3. If parent is null, return true.\n\t\tif (parent === null) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// 4. Let offset be node’s index.\n\t\tconst offset = getNodeIndex(node);\n\n\t\t// 5. If (parent, offset) is before end and (parent, offset + 1) is after start, return\n\t\t// true.\n\t\t// 6. Return false.\n\t\treturn (\n\t\t\tcompareBoundaryPointPositions(parent, offset, this.endContainer, this.endOffset) ===\n\t\t\t\tPOSITION_BEFORE &&\n\t\t\tcompareBoundaryPointPositions(\n\t\t\t\tparent,\n\t\t\t\toffset + 1,\n\t\t\t\tthis.startContainer,\n\t\t\t\tthis.startOffset\n\t\t\t) === POSITION_AFTER\n\t\t);\n\t}\n}\n\nconst POSITION_BEFORE = -1;\nconst POSITION_EQUAL = 0;\nconst POSITION_AFTER = 1;\n\n/**\n * If the two nodes of boundary points (node A, offset A) and (node B, offset B) have the same root,\n * the position of the first relative to the second is either before, equal, or after.\n *\n * Note: for efficiency reasons, this implementation deviates from the algorithm given in 4.2.\n *\n * This implementation assumes it is called on nodes under the same root.\n *\n * @param nodeA   - First boundary point's node\n * @param offsetA - First boundary point's offset\n * @param nodeB   - Second boundary point's node\n * @param offsetB - Second boundary point's offset\n *\n * @returns -1, 0 or 1, depending on the boundary points' relative positions\n */\nfunction compareBoundaryPointPositions(\n\tnodeA: Node,\n\toffsetA: number,\n\tnodeB: Node,\n\toffsetB: number\n): number {\n\tif (nodeA !== nodeB) {\n\t\tconst ancestors1 = getInclusiveAncestors(nodeA);\n\t\tconst ancestors2 = getInclusiveAncestors(nodeB);\n\n\t\t// Skip common parents\n\t\twhile (ancestors1[0] && ancestors2[0] && ancestors1[0] === ancestors2[0]) {\n\t\t\tancestors1.shift();\n\t\t\tancestors2.shift();\n\t\t}\n\n\t\t// Compute offsets at the level under the last common parent. Add 0.5 to bias positions\n\t\t// inside the parent vs. those before or after.\n\t\tif (ancestors1.length) {\n\t\t\toffsetA = getNodeIndex(ancestors1[0]) + 0.5;\n\t\t}\n\t\tif (ancestors2.length) {\n\t\t\toffsetB = getNodeIndex(ancestors2[0]) + 0.5;\n\t\t}\n\t}\n\n\t// Compare positions at this level\n\tif (offsetA === offsetB) {\n\t\treturn POSITION_EQUAL;\n\t}\n\treturn offsetA < offsetB ? POSITION_BEFORE : POSITION_AFTER;\n}\n\n/**\n * The root of a range is the root of its start node.\n *\n * @param range - The range to get the root of\n *\n * @returns The root of range\n */\nfunction getRootOfRange(range: Range): Node {\n\treturn getRootOfNode(range.startContainer);\n}\n","import Document from './Document';\nimport { getContext } from './context/Context';\n\n/**\n * @public\n */\nexport default class XMLDocument extends Document {\n\t/**\n\t * (non-standard) Creates a copy of this, not including its children.\n\t *\n\t * @param document - The node document to associate with the copy\n\t *\n\t * @returns A shallow copy of this\n\t */\n\tpublic _copy(document: Document): XMLDocument {\n\t\t// Set copy’s encoding, content type, URL, origin, type, and mode, to those of node.\n\t\t// (properties not implemented)\n\n\t\tconst context = getContext(document);\n\t\treturn new context.XMLDocument();\n\t}\n}\n","export { default as Attr } from './Attr';\nexport { default as CDATASection } from './CDATASection';\nexport { default as CharacterData } from './CharacterData';\nexport { default as Comment } from './Comment';\nexport { default as Document } from './Document';\nexport { default as DocumentFragment } from './DocumentFragment';\nexport { default as DocumentType } from './DocumentType';\nexport { default as DOMImplementation } from './DOMImplementation';\nexport { default as Element } from './Element';\nexport { default as Node } from './Node';\nexport { default as ProcessingInstruction } from './ProcessingInstruction';\nexport { default as Range } from './Range';\nexport { StaticRange } from './Range';\nexport { default as Text } from './Text';\nexport { default as XMLDocument } from './XMLDocument';\nexport { default as XMLSerializer } from './dom-parsing/XMLSerializer';\nexport { default as MutationObserver } from './mutation-observer/MutationObserver';\nexport { default as MutationRecord } from './mutation-observer/MutationRecord';\nexport { DOMException } from './util/errorHelpers';\n\n// Standard DOM does not expose a way to serialize arbitrary nodes as well-formed XML\nexport { serializeToWellFormedString } from './dom-parsing/XMLSerializer';\n\n// Unsafe exports, required for connecting a HTML parser\nexport { unsafeCreateAttribute, unsafeCreateElement, unsafeAppendAttribute } from './unsafe';\n\n// To avoid cyclic dependencies and enable multiple contexts with their own constructors later,\n// inject all constructors as well as the global document into the default context (i.e., global\n// object) here.\nimport { defaultContext } from './context/Context';\n\nimport Attr from './Attr';\nimport CDATASection from './CDATASection';\nimport Comment from './Comment';\nimport Document from './Document';\nimport DocumentFragment from './DocumentFragment';\nimport DocumentType from './DocumentType';\nimport DOMImplementation from './DOMImplementation';\nimport Element from './Element';\nimport ProcessingInstruction from './ProcessingInstruction';\nimport Range from './Range';\nimport Text from './Text';\nimport XMLDocument from './XMLDocument';\n\n/**\n * The document associated with the global object. Used when calling constructors directly.\n *\n * Do not mutate this instance. When possible, it is recommended to use `new slimdom.Document` to\n * create a new document, and then use the factory methods on that instance to create other nodes.\n *\n * @public\n */\nexport const document = new Document();\ndefaultContext.document = document;\n\ndefaultContext.Attr = Attr;\ndefaultContext.CDATASection = CDATASection;\ndefaultContext.Comment = Comment;\ndefaultContext.Document = Document;\ndefaultContext.DocumentFragment = DocumentFragment;\ndefaultContext.DocumentType = DocumentType;\ndefaultContext.DOMImplementation = DOMImplementation;\ndefaultContext.Element = Element;\ndefaultContext.ProcessingInstruction = ProcessingInstruction;\ndefaultContext.Range = Range;\ndefaultContext.Text = Text;\ndefaultContext.XMLDocument = XMLDocument;\n","import MutationRecord from './MutationRecord';\nimport NotifySet from './NotifyList';\nimport RegisteredObserver from './RegisteredObserver';\nimport Node from '../Node';\nimport { expectArity } from '../util/errorHelpers';\nimport { asObject } from '../util/typeHelpers';\n\n/**\n * @public\n */\nexport interface MutationObserverInit {\n\t/**\n\t * Whether to observe childList mutations.\n\t */\n\tchildList?: boolean;\n\n\t/**\n\t * Whether to observe attribute mutations.\n\t */\n\tattributes?: boolean;\n\n\t/**\n\t * Whether to observe character data mutations.\n\t */\n\tcharacterData?: boolean;\n\n\t/**\n\t * Whether to observe mutations on any descendant in addition to those on the target.\n\t */\n\tsubtree?: boolean;\n\n\t/**\n\t * Whether to record the previous value of attributes.\n\t */\n\tattributeOldValue?: boolean;\n\n\t/**\n\t * Whether to record the previous value of character data nodes.\n\t */\n\tcharacterDataOldValue?: boolean;\n}\n\nexport type MutationCallback = (records: MutationRecord[], observer: MutationObserver) => void;\n\n/**\n * 3.3.1. Interface MutationObserver\n *\n * A MutationObserver object can be used to observe mutations to the tree of nodes.\n *\n * @public\n */\nexport default class MutationObserver {\n\t/**\n\t * The function that will be called when control returns to the event loop, if there are any\n\t * queued records. The function is passed the MutationRecords and the observer instance that\n\t * collected them.\n\t */\n\tpublic _callback: MutationCallback;\n\n\t/**\n\t * The list of nodes on which this observer is a RegisteredObserver's observer.\n\t */\n\tpublic _nodes: Node[] = [];\n\n\t/**\n\t * The list of MutationRecord objects collected so far.\n\t */\n\tpublic _recordQueue: MutationRecord[] = [];\n\n\t/**\n\t * Tracks transient registered observers created for this observer, to simplify their removal.\n\t */\n\tpublic _transients: RegisteredObserver[] = [];\n\n\t/**\n\t * Constructs a MutationObserver object and sets its callback to callback. The callback is\n\t * invoked with a list of MutationRecord objects as first argument and the constructed\n\t * MutationObserver object as second argument. It is invoked after nodes registered with the\n\t * observe() method, are mutated.\n\t *\n\t * @param callback - Function called after mutations have been observed.\n\t */\n\tconstructor(callback: MutationCallback) {\n\t\texpectArity(arguments, 1);\n\t\tcallback = asObject(callback, Function);\n\n\t\t// 1. Let mo be a new MutationObserver object whose callback is callback.\n\t\tthis._callback = callback;\n\n\t\t// 2. Append mo to mo's relevant agent's mutation observers.\n\t\t// (for efficiency, this implementation only tracks MutationObserver objects that have\n\t\t// records queued)\n\n\t\t// 3. Return mo.\n\t}\n\n\t/**\n\t * Instructs the user agent to observe a given target (a node) and report any mutations based on\n\t * the criteria given by options (an object).\n\t *\n\t * NOTE: Adding an observer to an element is just like addEventListener, if you observe the\n\t * element multiple times it does not make a difference. Meaning if you observe element twice,\n\t * the observe callback does not fire twice, nor will you have to run disconnect() twice. In\n\t * other words, once an element is observed, observing it again with the same will do nothing.\n\t * However if the callback object is different it will of course add another observer to it.\n\t *\n\t * @param target  - Node (or root of subtree) to observe\n\t * @param options - Determines which types of mutations to observe\n\t */\n\tobserve(target: Node, options: MutationObserverInit) {\n\t\texpectArity(arguments, 2);\n\t\ttarget = asObject(target, Node);\n\n\t\t// Defaults from IDL\n\t\toptions.childList = !!options.childList;\n\t\toptions.subtree = !!options.subtree;\n\n\t\t// 1. If either options[\"attributeOldValue\"] or options[\"attributeFilter\"] exists, and\n\t\t// options[\"attributes\"] does not exist, then set options[\"attributes\"] to true.\n\t\tif (options.attributeOldValue !== undefined && options.attributes === undefined) {\n\t\t\toptions.attributes = true;\n\t\t}\n\n\t\t// 2. If options[\"characterDataOldValue\"] exists and options[\"characterData\"] does not\n\t\t// exist, then set options[\"characterData\"] to true.\n\t\tif (options.characterDataOldValue !== undefined && options.characterData === undefined) {\n\t\t\toptions.characterData = true;\n\t\t}\n\t\t// 3. If none of options[\"childList\"], options[\"attributes\"], and options[\"characterData\"]\n\t\t// is true, then throw a TypeError.\n\t\tif (!(options.childList || options.attributes || options.characterData)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t'The options object must set at least one of \"attributes\", \"characterData\", or ' +\n\t\t\t\t\t'\"childList\" to true.'\n\t\t\t);\n\t\t}\n\n\t\t// 4. If options[\"attributeOldValue\"] is true and options[\"attributes\"] is false, then throw\n\t\t// a TypeError.\n\t\tif (options.attributeOldValue && !options.attributes) {\n\t\t\tthrow new TypeError(\n\t\t\t\t'The options object may only set \"attributeOldValue\" to true when \"attributes\" ' +\n\t\t\t\t\t'is true or not present.'\n\t\t\t);\n\t\t}\n\n\t\t// 5. If options[\"attributeFilter\"] exists and options[\"attributes\"] is false, then throw a\n\t\t// TypeError. (attributeFilter not yet implemented)\n\n\t\t// 6. If options[\"characterDataOldValue\"] is true and options[\"characterData\"] is false,\n\t\t// then throw a TypeError.\n\t\tif (options.characterDataOldValue && !options.characterData) {\n\t\t\tthrow new TypeError(\n\t\t\t\t'The options object may only set \"characterDataOldValue\" to true when ' +\n\t\t\t\t\t'\"characterData\" is true or not present.'\n\t\t\t);\n\t\t}\n\n\t\t// 7. For each registered registered of target’s registered observer list, if registered's\n\t\t// observer is this:\n\t\t// 7.1. For each node of this's node list, remove all transient registered\n\t\t// observers whose source is registered from node's registered observer list.\n\t\t// 7.2. Set registered’s options to options.\n\t\t// 8. Otherwise:\n\t\t// 8.1. Append a new registered observer whose observer is this and options is\n\t\t// options to target's registered observer list.\n\t\t// 8.2. Append target to this's node list.\n\t\ttarget._registeredObservers.register(this, options);\n\t}\n\n\t/**\n\t * Stops the MutationObserver instance from receiving notifications of DOM mutations. Until the\n\t * observe() method is used again, observer's callback will not be invoked.\n\t */\n\tdisconnect() {\n\t\t// 1. For each node of this’s node list, remove any registered observer from\n\t\t// node's registered observer list for which this is the observer.\n\t\tthis._nodes.forEach((node) => node._registeredObservers.removeForObserver(this));\n\t\tthis._nodes.length = 0;\n\n\t\t// 2. Empty this’s record queue.\n\t\tthis._recordQueue.length = 0;\n\t}\n\n\t/**\n\t * Empties the MutationObserver instance's record queue and returns what was in there.\n\t *\n\t * @returns An Array of MutationRecord objects that were recorded.\n\t */\n\ttakeRecords(): MutationRecord[] {\n\t\t// 1. Let records be a clone of this's record queue.\n\t\tconst records = this._recordQueue.concat();\n\t\t// 2. Empty this's record queue\n\t\tthis._recordQueue.length = 0;\n\t\t// 3. Return records\n\t\treturn records;\n\t}\n}\n","import Node from '../Node';\nimport { asObject } from '../util/typeHelpers';\nimport { produceXmlSerialization } from './serializationAlgorithms';\n\n/**\n * 2.2 The XMLSerializer interface\n *\n * @public\n */\nexport default class XMLSerializer {\n\t/**\n\t * Constructs a new XMLSerializer object.\n\t */\n\tpublic constructor() {}\n\n\t/**\n\t * Serializes root into a string using an XML serialization. Throws a TypeError exception if\n\t * root is not a Node.\n\t *\n\t * @param root - The node to serialize\n\t *\n\t * @returns The XML resulting from serialization\n\t */\n\tpublic serializeToString(root: Node): string {\n\t\troot = asObject(root, Node);\n\n\t\t// Produce an XML serialization of root passing a value of false for the require well-formed\n\t\t// parameter, and return the result.\n\t\tconst result: string[] = [];\n\t\tproduceXmlSerialization(root, false, result);\n\t\treturn result.join('');\n\t}\n}\n\n/**\n * Serializes root into a string using an XML serialization. Throws if the result would not be\n * well-formed XML.\n *\n * Non-standard: the dom-parsing spec does not provide a way to serialize arbitrary nodes while\n * enforcing well-formedness.\n *\n * @public\n *\n * @param root - The node to serialize\n *\n * @returns The XML resulting from serialization\n */\nexport function serializeToWellFormedString(root: Node): string {\n\troot = asObject(root, Node);\n\n\t// Produce an XML serialization of root passing a value of true for the require well-formed\n\t// parameter, and return the result.\n\tconst result: string[] = [];\n\tproduceXmlSerialization(root, true, result);\n\treturn result.join('');\n}\n","import Attr from './Attr';\nimport Document from './Document';\nimport { createElement, default as Element } from './Element';\nimport { appendAttribute } from './util/attrMutations';\n\n/**\n * Create an Attr node without the usual validation of the given names.\n *\n * @public\n *\n * @param namespace - The namespace URI for the new node\n * @param prefix    - The prefix for the new node\n * @param localName - The local name for the new node\n * @param value     - The value for the new node\n * @param element   - The owner element for the new node\n *\n * @returns A new Attr node with the given values\n */\nexport function unsafeCreateAttribute(\n\tnamespace: string | null,\n\tprefix: string | null,\n\tlocalName: string,\n\tvalue: string,\n\townerElement: Element | null\n): Attr {\n\treturn new Attr(namespace, prefix, localName, value, ownerElement);\n}\n\n/**\n * Create an Element node without the usual validation of the given names.\n *\n * @public\n *\n * @param document  - The node document for the new element\n * @param localName - The local name for the new element\n * @param namespace - The namespace URI for the new element, or null for the null namespace\n * @param prefix    - The prefix for the new element, or null for no prefix\n *\n * @returns The new element\n */\nexport function unsafeCreateElement(\n\tdocument: Document,\n\tlocalName: string,\n\tnamespace: string | null,\n\tprefix: string | null = null\n): Element {\n\treturn createElement(document, localName, namespace, prefix);\n}\n\n/**\n * Append an attribute attribute to an element without the usual checks.\n *\n * @public\n *\n * @param attribute - The attribute to append\n * @param element   - The element to append attribute to\n */\nexport function unsafeAppendAttribute(attribute: Attr, element: Element): void {\n\tappendAttribute(attribute, element);\n}\n"],"names":["RegisteredObserver","[object Object]","observer","node","options","source","this","_transients","push","type","target","data","interestedObservers","pairedStrings","subtree","attributes","characterData","childList","index","indexOf","length","undefined","attributeOldValue","characterDataOldValue","oldValue","RegisteredObservers","_node","registeredObservers","_registeredObservers","hasRegisteredObserverForObserver","forEach","registered","i","transientRegisteredObserver","removeTransientRegisteredObserver","splice","removeTransientRegisteredObserversForSource","_nodes","write","read","l","registeredObserver","collectInterestedObservers","registerTransient","queueMicrotaskWithAppropriateApi","callback","thisArg","args","queueMicrotask","Promise","resolve","then","apply","NotifySet","Set","record","_recordQueue","_notifySet","add","_mutationObserverMicrotaskQueued","_notifyMutationObservers","notifySet","Array","from","clear","mo","records","takeRecords","_callback","FakeWeakRef","_target","defaultContext","cb","numRanges","_ranges","r","deref","pop","range","WeakRef","getContext","instance","isNodeOfType","types","some","t","nodeType","determineLengthOfNode","childNodes","getInclusiveAncestors","ancestor","ancestors","unshift","parentNode","getNodeDocument","ownerDocument","getNodeIndex","getRootOfNode","forEachInclusiveDescendant","child","firstChild","nextSibling","getListOfElementsWithQualifiedName","qualifiedName","root","elements","element","nodeName","getListOfElementsWithNamespaceAndLocalName","namespace","localName","namespaceURI","cloneNode","cloneChildren","document","copy","_copy","appendChild","expectArity","minArity","TypeError","codeByName","IndexSizeError","HierarchyRequestError","WrongDocumentError","InvalidCharacterError","NotFoundError","NotSupportedError","InUseAttributeError","InvalidStateError","NamespaceError","InvalidNodeTypeError","DOMException","Error","message","name","super","code","stack","createDOMException","throwHierarchyRequestError","throwIndexSizeError","throwInvalidCharacterError","throwInvalidNodeTypeError","throwNamespaceError","throwNotFoundError","throwNotSupportedError","throwWrongDocumentError","asParentNode","getChildren","firstElementChild","nextElementSibling","asNonDocumentTypeChildNode","getPreviousElementSibling","sibling","previousSibling","getNextElementSibling","MutationRecord","queueMutationRecord","context","mappedOldValue","attributeName","attributeNamespace","addedNodes","removedNodes","appendRecord","queueMutationObserverMicrotask","ensurePreInsertionValidity","parent","contains","parentDocument","fragment","lastElementChild","documentElement","doctype","preInsertNode","referenceChild","adoptNode","insertNode","suppressObservers","isDocumentFragment","nodes","count","n","removeNode","childIndex","forEachRange","startContainer","startOffset","endContainer","endOffset","lastChild","previousElementSibling","siblingNonDocumentTypeChildNode","childElementCount","insertIntoChildren","appendNode","replaceChildWithNode","replaceAllWithNode","oldPreviousSibling","oldNextSibling","isElement","removeFromChildren","inclusiveAncestor","appendTransientRegisteredObservers","oldDocument","inclusiveDescendant","attr","getDescendantTextContent","descendant","join","stringReplaceAll","newValue","Text","convertNodesIntoNode","actualNodes","map","nodeOrString","Node","createTextNode","String","createDocumentFragment","prependNodes","thisObject","appendNodes","replaceChildren","insertNodesBefore","viablePreviousSibling","insertNodesAfter","viableNextSibling","replaceWithNodes","removeFromParent","asUnsignedLong","number","legacyNullToEmptyString","value","ifNullActAsIfEmptyString","asObject","Constructor","expectObject","asNullableObject","asNullableString","parentElement","nextNode","normalize","textNode","siblingsToRemove","replaceData","currentNode","currentNodeIndex","shift","deep","other","arguments","lookupNamespaceURI","preRemoveChild","handleAttributeChanges","attribute","changeAttribute","ownerElement","_value","appendAttribute","removeAttribute","attributeElement","prototype","ELEMENT_NODE","ATTRIBUTE_NODE","TEXT_NODE","CDATA_SECTION_NODE","ENTITY_REFERENCE_NODE","ENTITY_NODE","PROCESSING_INSTRUCTION_NODE","COMMENT_NODE","DOCUMENT_NODE","DOCUMENT_TYPE_NODE","DOCUMENT_FRAGMENT_NODE","NOTATION_NODE","Attr","prefix","nodeValue","setExistingAttributeValue","textContent","lookupPrefix","CharacterData","_data","offset","substringData","nodeData","newData","substring","newNode","indexOfNodePlusOne","splitText","wholeText","allData","CDATASection","Comment","DocumentType","publicId","systemId","_newValue","HTML_NAMESPACE","XML_NAMESPACE","XMLNS_NAMESPACE","NAME_REGEX_XML_1_0_FIFTH_EDITION","matchesNameProduction","test","validateQualifiedName","parts","split","every","part","isValidQName","validateAndExtract","locateNamespacePrefix","find","NamespacePrefixMap","Map","prefixes","_map","entries","set","concat","preferredPrefix","ns","candidatesList","get","CHAR_REGEX_XML_1_0_FIFTH_EDITION","PUBIDCHAR_REGEX_XML_1_0_FIFTH_EDITION","HTML_VOID_ELEMENTS","serializeFragment","requireWellFormed","withFictionalParent","result","produceXmlSerialization","prefixMap","prefixIndex","runXmlSerializationAlgorithm","error","throwInvalidStateError","skipEndTag","ignoreNamespaceDefinitionAttribute","localPrefixesMap","localDefaultNamespace","defaultNamespaceAttrValue","attributePrefix","prefixDefinition","namespaceDefinition","checkIfFound","recordNamespaceInformation","inheritedNs","candidatePrefix","retrievePreferredPrefixString","generatePrefix","serializeAttributeValue","localNameSet","tuple","serializeAttributes","hasChildNodes","serializeElementNode","serializeDocumentNode","comment","endsWith","serializeCommentNode","cs","serializeCDATASectionNode","text","markup","replace","serializeTextNode","serializeDocumentFragmentNode","dt","serializeDocumentTypeNode","pi","toLowerCase","serializeProcessingInstructionNode","attributeValue","newNamespace","generatedPrefix","Element","tagName","getAttributeNodeNS","children","getAttributeByName","getAttributeByNamespaceAndLocalName","validatedNamespace","setAttributeValue","removeAttributeByName","removeAttributeByNamespaceAndLocalName","force","setAttribute","copyElement","createElement","copyAttribute","setAttributeNode","innerHTML","outerHTML","throwInUseAttributeError","oldAttr","newAttr","oldAttrElement","replaceAttribute","createElementNS","DOMImplementation","_document","XMLDocument","title","doc","Document","htmlElement","headElement","titleElement","documentFragment","DocumentFragment","cdataSection","ProcessingInstruction","Range","addRange","collapsed","commonAncestorContainer","ancestors1","ancestors2","getRootOfRange","compareBoundaryPointPositions","POSITION_AFTER","POSITION_BEFORE","setStart","setEnd","toStart","how","sourceRange","START_TO_START","START_TO_END","END_TO_END","END_TO_START","removeRange","nodeA","offsetA","nodeB","offsetB","Function","register","removeForObserver","init"],"mappings":"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"}